<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android原生项目集成ReactNative混合开发]]></title>
    <url>%2F2018%2F08%2F03%2FAndroid%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90React-Native%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 12345678910npm init&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;&#125;npm install --save react react-native@版本号curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 配置原生安卓项目的Gradle12345678910111213141516171819202122232425allprojects &#123; repositories &#123; maven &#123; url &quot;$rootDir/node_modules/react-native/android&quot; &#125; jcenter() &#125;&#125;dependencies &#123; implementation &apos;com.facebook.react:react-native:版本号&apos;&#125;android &#123; defaultConfig &#123; ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &quot;armeabi-v7a&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; &#125; configurations.all &#123; resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos; &#125;&#125; 添加权限12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;/&gt;&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt; 添加React native入口在项目根目录下，新建index.js文件作为React Native控件配置页 Hello World示例 12345678910111213141516171819202122232425import React from &apos;react&apos;;import &#123;AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, &#125;, hello: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;,&#125;);AppRegistry.registerComponent(&apos;AndroidRnDemoApp&apos;, () =&gt; HelloWorld); 编译运行到安卓真机12adb reverse tcp:8081 tcp:8081npm start 打包新建assert资产文件 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/ 小结 本次Android集成了React Native0.51.0版本的环境（最新为0.56.0），采取了原生项目为主，编译和打包仍走安卓项目的Gradle流程 React Native集成过程中，由于Kotlin改写了模块iml文件里的某处标签信息，使得项目无法正常编译，往文件里手动添加如下标签得以修复： 1&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第七讲-泛型在Java和Kotlin上的横向比较]]></title>
    <url>%2F2018%2F07%2F16%2FKotlin%E7%AC%AC%E4%B8%83%E8%AE%B2-%E6%B3%9B%E5%9E%8B%E5%9C%A8Java%E5%92%8CKotlin%E4%B8%8A%E7%9A%84%E6%A8%AA%E5%90%91%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 阅读本文前，如果对Java泛型不够了解，不妨先阅读我之前写的两篇说Java泛型的文章 重拾Java泛型 上篇 重拾Java泛型 下篇 语法比较泛型方法Java 1234567891011public static&lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)&#123; Iterator&lt;? extends T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext())&#123; T t = iterator.next(); if(t.compareTo(result) &gt; 0)&#123; result = t; &#125; &#125; return result; &#125; Kotlin1234567891011fun &lt;T : Comparable&lt;in T&gt;&gt; max(list: List&lt;out T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 查看Kotlin里的Comparable类和List类源码，Comparable类定义，List类定义，所以可以不必重复表明Comparable的逆变能力和List的协变能力。 1234567891011fun &lt;T : Comparable&lt;T&gt;&gt; max(list: List&lt;T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 不管是泛型类还是泛型方法，泛型的使用分为两个步骤 第一步，声明泛型参数 第二步，才是使用泛型参数 上面的泛型方法，以Java泛型方法为例，泛型声明部分是： 1&lt;T extends Comparable&lt;? super T&gt;&gt; 引入泛型类型名称为T，这个数据类型的关系是实现Comparable的类。 使用泛型的部分如下： 1List&lt;? extends T&gt; 入参的集合具有对类型T的协变能力。 所以，有些书或者网上资料，会出现两个概念：声明点变型，使用点变型。这个概念说的就是这件事 再来看下in位置，和out位置的概念 所以，类型参数T上的关键字out有两方面含义： 具有协变的能力 T只能用在out位置 我们再看一个有趣的例子 我有一个方法，入参的一个集合，我希望入参集合元素是EditText的子类的集合，如何构建满足这个关系的方法呢？至少有下面的两种方式： 1234567fun test2(list: MutableList&lt;out EditText&gt;)&#123;&#125;fun &lt;T: EditText&gt;test3(list: MutableList&lt;T&gt;)&#123;&#125; 上面test2， test3方法都能实现预期的效果。不同的是，test2使用协变来实现，也意味着只能读不能写操作，test2不是泛型方法。test3方法通过在声明表明泛型参数的类型关系来实现，可读可写，它是泛型方法。 对应的Java代码如下 private void test2(List&lt;? extends EditText&gt; list){ } private &lt;T extends EditText&gt; void test3(List&lt;T&gt; list){ } 实现泛型参数多约束Java 123private &lt;T extends Serializable &amp; CharSequence&gt; void ensureTrailingPeriod(T seq)&#123; &#125; kotlin 123fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T: Serializable, T: CharSequence&#123; &#125; 这是Java语法上很大的不同，Kotlin要实现多约束，使用到where关键词，这是全新的表示法。 实化类型参数来看一段Java代码： private &lt;T&gt; void test(T t){ if(t instanceof String){ String s = (String)t; }else if(t instanceof Integer){ Integer i = (Integer)t; } } 入参是泛型的，通过instanceof来判断泛型具体是哪个类型。再看一段代码 private &lt;T&gt; void test2(Object o){ //编译不通过 if(o instanceof T){ } } 泛型作为参数类型时，编译不通过。如果要完成上述的逻辑，要怎么实现？可以通过class近似等效实现 class ClassJudge&lt;T&gt;{ Class&lt;T&gt; kind; public ClassJudge(Class&lt;T&gt; kind) { this.kind = kind; } public boolean isInstance(Object o){ return kind.isInstance(o); } } 调用 Integer a = 12; boolean instance = new ClassJudge&lt;String&gt;(String.class).isInstance(a); System.out.println(&quot;instance = &quot; + instance); Kotlin在语言层面作出了支持，对上述Java代码test2方法，kotlin代码如下： 12345inline fun&lt;reified T&gt; test2(any: Any)&#123; if(any is T)&#123; &#125;&#125; 因此需要具备两个条件： 是内联函数 inline 关键词 reified 集合协变在Kotlin里，非空类型是可空类型的子类型。 Java实现的协变 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); Kotlin实现的协变 1val list: MutableList&lt;out Number&gt; = arrayListOf&lt;Int&gt;() 集合逆变Java实现的逆变 1List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;(); 对应的Kotlin逆变的实现： 1val list: MutableList&lt;in Int&gt; = arrayListOf&lt;Number&gt;() 变型（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。 由此可见，在泛型里，extends 不全等于 ：。extends代表子类型关系和协变，而Kotlin的 ：只代表子类型关系。 12&lt;out T&gt; = &lt;? extends T&gt;&lt;in T&gt; = &lt;? super T&gt; 星投影和Java无限制通配符？差异星投影如何使用 12&lt;*&gt; = &lt;out Any?&gt;&lt;*&gt; = &lt;in nothing&gt; 投影一词，顾名思义，是对Any？的投影，获得了Any？部分的能力—Any？协变的能力，即失去写操作，只能读操作。 12345fun printFirst(list: List&lt;*&gt;)&#123; if(list.isNotEmpty())&#123; println(list.first()) &#125;&#125; 场景二：泛型类存储所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化到一个分开的位置，预防了误用，保证了它不会被错误地使用。 其他非空性与泛型Java和Kotlin默认，泛型参数都是可空的，以Kotlin为例 12345class Processor&lt;T&gt; &#123; fun process(value: T)&#123; value?.hashCode() &#125;&#125; 泛型参数是可空类型，可以理解为默认实现&lt;T: Any?&gt;，因此要实现非空类型，只需&lt;T: Any&gt;，如下 12345class Processor2&lt;T: Any&gt; &#123; fun process(value: T)&#123; value.hashCode() &#125;&#125; 所以，泛型 和&lt;T: Any&gt;是有区别的，前者是可空类型，后者是非空类型，确切说，和&lt;T:Any?&gt;等效 小结Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 ##参考资料 仔细说说Java中的泛型 Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ Java 泛型进阶 Java为什么要添加运行时获取泛型的方法 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第六讲-委托类和属性]]></title>
    <url>%2F2018%2F06%2F12%2FKotlin%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%A7%94%E6%89%98%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 委托类实现一个接口，可以使用by关键字将接口实现委托给另一个对象。 1234567891011121314151617181920212223interface OnClickListener&#123; fun onClick() fun onLongClick()&#125;class ViewClickDelegate : OnClickListener&#123; override fun onClick()&#123; println(&quot;ViewClickDelegate onClick&quot;) &#125; override fun onLongClick() &#123; println(&quot;ViewClickDelegate onLongClick&quot;) &#125;&#125;class View(val name: String, onClickListener: OnClickListener) : OnClickListener by onClickListener&#123; override fun onLongClick() &#123; println(&quot;$name onLongClick&quot;) &#125;&#125; 类委托后我们依然可以通过重写的方式来覆盖委托类的实现，这里View实现onLongClick方法，覆盖重写了ViewClickDelegate类里的onLongClick方法。 类委托的本质是：把抽象方法的实现交给了by后的委托对象 延迟初始化和委托属性延迟初始化属性不在对象创建的时候初始化，而是在第一次使用时初始化。完成后像普通属性一样使用 123456789101112open class Food(val name: String) &#123; override fun toString(): String &#123; return &quot;[$name]&quot; &#125;&#125;class Container(val name: String) &#123; lateinit var foodList: List&lt;Food&gt;&#125; 惰性初始化属性第一次使用该属性时才初始化，且只初始化一次。用旗号标示是否初始化过，旗号有多种选择和实现方式。 在代码定义处执行初始化，有助于代码维护。 对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。 普通实现12345678910class Container2(val name: String) &#123; private var _foodList: List&lt;Food&gt;? = null val foodList: List&lt;Food&gt; get() &#123; if (_foodList == null) &#123; _foodList = arrayListOf(Food(&quot;米糊&quot;)) &#125; return _foodList!! &#125;&#125; by lazy(){}实现惰性初始化1234567891011121314151617181920class Container4(val name: String) &#123; val food: Food by lazy&#123; Food(&quot;米糊&quot;) &#125;&#125;//指定锁class Container5(val name: String) &#123; val food: Food by lazy(Container5::class)&#123; Food(&quot;米糊&quot;) &#125;&#125;//默认 线程安全 SYNCHRONIZED//PUBLICATION，同步锁不是必需的，允许多个线程同时执行class Container6(val name: String) &#123; val food: Food by lazy(LazyThreadSafetyMode.SYNCHRONIZED)&#123; Food(&quot;米糊&quot;) &#125;&#125; 在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性，索引属性；关联属性，限制属性。接下来看下Kotlin如何实现关联属性和限制属性的 关联属性（可观察属性）通过PropertyChangeSupport代码实现属性监听12345678910111213141516171819class Shelf(val name: String, _book: Book) &#123; private val propertyChange: PropertyChangeSupport = PropertyChangeSupport(this) var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把逻辑封装，抽取出基类 123456789101112131415161718192021222324252627282930open class BasePropertyChange &#123; val propertyChange = PropertyChangeSupport(this) protected fun addChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(key, propertyChangeListener) &#125; protected fun removeChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(key, propertyChangeListener) &#125;&#125;class Shelf_2(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把book里的set访问器的逻辑封装成一个类 123456789101112131415161718192021222324252627282930class BookDelegate(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book fun getValue(): Book = field fun setValue(value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf2(val name: String, _book: Book) : BasePropertyChange() &#123; val _bookDelegate: BookDelegate = BookDelegate(_book, propertyChange) var book: Book set(value) &#123; _bookDelegate.setValue(value) &#125; get() = _bookDelegate.getValue() fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 至此，我们用Kotlin手工实现了可观察属性变化的功能，测试下 12345678910111213fun testObserverField() &#123; val shelf = Shelf2(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt.newValue as Book println(&quot;old book = $oldBook , new book = $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行上述代码结果如下： old book = Book(name=Think in java) , new book = Book(name=Kotlin in action) 使用Kotlin委托实现Kotlin的委托属性在语言层面提供了在属性的读访问器里调用委托类里operator修饰的两参数getValue方法，属性写访问器调用operator修饰setValue三个参数方法 12345678910111213141516171819202122232425class BookDelegate2(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book operator fun getValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;): Book = field operator fun setValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;, newValue: Book) &#123; val oldBook = field field = newValue propertyChange.firePropertyChange(&quot;book&quot;, oldBook, newValue) &#125;&#125;class Shelf3(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate2(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 通常借助ReadWriteProperty接口能方便我们实现委托 12345678910111213141516171819202122232425class BookDelegate3(var field: Book, val propertyChange: PropertyChangeSupport) : ReadWriteProperty&lt;Shelf3_1, Book&gt; &#123; override fun getValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;): Book &#123; return field &#125; override fun setValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;, value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf3_1(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate3(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 测试上述代码： 1234567891011121314fun testDelegateFieldForKotlin() &#123; val shelf = Shelf3_1(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt?.newValue as Book println(&quot;Kotlin委托 old book is $oldBook, and new book is $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action!&quot;)&#125; 运行结果如下： Kotlin委托 old book is Book(name=Think in java), and new book is Book(name=Kotlin in action!) 委托属性的本质：把属性访问器的实现交给了by后的委托对象 使用Kotlin的自带的实现可观察属性其实，Delegate.observable()类实现了上面提到的所有逻辑了。 我们看下Delegate.observable方法的源码 1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 该方法返回ObservableProperty对象，看下ObservableProperty对象源码 1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 该对象有getValue和setValue方法，这和我们自己实现的BookDelegate3类里的getValue和setValue方法逻辑几乎相同。不同之处是，官方还多了beforeChange()控制，和afterChange()供实现类覆盖重写。 Kotlin标准库已经提供了可观察属性的属性委托实现了 123456class Shelf4(val name: String, _book: Book) &#123; var book: Book by Delegates.observable(_book, &#123;property, oldValue, newValue -&gt; println(&quot;The old book&apos;s name is \&quot;$&#123;oldValue.name&#125;\&quot;, and the new book&apos;s name is \&quot;$&#123;newValue.name&#125;\&quot;&quot;) &#125;)&#125; 测试下上述的代码 1234fun testObserverFieldForKotlin()&#123; val shelf = Shelf4(&quot;书架&quot;, Book(&quot;think in java&quot;)) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行结果如下 The old book’s name is “think in java”, and the new book’s name is “Kotlin in action” 限制属性Kotlin也为我们提供了现成的委托类来实现限制属性 12345class Shelf5(val name: String, val book: Book ,_year: Int) &#123; var year: Int by Delegates.vetoable(_year, &#123;property, oldValue, newValue -&gt; newValue &lt;= 99 &#125;)&#125; 测试上述代码 12345678fun testVetoableFieldForKotlin()&#123; val shelf = Shelf5(&quot;书架&quot;, Book(&quot;think in java&quot;), 0) shelf.year = 200 println(&quot;current book is $&#123;shelf.year&#125;&quot;) shelf.year = 20 println(&quot;current book is $&#123;shelf.year&#125;&quot;)&#125; 运行结果如下： current book is 0current book is 20 注意：上述用的是成员函数，事实上，扩展函数也能实现委托属性 使用Map实现委托属性MapAccessors.kt文件里，有如下扩展函数源码 1234567891011@kotlin.jvm.JvmName(&quot;getVarContravariant&quot;)@kotlin.internal.LowPriorityInOverloadResolution@kotlin.internal.InlineOnlypublic inline fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V = @Suppress(&quot;UNCHECKED_CAST&quot;) (getOrImplicitDefault(property.name) as V)@kotlin.internal.InlineOnlypublic inline operator fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) &#123; this.put(property.name, value)&#125; 由此可见， MutableMap存在getValue方法和setValue方法，那么就可以用于委托，事实上，也确实如此。 举个例子: 123456789101112131415161718192021class Fruit(name: String) : Food(name)&#123; private val attributeMap = HashMap&lt;String, String&gt;() val color: String by attributeMap val size: String by attributeMap fun setAttributeMap(name: String, value: String)&#123; attributeMap.put(name, value) &#125;&#125;fun testDelegateMap()&#123; val fruit = Fruit(&quot;西瓜&quot;) fruit.setAttributeMap(&quot;color&quot;, &quot;绿色&quot;) fruit.setAttributeMap(&quot;size&quot;, &quot;2kg&quot;) println(&quot;color = $&#123;fruit.color&#125;, size = $&#123;fruit.size&#125;&quot;)&#125; 运行结果 color = 绿色, size = 2kg 小结类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 参考资料维基百科：惰性初始化模式 维基百科：惰性求值]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第五讲-Kotlin的类型和空处理]]></title>
    <url>%2F2018%2F06%2F03%2FKotlin%E7%AC%AC%E4%BA%94%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 ##Kotlin的类型类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 以字符串类型举例，字符串平台类型如下： String！ 程序员不能使用这种语法，Java代码转Kotlin代码的时候会出现，表示可控性未知，也可以理解为己有肯能是非空类型也有可能是可空类型 ####非空类型和可空类型的理解可空类型 = 非空类型 + null Type? = Type + null 因此，String？，String是两种不同的数据类型，就像Int和String是两种数据类型那般。 ###基本数据类型Kotlin不区分基本数据类型和包装类型，都是使用一种基本类型： 下面是非空基本类型 Char, Boolean, Byte, Short, Int，Long, Float, Double 可空基本类型 Char？, Boolean?, Byte?, Short?, Int?，Long?, Float?, Double? Kotlin的基本类型如果转成Java基本数据类型，要怎么办？ 对于变量、属性、参数和返回类型，Kotlin的基本类型会被编译成Java的基本数据类型。用作泛型类型参数的基本数据类型会被编译成对应的Java包装类型。 注意： 和Java不同，小范围的值不能自动转化为大范围的值，而是看成两种不同的类型 下面的代码演示了数据类型的表示，各类型转化，数据类型智能推断，字符串类型转成基本数据类型 1234567891011121314151617181920212223242526272829303132333435fun testBasicType() &#123; val bb: Byte = 127 val boolean = false val aa: Char = &apos;a&apos; var i: Int = 21_4748_3647 //10位 var l: Long = 922_3372_0368_5477_5807L //19位 //不存在小写的l val f: Float = 123f val f2: Float = 124F val a16 = 0x123ef3 val b16 = 0XcCCef3 val c2 = 0b1010 val cc2 = 0B11001 val b: Byte = 1 val eas = b + 1L //Long + Byte =&gt; Long , eas为Long类型 fun foo(l: Long) &#123; println(l) &#125; foo(44) //单独写44可能是byte，int long，这里智能推断44会被认为是long //字符串转基本数据类型 val p = &quot;44&quot;.toInt() val p2 = &quot;44&quot;.toLong() val p3 = &quot;44&quot;.toFloatOrNull() val p4 = &quot;44&quot;.toDouble() val translate = l.toInt().toLong().toFloat().toDouble().toInt()&#125; ###Any，Unit，Nothing类型 Any 相当于 Object，不同点：是非空类型，缺少Object的wait，notify方法 Unit相当于Java的Void；不同点：Unit是一个完备的类型，可以作为类型参数。Unit是Any的子类 Nothong表明函数不会有返回类型（没有返回类型），该函数不会正常终止，Nothing是Unit的子类 1234567891011121314151617181920212223242526272829303132fun getStrinLenght(s: String?): Int &#123; if (s == null) &#123; throw IllegalArgumentException() &#125; else &#123; return s.length &#125;&#125;fun fail(): Nothing = throw IllegalArgumentException()fun getStrinLenght2(s: String?): Int = if (s == null) &#123; fail() &#125; else &#123; s.length &#125;fun testAnyAndNothing(o: Any?): View &#123; val filterO = o ?: fail() return when (filterO) &#123; is View -&gt; &#123; View(&quot;View&quot;) &#125; is TextView -&gt; &#123; TextView(&quot;TextView&quot;, &quot;&quot;) &#125; else -&gt; &#123; fail() &#125; &#125;&#125; 可以认为：throw IllegalArgumentException()返回的类型是Nothing，nothing是Int的子类型。 ####小结Any，Unit和Nothing三者关系： A Whirlwind Tour of the Kotlin Type Hierarchy ##空安全相关的运算符 ###安全调用？.如果值是null，整个表达式的值为null。 12345678open class Company(val name: String, val address: String?)fun testNullType()&#123; val company = Company(&quot;京东&quot;, null) val length = company.address?.length println(&quot;length = $length&quot;)&#125; ###Elvis运算符 ？： 12345678910fun testElvis(list: List&lt;Company?&gt;?, defaultAddress: String?)&#123; val defaultAdd = defaultAddress ?: &quot;&quot; val length = defaultAddress?.length ?: 0 //.?为空调用，表达式返回null，遇到了？： println(&quot;defaultAdd = $defaultAdd, length = $length&quot;) val companyList = list ?: throw IllegalArgumentException(&quot;null list&quot;) val address = companyList[0]?.address?.toUpperCase() ?: defaultAddress //多重空安全调用和Elvis联合使用 println(&quot;address = $address&quot;)&#125; ###安全转换as?as？运算法尝试把值转换成制定的类型，如果值不是合适的类型就返回null。 1234567891011121314151617181920212223open class View(val name: String)class TextView(name: String, val text: String) : View(name)fun testAsClient()&#123; val company = Company(&quot;JD&quot;, &quot;亦庄&quot;) testAs(company) testAs2(company) val tv = TextView(&quot;TextView&quot;, &quot;I am a message content&quot;) testAs2(tv)&#125;fun testAs(o: Any)&#123; val tv = o as TextView println(&quot;name = $&#123;tv.name&#125;&quot;)&#125;fun testAs2(o: Any)&#123; val tv = o as? TextView ?: TextView(&quot;Default TextView&quot;, &quot;&quot;) println(&quot;The content of $&#123;tv.name&#125; is = $&#123;tv.text&#125;&quot;)&#125; ###非空断言 !! 把任何值转换成非空类型 12345678910fun testNoNullClient()&#123; val result = testNoNull(&quot;Kotlin&quot;) println(&quot;result = $result&quot;)&#125;fun testNoNull(s: String?) : String&#123; val length = s!!.length println(&quot;$s&apos;s length is $length&quot;) return s!!.toUpperCase()&#125; ###let函数 把可空值作为实参传递一个只接收非空值的函数 1234567891011121314151617fun testLet()&#123; val length = getTheBigCompanyInTheWorld().address?.length val upperCase = getTheBigCompanyInTheWorld().address?.toUpperCase() val letter = getTheBigCompanyInTheWorld().address?.get(0) println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;)&#125;fun testLet2()&#123; getTheBigCompanyInTheWorld().address?.let &#123; val upperCase = it.toUpperCase() val length = it.length val letter = it[0] println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;) &#125;&#125;fun getTheBigCompanyInTheWorld(): Company = Company(&quot;JD&quot;, &quot;Beijing&quot;) ###可空类型的扩展函数 允许接收者为null的调用，在扩展函数内部处理null。不需要安全调用了 看几个Kotlin标准库，String定义的扩展函数isNullOrEmpty 123public inline fun CharSequence?.isNullOrEmpty(): Boolean &#123; return this == null || this.length == 0&#125; 注意： 在Java中，this永远是非空的，在Kotlin中，this可以为null。 因此在定义扩展函数时，需要考虑扩展是否需要为可空类型定义。本质上是对null在哪个环节处理的思考，是要在调用时使用空安全调用处理呢，还是在调用的函数内部处理。 ###泛型参数默认是可空类型 1234567fun &lt;T&gt; myPrintln(t: T)&#123; println(t.toString())&#125;fun testGenericityClient()&#123; myPrintln(null)&#125; ###转Java代码为Kotlin代码时，对空的处理 ####带注解的Java变量翻译到Kotlin时被认为是可空类型或者非空类型 Javax.annotation包下 android.support.annotation包下 org.jetbrains.annotations下 @Nullable + Type = Type?@NotNull + Type = Type ##参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第四讲-Kotlin的类、对象和接口]]></title>
    <url>%2F2018%2F05%2F27%2FKotlin%E7%AC%AC%E5%9B%9B%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 类类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 为了简化，Kotlin支持步骤2和步骤1合并操作，在主构造函数参数前加var/val； 支持步骤3和步骤2合并，对定义的属性直接赋值。支持步骤3和步骤2和步骤1合并操作，使用主构造函数的默认参数表达。 当然这些合并带来简便的同时，降低了构造的能力。 最初的状态（步骤1，步骤2，步骤3都存在） 123456789class User(_sickName: String)&#123; val sickName: String init &#123; println(&quot;init&quot;) sickName = _sickName &#125;&#125; 步骤2和步骤1的合并，在主构造函数里传参和定义类的属性 123456class User(val sickName: String)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 步骤3，步骤2和步骤1的合并 123456open class User private constructor(val sickName: String = &quot;Kotlin&quot;, var age: Int)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 注意：Java中需要重载构造方法的场景大多数都被Kotlin参数默认值和参数命名的语法特性涵盖了 子类的构造方法 123456789101112131415 open class AirBook(name: String, val year: Int, val size: Int) &#123; constructor(name: String, year: Int) : this(name, year, 22)&#123; println(&quot;constructor&quot;) &#125;&#125; class MacBookPro: AirBook&#123; public constructor(name: String, year: Int) : super(name, year) &#123; &#125; public constructor(name: String, year: Int, size: Int) : super(name, year, size)&#123; &#125;&#125; 子类在创建的时候，必须调用父类的构造函数，如果其父类还有父类，仍然要调用父类的父类的构造函数，直至顶层的基类。 12345678open class AirBook(name: String, val year: Int, val size: Int)&#123; init &#123; &#125; constructor(name: String, year: Int) : this(name, year, 22)&#123; &#125;&#125; 构造函数可以调用当前自身的构造函数，因为自身的构造函数必然有至少一个调用了父类的构造函数。 属性访问器在kotlin里，一个属性 = 字段 + 属性访问器；这里的字段是Java里的成员变量 属性访问器分为读访问器getter，和写访问器setter 访问器里存在field字段，用来连接写访问器和读访问器，作为两者的通信桥梁 val修饰的属性只有读访问器，var修饰的属性既有有读也有写访问器 Kotlin引入属性访问器后，凡事对属性进行赋值操作，就会调用属性的写访问器setter；读取值的操作对应调用的是属性的读访问器 那么如果我们要自定义一个类似Java里的setter方法，要怎么做呢？ 通过var变量的私有setter来实行 代码如下: 12345678910class TableLamp(val name: String, lightness: Int)&#123; var lightness: Int = 1 private set fun setupLightness(lightness: Int)&#123; this.lightness = lightness println(&quot;setupLightness lightness = $lightness&quot;) &#125;&#125; 这样对属性lightness的修改，只能通过setupLightness方法。 修饰词final, open, abstract相互影响和使用Kotlin的函数，类默认是final的，如果想重写函数，类有子类，则需使用open修饰。abstract修饰的函数和类，意味着有open的特性。这和Java的用法是一致的。 Kotlin自带的特殊类数据类，嵌套类，内部类，密封类的基本写法这里就略去不谈。 数据类datadata修饰的类，必须有主构造函数，且主构造每个入参必须都val或var修饰 data修饰补充的方法里的所用的变量取决于主构造函数的入参 嵌套类和内部类定义在某个类内部并用inner修饰的类称为内部类 嵌套类可以类比Java的静态内部类，Kotlin的内部类类比Java的内部类，他们含有外部类的引用。与Java内部类不同的是，Kotlin的内部类能对外部类的变量进行写操作。 举个例子 123456789class TextView&#123; var counter: Int= 0 inner class Operator&#123; fun calculate()&#123; counter ++ &#125; &#125;&#125; 内部类Operator的成员函数可以写外部类的counter属性，这在Java里是做不到的。 密封类sealed关键词修饰的类，表达有限个子类。 123456789sealed class Color constructor(val name: String)class Red : Color(&quot;Red&quot;)class Green : Color(&quot;Green&quot;)class Blue : Color(&quot;Blue&quot;)class Gray : Color(&quot;Gray&quot;) 上述写法，编译器就会知道，Color的子类的数量，此例Color一共只有四个子类，分别是：Red，Green， Blue， Gray。如果增加或删除Color的子类，编译器是能感知到的。密封类的子类可以作为嵌套类，也可以写在密封类所在的文件里，但是不能写在其他文件里。 举个和When搭配的应用例子： 12345678910111213141516171819fun testSealed(color: Color): Int = when (color) &#123; is Red -&gt; &#123; println(&quot;Red&quot;) 1 &#125; is Green -&gt; &#123; println(&quot;Green&quot;) 2 &#125; is Blue -&gt; &#123; println(&quot;Blue&quot;) 3 &#125; is GRAY -&gt;&#123; println(&quot;GRAY&quot;) 4 &#125; &#125; 密封类的意义：如果不用密封类，使用when总是不得不添加一个默认分支。更重要的是，如果你添加了一个新的子类，编译器并不能发现有地方改变了。如果你忘记了添加一个分支，就会选择默认的选项，这可能导致潜在的bug。 使用密封类就能解决上述的问题。 Object的使用声明一个类并创建一个对应的实例。与类一样，对象可以包含属性，方法，初始化语句块等的声明。对象声明可以继承类和实现接口，尤其不包含状态的时候很适用，也可以有扩展函数。 对象声明创建单一的实例，对象声明在定义的时候就创建了，不需要在代码的其他地方调用构造方法。 因此，对象声明不允许有构造函数。 123456object NameComparator : Comparator&lt;String&gt;&#123; override fun compare(o1: String, o2: String): Int &#123; return o1.compareTo(o2, true) &#125;&#125; Java调用上述代码，则需要通过INSTANCE来调用，如下 1CaseInsensitiveFileComparator.INSTANCE.compare(&quot;abc&quot;, &quot;abe&quot;); 伴生对象创建单一的实例，可以实现Java里访问类的私有成员的静态方法 在对象声明的基础上，使用companion关键字来标记，这样做就获得了直接通过容器类名称来访问这个对象的方法和属性的能力。 举个例子，实现CarFactory工厂 通过对象声明的实现 1234567891011class CarFactory&#123; object Instance&#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.Instance.newCar(&quot;Mini Cooper&quot;) 通过伴生对象的实现 1234567891011class CarFactory&#123; companion object &#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.newCar(&quot;Mini Cooper&quot;) 对象表达式既然是表达式，就意味着有返回值 与Java的匿名内部类只能扩展一个类或者实现一个接口不同，Kotlin的匿名对象可以实现多个接口或者不实现接口。 与对象声明不通，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。在对象表达式里不经可以访问创建它的函数中的变量，还可以修改变量的值 举个例子 12345678910fun countClick(view: View)&#123; var clickCount = 0 view.addClick(object : IClick&#123; override fun onClick() &#123; clickCount ++ &#125; &#125;)&#125; 小结object对象在Kotlin中的意义： 实现Java里静态的功能，等效实现静态调用 代替Java匿名内部类书写 接口123456789interface IFocus &#123; val focusName: String fun showOff()&#123; println(&quot;IFocus foucusName length = $&#123;focusName.length&#125;&quot;) &#125; fun onFocus()&#125; IFocus接口声明函数，让子类实现，默认方法showOff，和抽象方法onFucus 123456789class View : IFocus&#123; override val focusName: String get() = &quot;View&quot; override fun onFocus() &#123; showOff() &#125; &#125; View实现IFocus接口，focusName由View来确定，获取focusName逻辑写在IFocus的默认方法里。调用如下 val view = View() view.onFocus() 调用返回内容 IFocus foucusName length = 4 其他访问权限修饰词protected在Kotlin和Java的区别kotlin中protected只能是其子类和自身才能访问；Java中则是同包下所有文件和不同包的子类能访问 Kotiln访问权限由小到大排列依次是：private, protected, internal, public Kotlin函数和属性默认是public的，Java的默认是包级访问范围，即同一个包下的类能访问。Kotlin缺少包级别访问控制，而多了一个模块访问范围internal。internal表示同一个项目模块下的类都能访问 参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第三讲-拓展函数及其他]]></title>
    <url>%2F2018%2F05%2F07%2FKotlin%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 1234567891011121314151617181920212223242526public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123; override fun add(element: E): Boolean override fun remove(element: E): Boolean override fun addAll(elements: Collection&lt;E&gt;): Boolean public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean override fun removeAll(elements: Collection&lt;E&gt;): Boolean override fun retainAll(elements: Collection&lt;E&gt;): Boolean override fun clear(): Unit public operator fun set(index: Int, element: E): E public fun add(index: Int, element: E): Unit public fun removeAt(index: Int): E override fun listIterator(): MutableListIterator&lt;E&gt; override fun listIterator(index: Int): MutableListIterator&lt;E&gt; override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;&#125; MutableList接口提供了增加和删除集合元素的能力。 创建不可变集合val list = listOf&lt;String&gt;(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val letter = list[0] var list1 = listOfNotNull&lt;Int&gt;(1, 4, 8) 创建可变集合val list2 = arrayListOf&lt;Int&gt;(1, 2, 3, 4) list2.set(0, 10) list2[0] = 10 list2.add(5) println(&quot;list2 = $list2&quot;) val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.add(&quot;d&quot;) println(&quot;e = $list3&quot;) println(&quot;last element = ${list3.last()}&quot;) val list4 = mutableMapOf&lt;String, String&gt;(&quot;1&quot; to &quot;A&quot;, &quot;2&quot; to &quot;B&quot;) val list5 = mutableSetOf&lt;String&gt;(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;) 参数Kotlin的函数比Java函数强大的地方之一是入参可以有默认值，即默认参数； 在Kotlin调用函数时，可以指定入参的名称，即命名参数； 与Java不同，Koltin表示可变参数，不是参数后面加三个点，，而是在入参前加vararg关键词即可。Kotlin中存在一个展开运算符 – *（星号），它和可变参数搭配使用；作用是把一个数组展开成可变参数传入 详细说明，可看这篇文章Kotlin里的输入参数 顶层函数与属性 很多代码并不能归属到任何一个类中，有时一个操作对应两个不同的类的对象，而且重要性相差无几。 有时存在一个基本的对象，但不想通过实例函数来添加操作，让它的API继续膨胀。 在Java里，我们使用静态方法。Kotlin里没有static修饰词，它一种方式，使用顶层函数来实现相同的效果。 顶层函数实现一个功能，把集合中元素添加前缀，后缀，用分隔符间隔展示 在kt类里直接写 12345678910111213141516171819const val counter: Int = 0fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String ): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 顶层函数是包内成员，包内直接访问。若包外访问，需要import（IDEA等开发工具会为你自动import） 顶层函数是都是静态函数，默认函数所在的文件名加KT作为容器类，比如上述joinToString方法是在Example3_2文件名下的顶层函数，在Java里调用是时 Example3_2Kt.joinToString(collection, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;); 如果我想更改调用静态方法的容器类的类名为StringUtils，则需要在kotlin文件里添加 @file:JvmName(&quot;StringUtils&quot;) 这时候调用形式如下： StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 顶层属性counter就是顶层属性，等效于容器类的静态成员变量，即Java里如下写法 public static final int counter = 0; 拓展函数与属性拓展函数基本使用StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 每次调用上述实现的joinToString方法传入四个参数，有点多，我希望减少入参数量。StringUtils是工具类类名，工具类类名在整个调用过程中是不够高效的。达到优雅的途径之一就是做到高效而简洁。这个工具类具体是什么名字并不会影响这个函数的输入和输出，这个类名的意义是作为joinToString容器的标示，如果能把其中一个入参名作为类名，这个入参同时做两件事：传入自身到函数体里，作为调用的句柄名。 强大的Kotlin为我们实现了这样的能力：扩展函数。把上述方法生命为一个拓展函数，如下所示： 1234567891011fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;)&#123; val sb = StringBuilder() sb.append(prefix) for((index, element) in this.withIndex())&#123; if(index &gt; 0)&#123; sb.append(separator) &#125; sb.append(element.toString()) &#125; sb.append(postfix)&#125; 接收者类型：函数名前的类，上例Collection就是该扩展函数的接收者类型 接收者对象：接收者类的实例，上例this.withIndex方法的this指代的就是Collection对象，是该扩展函数接收者对象 这时候我们要使用joinToString方法，变成这样用了 val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.joinToString(&quot;_&quot;, &quot;[&quot;, &quot;]&quot;) 导入范围需要进行导入扩展函数才能生效，好在开发工具为我们自动导入了。如果定义的扩展函数所在的类和其接收者类型的类在一个包下，可以不需要显式导入。 有一种情况，如果你定义的扩展函数名和其他包里定义的函数名相同，你需要导入全类名以示区分。还有另一种方式，通过as在导入的地方重命名扩展函数名 import sugarya.chapter3.joinToString as jts 这时候，就可以调用jts就相当于调用joinToString方法 扩展函数的本质和特性其实，Kotlin把上述代码翻译到JVM上运行时。拓展函数的本质是：把接收者对象作为第一个入参的函数。通常我们在顶层位置定义扩展函数，这样扩展函数就能被其他包的文件调用。因此，扩展函数并没有改变接收者类里的代码，扩展函数并不是类的一部分，它是声明在类之外的，却能像成员变量那般使用。 像成员变量那般使用，扩展函数和成员变量不是一回事，它们之间是有区别的 扩展函数不能访问私有或者受保护的成员，因为接收者对象只是静态方法的一个入参，这个入参有大的访问能力，扩展函数就是多大访问能力。 扩展函数不能被接收者类的子类重写／继承。前面说了，扩展函数只是静态方法，并不是真实的接收者里的成员，自然也就无法重写了。 对于第2点的理解，我们举一个例子 12345678910111213class Person(name: String, var age: Int) : Animal(name)//拓展定义是写在Example2_4.Kt文件里fun Animal.move()&#123; println(&quot;animal move&quot;)&#125;fun Person.move()&#123; println(&quot;Person move&quot;)&#125;val animal: Animal = Person(&quot;Kotlin&quot;, 5)animal.move() 输出结果： animal move animal.move是拓展函数，转化为静态方法是Example2_4.move(animal),所以，move方法调用的就是Animal类下的move。 扩展属性扩展属性是对扩展函数能力的弱化／简化使用。相当于Java里第一个参数是接收者对象的静态getter方法和setter方法。扩展函数和扩展属性搭配使用，在扩展函数里访问扩展属性。举个例子 val Animal.length: Int get() = this.name.length * 10 fun Animal.move(){ println(&quot;animal move ${this.length}&quot;) } 扩展函数的应用看几个扩展函数的应用例子 分割字符串有一个字符串“ab.cd12.ef”，需要分割成三部分：ab, cd12, ef 使用Java，我们很容易写成这样 String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;.&quot;); java里split（）方法入参的字符串表示的正则表达式，在正则表达式里“.”表示任意字符，所以，如果照上面所写，返回为空，找不到字符。 使用Java正确实现是： String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;\\.&quot;); Kotlin在此基础上，通过扩展函数扩展字符串方法，通过默认参数实现重载效果。 123456789101112131415161718192021/** * Splits this char sequence to a list of strings around occurrences of the specified [delimiters]. * * @param delimiters One or more strings to be used as delimiters. * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`. * @param limit The maximum number of substrings to return. Zero by default means no limit is set. * * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from * the beginning to the end of this string, and matches at each position the first element in [delimiters] * that is equal to a delimiter in this instance at that position. */public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123; if (delimiters.size == 1) &#123; val delimiter = delimiters[0] if (!delimiter.isEmpty()) &#123; return split(delimiter, ignoreCase, limit) &#125; &#125; return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map &#123; substring(it) &#125;&#125; Kotlin实现 &quot;ab.cd12.ef&quot;split(&quot;.&quot;) Kotlin里用Regex类表示正则，使用正则实现如下 val regex = Regex(&quot;\\.&quot;) val result = &quot;ab.cd12.ef&quot;.split(regex.toPattern()) 解析字符串在Kotlin变得更容易了，除了split，Kotlin还提供了其他方法，再看一个例子 解析文件路径解析一个文件路径：“/Users/mine/Documents/MyDocument/Photoes／546294_308008399296566_779316797_n.jpg”,获取目录路径，文件名，文件拓展名 Kotlin代码实现 val msg = &quot;/Users/mine/Documents/MyDocument/Photoes/546294_308008399296566_779316797_n.jpg&quot; val dirPath = msg.substringBeforeLast(&quot;/&quot;) val filePath = msg.substringAfterLast(&quot;/&quot;) val fileName = filePath.substringBeforeLast(&quot;.&quot;) val extendName = filePath.substringAfterLast(&quot;.&quot;) println(&quot;directory path = $dirPath, fileName = $fileName, extendName = $extendName&quot;) 输出： directory path = /Users/mine/Documents/MyDocument/Photoes, fileName = 546294_308008399296566_779316797_n, extendName = jpg 局部属性在Java里，函数的最小的作用域是在一个类里（private修饰的方法），而Kotlin引入局部函数–允许在函数里定义一个函数，让函数（方法）的最小作用域降到一个函数体里。提供更小粒度的复用，这样有什么意义呢？ 这样是有意义的。 没有局部函数的特性的Java语言里，对方法最小作用域的组织方式是这样的：一个复杂的类里有很多方法，当方法A里的代码行数很多时，通常拆分出几个新的方法a1，a2，a3等等，这些新的方法之间如果存在整体的逻辑关系，就能组合成一个内部类，a1，a2，a3是该内部类的方法。直接在A里新建内部类并调用即可。外部类的其他方法比如方法B也能方便的调用。 Kotlin局部函数提供了比上述Java更细致的代码组织方式：如果我们只在一个方法A里多次用到，这时候在方法A里，定义a1，a2，a3，在方法A里多次使用方法a1，a2，a3。这种方式相较于上面的内部类组织方式，带来的益处是降低定义内部类带来的语法开销。 对于什么时候引入局部函数，我们有了下述认识：当需要在方法粒度上多次调用一段逻辑时。具体的场景有，登录验证，表单数据校验。 中缀调用 对只有一个参数的函数使用中缀调用 中缀调用的函数，需要对其使用inflix修饰符 中缀不仅适用于成员函数也适用于扩展函数 举个中缀的例子 val pair: Pair&lt;String, String&gt; = &quot;a&quot; to2 &quot;A&quot; 上面的中缀调用是怎么定义呢？ infix fun &lt;T, V&gt; T.to2(v: V): Pair&lt;T, V&gt; = Pair(this, v) 三重引号的字符串三重引号字符串不仅在于避免转义符，而且可以包含任何字符，包括换行符。 看一个佛祖镇楼的例子 1234567891011121314151617181920212223 val bless = &quot;&quot;&quot; _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG &quot;&quot;&quot; println(bless) 这样控制台按原样格式输出佛祖图 小结这是Kotlin实战第三章涉及的所有知识点，结合自己的理解整理归纳成本篇文章。]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第二讲-初出茅庐]]></title>
    <url>%2F2018%2F04%2F05%2FKotlin%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90%2F</url>
    <content type="text"><![CDATA[年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？ 年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？val = 加了final的变量 val message = &quot;Kotlin&quot; // final String message = &quot;Kotlin&quot;; var count = 0 val msg: String = &quot;Kotlin&quot; //value var count2: Int = 0 // variant val p = Person(&quot;Kotlin&quot;) p.name /* Q1 var与val什么区别？ val = 加了final变量 */ val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;) languageList.add(&quot;Go&quot;) 字符串模板类比Java Web JSP里的EL表达式 println(&quot;message = &quot; + message) println(&quot;message = $message&quot;) println(&quot;count = ${count}&quot;) println(&quot;language list size = ${languageList.size}&quot;) println(&quot;\$: ${count2}&quot;) 函数fun max(a: Int, b: Int): Int { if (a &gt; b) { return a } return b } fun max2(a: Int, b: Int) = if (a &gt; b) a else b 问题：表达式和语句有什么区别？ 表达式有返回值，语句没有。表达式可以包含在语句或表达式里。语句与语句之间是并列的 Kotlin常见的表达式有：if，when，try{}catch 关于Whenfun filter(a: Int) { when (a) { 0 -&gt; println(&quot;0&quot;) 1 -&gt; println(&quot;1&quot;) in 2..10 -&gt; println(&quot;in 2..10&quot;) !in 11..20 -&gt; println(&quot;! in 11..20&quot;) Integer.parseInt(&quot;21&quot;) -&gt; println(&quot;21&quot;) 22, 23 -&gt; println(&quot;22 , 23&quot;) else -&gt; println(&quot;else&quot;) } } fun filter2(x: Any) { when (x) { is Int -&gt; println(&quot;Int&quot;) is String -&gt; println(&quot;String&quot;) is Person -&gt; print(&quot;JavaPerson&quot;) } } fun filter3(x: Any) = when (x) { is Int -&gt; { val a = 3 &quot;Int&quot; } is String -&gt; { val b = &quot;&quot; &quot;String&quot; } else -&gt; { &quot;else&quot; } } fun filter4(x: Any) = when { x is Int -&gt; &quot;Int&quot; x is String -&gt; &quot;String&quot; else -&gt; &quot;else&quot; } } 关于Kotlin里的循环和迭代for (i in 0..5) { println(&quot;i : $i&quot;) } for(j in 0 until 5){ println(&quot;j : $j&quot;) } for(k in 5 downTo 0){ println(&quot;k : $k&quot;) } val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;, &quot;Go&quot;) for((index, value) in languageList.withIndex()){ println(&quot;index = $index, value = $value&quot;) } val languageMap = hashMapOf&lt;String, String&gt;(&quot;j&quot; to &quot;Java&quot;, &quot;k&quot; to &quot;Kotlin&quot;, &quot;g&quot; to &quot;Go&quot;) for((key, v) in languageMap){ println(&quot;$key : map value = $v&quot;) } 异常处理背景知识： Java异常继承自Throwable，分为两种 运行时异常RuntimeException，也叫非受检异常 受检异常 CheckedException Java处理异常有两种方式： try catch 捕获异常 throws抛出异常 先看下Java的例子 //非受检异常 private static void testRuntimeException() { int i = Integer.parseInt(&quot;!&quot;); } //受检异常 private void testCheckedException() { try { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } catch (FileNotFoundException e) { e.printStackTrace(); } } private void testCheckedException2() throws FileNotFoundException { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } 从上面程序可知：Java强制要求开发人员处理受检异常. 常见的受检异常： Exception, FileNotFoundException, IOException, SQLException 常见的未检查异常： NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException 上述Kotlin下的代码如下： fun testRuntimeException(){ val i = Integer.parseInt(&quot;!&quot;) } fun testCheckedException(){ val fis = FileInputStream(&quot;/temp&quot;) throw IllegalArgumentException(&quot;&quot;) } 可知：与Java不同，对受检异常，Kotlin不强制开发人员处理。 小结对于异常，Kotlin与Java的不同之处如下： Kotlin不区分受检异常和非受检异常, 都不强制处理异常 Kotlin不存在throws，不允许抛出异常 当try{}catch{}作为表达式的使用时fun readNumber(){ val a = try { val c = &quot;&quot; Integer.parseInt(&quot;!&quot;) }catch (e: Exception){ e.printStackTrace() 0 } println(&quot;a = $a&quot;) } 关于枚举1234567891011121314enum class Season&#123; SPRING, SUMMER, AUTUMN, WINTER&#125;enum class Color(val r: Int, val g: Int, val b: Int)&#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0,0,255); fun rgb() = r * 255 * 255 + g * 255 + b&#125; 关于类和属性我们看下Java的 123456789101112131415161718192021222324252627public class Rectangle &#123; private final int width; private final int height; private final boolean isSquare; public Rectangle(int width, int height, boolean isSquare) &#123; this.width = width; this.height = height; this.isSquare = isSquare; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public boolean isSquare() &#123; return isSquare; &#125;&#125;``` 等效Kotlin实现 class Rectangle(val width: Int, val height: Int){ val isSquare get() = width == height}` Java中，成员变量就是一个字段，访问成员变量通过setter或者getter方法，相当于变量的访问器。Kotlin把这个概念作为语言层面的支持了。kotlin中每个属性，如果是val变量就自带访问器get(),如果是var属性则自带get()和set() 因此Kotlin中，一个属性 = 字段 + 访问器；这是Kotlin对Java语言的进化。 小结该文是对Kotlin实战一书第二章知识点代码的梳理和总结，完整代码，已上传到GitHub上，KotlinInActionExample 传送门]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第一讲-输入参数]]></title>
    <url>%2F2018%2F03%2F22%2F%20Kotlin%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下：本专栏的第一篇，分享下Kotlin里输入参数的特性 命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下： 1234567891011121314151617181920212223242526272829public class SeparatorUtils &#123; /** * * @param collections 集合 * @param prefix 前缀 * @param separator 分隔符 * @param postfix 后缀 * @param &lt;T&gt; 集合泛型 * @return 分隔后的结果 */ public static &lt;T&gt; String separator(Collection&lt;T&gt; collections, String prefix, String separator, String postfix) &#123; Objects.requireNonNull(collections); StringBuilder sb = new StringBuilder(); sb.append(prefix); int size = collections.size(); int index = 0; for (T t : collections) &#123; sb.append(t.toString()); if(index &lt; size - 1)&#123; sb.append(separator); &#125; index ++; &#125; sb.append(postfix); return sb.toString(); &#125;&#125; private static void testSeparator(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Java&quot;); list.add(&quot;Kotlin&quot;); list.add(&quot;Python&quot;); list.add(&quot;JavaScript&quot;); list.add(&quot;Ruby&quot;); list.add(&quot;Go&quot;); String separator = SeparatorUtils.separator(list, &quot;(&quot;, &quot;,&quot;, &quot;)&quot;); System.out.println(&quot;separator result = &quot; + separator); } 输出结果： separator result = (Java,Kotlin,Python,JavaScript,Ruby,Go) 这是一个完整的编码过程，来了一个需求，通过新增类和方法，在需要的地方，调用实现。需求被解决了，代码默默地在角落发挥着作用。 转眼三个月过去，团队里来了新人，他阅读到testSeparator方法；当读到SeparatorUtils.separator（）方法，对于传的四个参数代表什么含义，乍看之下他并不清楚，需要点进去读实现代码或者看注释说明才确切明白。那么还有没有更易于阅读的方式呢？Kotlin的命名参数能做到。 SeparatorUtils.separator方法用Kotlin重写如下： 123456789101112131415161718fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 调用joinToString方法可以这样 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val s = joinToString(list, postfix = &quot;)&quot;, separator = &quot;,&quot;, prefix = &quot;(&quot;) println(&quot;s = $s&quot;) 上述即是命名参数，在调用处使用，形式为：参数名=参数值；这样的入参带来了两个便利： 便于阅读，按顺序阅读代码就能知晓方法参数的含义 调用时入参的位置可以任意（调用的入参顺序和定义的入参的顺序允许不一致） 这样看起来真不错的 默认参数定义函数时，给入参提供默认值，在调用处，如果不传入实参，则该参数使用默认值，可用于方法重载。例如对上述Kotlin代码的joinToString方法改变入参 12345678910111213141516171819@JvmOverloadsfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 在Kotlin调用joinToString（）支持如下，最后一个我们同时使用了Kotlin的命名参数和默认参数的特性。 val list = arrayListOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;Ruby&quot;, &quot;Go&quot;) val s = joinToString(list) val s2 = joinToString(list,&quot;,&quot;) val s3 = joinToString(list,&quot;,&quot;,&quot;[&quot;) val s4 = joinToString(list,&quot;,&quot;,&quot;[&quot;,&quot;]&quot;) val s5 = joinToString(list, prefix = &quot;[&quot;, postfix = &quot;]&quot;) 上述调用体现了方法重载，默认参数可提供方法重载的效果 上面出现的@JvmOverloads注解是用来做什么的呢？ 默认参数特性，使用是有前提的：用Kotlin定义函数，并在Kotlin代码里调用该函数。因此，如果在Java文件里调用Kotlin定义的joinToString方法，默认不支持默认参数特性的，也即方法重载失效。 @JvmOverloads提供了让默认参数特性在Java环境也得到支持。原理是：kotlin代码编译成java代码时，会增加增加下面的方法，这些正是Java方法重载。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class StringUtils &#123; public static final int count = 11; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix, @NotNull String postfix) &#123; Intrinsics.checkParameterIsNotNull(collection, &quot;collection&quot;); Intrinsics.checkParameterIsNotNull(separator, &quot;separator&quot;); Intrinsics.checkParameterIsNotNull(prefix, &quot;prefix&quot;); Intrinsics.checkParameterIsNotNull(postfix, &quot;postfix&quot;); StringBuffer sb = new StringBuffer(prefix); Object element; for(Iterator var6 = CollectionsKt.withIndex((Iterable)collection).iterator(); var6.hasNext(); sb.append(element)) &#123; IndexedValue var5 = (IndexedValue)var6.next(); int index = var5.component1(); element = var5.component2(); if (index &gt; 0) &#123; sb.append(separator); &#125; &#125; sb.append(postfix); String var10000 = sb.toString(); Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;sb.toString()&quot;); return var10000; &#125; // $FF: synthetic method // $FF: bridge method @JvmOverloads @NotNull public static String joinToString$default(Collection var0, String var1, String var2, String var3, int var4, Object var5) &#123; if ((var4 &amp; 2) != 0) &#123; var1 = &quot;,&quot;; &#125; if ((var4 &amp; 4) != 0) &#123; var2 = &quot;(&quot;; &#125; if ((var4 &amp; 8) != 0) &#123; var3 = &quot;)&quot;; &#125; return joinToString(var0, var1, var2, var3); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix) &#123; return joinToString$default(collection, separator, prefix, (String)null, 8, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator) &#123; return joinToString$default(collection, separator, (String)null, (String)null, 12, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection) &#123; return joinToString$default(collection, (String)null, (String)null, (String)null, 14, (Object)null); &#125; public static final void testExtend(@NotNull Container $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, &quot;$receiver&quot;); String var1 = &quot;call the container testExtend method&quot;; System.out.println(var1); &#125;&#125; 可变参数可变参数关键词：vararg(分别取variate和arguments前三个字母) 来看一个Kotlin的Collections类里的一个方法 123456/** * Returns a new [ArrayList] with the given elements. * @sample samples.collections.Collections.Lists.arrayList */public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt; = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true)) 调用 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) arrayListOf入参数量可以任意多个 Java实现可变参数，在数据类型后面加三个点：… ，看下Java里的Arrays里的一个方法 12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 展开运算符 *把数组展开成一个一个元素。展开运算符常与可变运算符联合使用。比如这样： 12val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)val list = arrayListOf(*array) 我得到了一个ArrayList集合，集合里的元素是”a”, “b”, “c”]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
