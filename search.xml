<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android原生项目集成ReactNative混合开发]]></title>
    <url>%2F2018%2F08%2F03%2F2018%2F2018-08-03%2F</url>
    <content type="text"><![CDATA[假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 12345678910npm init&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;&#125;npm install --save react react-native@版本号curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 配置原生安卓项目的Gradle12345678910111213141516171819202122232425allprojects &#123; repositories &#123; maven &#123; url &quot;$rootDir/node_modules/react-native/android&quot; &#125; jcenter() &#125;&#125;dependencies &#123; implementation &apos;com.facebook.react:react-native:版本号&apos;&#125;android &#123; defaultConfig &#123; ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &quot;armeabi-v7a&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; &#125; configurations.all &#123; resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos; &#125;&#125; 添加权限12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;/&gt;&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt; 添加React native入口在项目根目录下，新建index.js文件作为React Native控件配置页 Hello World示例 12345678910111213141516171819202122232425import React from &apos;react&apos;;import &#123;AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, &#125;, hello: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;,&#125;);AppRegistry.registerComponent(&apos;AndroidRnDemoApp&apos;, () =&gt; HelloWorld); 编译运行到安卓真机12adb reverse tcp:8081 tcp:8081npm start 打包新建assert资产文件 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/ 小结 本次Android集成了React Native0.51.0版本的环境（最新为0.56.0），采取了原生项目为主，编译和打包仍走安卓项目的Gradle流程 React Native集成过程中，由于Kotlin改写了模块iml文件里的某处标签信息，使得项目无法正常编译，往文件里手动添加如下标签得以修复： 1&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;]]></content>
      <categories>
        <category>ReactNative游历</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb连接不上 e00002be问题踩坑]]></title>
    <url>%2F2018%2F07%2F25%2F2018%2F2018-07-25%2F</url>
    <content type="text"><![CDATA[上周升级了Mac OS到10.13.6，前天使用Android Studio带的手机模拟器运行App，第二天真机连接笔记本无法识别，adb一直处在初始化状态。 错误信息如下： daemo not running, starting no at tcpTerminated: 15 Unable to create an interface plug-in(e00002be)adb_auth_init….Terminated: 15 经过两个多小时的搜索和排查，参考了如下文章： Mac users are unable to access the tablet via fastboot macbook adb cannot open interface 问题出在最新版的Mac OS和 Android studio的platform-tool 28版本里的下的fastboot文件不兼容。 5037是adb服务默认端口。在这个过程中使用到了adb命令如下： 查看当前连接的所有设备 adb devices 开启adb服务 adb start-server 关闭服务 adb kill-server adb守护线程未启动，无法连接adb时，查看原因 adb nodeamon server 查看80端口被那些程序占用，终端输入 1lsof -i:80 或者 1lsof -i tcp:80]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Exception</tag>
        <tag>MacOS</tag>
        <tag>Adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第七讲-泛型在Java和Kotlin上的横向比较]]></title>
    <url>%2F2018%2F07%2F16%2F2018%2F2018-07-16%2F</url>
    <content type="text"><![CDATA[阅读本文前，如果对Java泛型不够了解，不妨先阅读我之前写的两篇说Java泛型的文章 重拾Java泛型 上篇 重拾Java泛型 下篇 语法比较泛型方法Java 1234567891011public static&lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)&#123; Iterator&lt;? extends T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext())&#123; T t = iterator.next(); if(t.compareTo(result) &gt; 0)&#123; result = t; &#125; &#125; return result; &#125; Kotlin1234567891011fun &lt;T : Comparable&lt;in T&gt;&gt; max(list: List&lt;out T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 查看Kotlin里的Comparable类和List类源码，Comparable类定义，List类定义，所以可以不必重复表明Comparable的逆变能力和List的协变能力。 1234567891011fun &lt;T : Comparable&lt;T&gt;&gt; max(list: List&lt;T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 不管是泛型类还是泛型方法，泛型的使用分为两个步骤 第一步，声明泛型参数 第二步，才是使用泛型参数 上面的泛型方法，以Java泛型方法为例，泛型声明部分是： 1&lt;T extends Comparable&lt;? super T&gt;&gt; 引入泛型类型名称为T，这个数据类型的关系是实现Comparable的类。 使用泛型的部分如下： 1List&lt;? extends T&gt; 入参的集合具有对类型T的协变能力。 所以，有些书或者网上资料，会出现两个概念：声明点变型，使用点变型。这个概念说的就是这件事 再来看下in位置，和out位置的概念 所以，类型参数T上的关键字out有两方面含义： 具有协变的能力 T只能用在out位置 我们再看一个有趣的例子 我有一个方法，入参的一个集合，我希望入参集合元素是EditText的子类的集合，如何构建满足这个关系的方法呢？至少有下面的两种方式： 1234567fun test2(list: MutableList&lt;out EditText&gt;)&#123;&#125;fun &lt;T: EditText&gt;test3(list: MutableList&lt;T&gt;)&#123;&#125; 上面test2， test3方法都能实现预期的效果。不同的是，test2使用协变来实现，也意味着只能读不能写操作，test2不是泛型方法。test3方法通过在声明表明泛型参数的类型关系来实现，可读可写，它是泛型方法。 对应的Java代码如下 private void test2(List&lt;? extends EditText&gt; list){ } private &lt;T extends EditText&gt; void test3(List&lt;T&gt; list){ } 实现泛型参数多约束Java 123private &lt;T extends Serializable &amp; CharSequence&gt; void ensureTrailingPeriod(T seq)&#123; &#125; kotlin 123fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T: Serializable, T: CharSequence&#123; &#125; 这是Java语法上很大的不同，Kotlin要实现多约束，使用到where关键词，这是全新的表示法。 实化类型参数来看一段Java代码： private &lt;T&gt; void test(T t){ if(t instanceof String){ String s = (String)t; }else if(t instanceof Integer){ Integer i = (Integer)t; } } 入参是泛型的，通过instanceof来判断泛型具体是哪个类型。再看一段代码 private &lt;T&gt; void test2(Object o){ //编译不通过 if(o instanceof T){ } } 泛型作为参数类型时，编译不通过。如果要完成上述的逻辑，要怎么实现？可以通过class近似等效实现 class ClassJudge&lt;T&gt;{ Class&lt;T&gt; kind; public ClassJudge(Class&lt;T&gt; kind) { this.kind = kind; } public boolean isInstance(Object o){ return kind.isInstance(o); } } 调用 Integer a = 12; boolean instance = new ClassJudge&lt;String&gt;(String.class).isInstance(a); System.out.println(&quot;instance = &quot; + instance); Kotlin在语言层面作出了支持，对上述Java代码test2方法，kotlin代码如下： 12345inline fun&lt;reified T&gt; test2(any: Any)&#123; if(any is T)&#123; &#125;&#125; 因此需要具备两个条件： 是内联函数 inline 关键词 reified 集合协变在Kotlin里，非空类型是可空类型的子类型。 Java实现的协变 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); Kotlin实现的协变 1val list: MutableList&lt;out Number&gt; = arrayListOf&lt;Int&gt;() 集合逆变Java实现的逆变 1List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;(); 对应的Kotlin逆变的实现： 1val list: MutableList&lt;in Int&gt; = arrayListOf&lt;Number&gt;() 变型（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。 由此可见，在泛型里，extends 不全等于 ：。extends代表子类型关系和协变，而Kotlin的 ：只代表子类型关系。 12&lt;out T&gt; = &lt;? extends T&gt;&lt;in T&gt; = &lt;? super T&gt; 星投影和Java无限制通配符？差异星投影如何使用 12&lt;*&gt; = &lt;out Any?&gt;&lt;*&gt; = &lt;in nothing&gt; 投影一词，顾名思义，是对Any？的投影，获得了Any？部分的能力—Any？协变的能力，即失去写操作，只能读操作。 12345fun printFirst(list: List&lt;*&gt;)&#123; if(list.isNotEmpty())&#123; println(list.first()) &#125;&#125; 场景二：泛型类存储所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化到一个分开的位置，预防了误用，保证了它不会被错误地使用。 其他非空性与泛型Java和Kotlin默认，泛型参数都是可空的，以Kotlin为例 12345class Processor&lt;T&gt; &#123; fun process(value: T)&#123; value?.hashCode() &#125;&#125; 泛型参数是可空类型，可以理解为默认实现&lt;T: Any?&gt;，因此要实现非空类型，只需&lt;T: Any&gt;，如下 12345class Processor2&lt;T: Any&gt; &#123; fun process(value: T)&#123; value.hashCode() &#125;&#125; 所以，泛型 和&lt;T: Any&gt;是有区别的，前者是可空类型，后者是非空类型，确切说，和&lt;T:Any?&gt;等效 小结Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 参考资料 仔细说说Java中的泛型 Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ Java 泛型进阶 Java为什么要添加运行时获取泛型的方法 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin项目上传jcenter躺坑记]]></title>
    <url>%2F2018%2F07%2F06%2F2018%2F2018-07-06%2F</url>
    <content type="text"><![CDATA[前段时间写了一个下拉列表的自定义控件，造了轮子就想对外分享。如何上传代码到Maven仓库（Jcenter）呢？刷了文章，查阅了几处文档。 多个语言项目发布JCenter仓库的小结 Gradle版本和gradle 插件版本对照关系 Github:novoda/bintray-release 我采用了“多个语言项目发布JCenter仓库的小结”一文使用的方案，这个过程我遇到了两个坑，记录如下： com.novoda.bintray插件和Gradle版本需匹配这里匹配包含两个方面 匹配一：插件和Gradle语言版本匹配我选用的方案是使用novoda.bintray插件。com.novoda.bintray-release 插件内部把上传代码到bintray.com网站（Maven仓库管理商）的逻辑封装好了，比起早期2016年的时候，需要开发者写大量Gradle配置的任务代码相比快速方便多了。 查看该插件的github页面，可知这个插件最新版本是0.8，是基于Gradle4.3的；因此使用0.8版本，gradle版本最好选用4.3版本（目前gradle最新版本是4.4） 匹配二：Gradle语言和Gradle插件版本匹配我们知道，android studio开发是需要引入gradle插件的，它和gradle语言版本的匹配关系，可以查阅安卓官网获知传送门)。 novoda.bintray插件选用了0.8最新版本，它需要的Gradle语言版本是4.3，而Gradle语言版本4.3要求的Gralde插件版本为3.0.x。 releaseAndroidJavadocs任务执行失败问题执行命令上传，遇到 Execution failed for task ‘:spinnerlibrary:releaseAndroidJavadocs’. 找了文章，处理方式都是不执行这个任务，也是可以接受的，毕竟不生成javadocs不影响代码上传到jcenter。 命令行 后面 跟 -x releaseAndroidJavadocs便能不执行此任务 mac下的命令行 1./gradlew clean build bintrayUpload -PbintrayUser=bintray网站上的姓名 -PbintrayKey=bintray网站的apiKey -PdryRun=false -x releaseAndroidJavadocs 最后附上的gradle配置信息 工程根gradle配置： 12345678910111213141516171819202122232425262728293031buildscript &#123; ext.kotlin_version = &apos;1.2.50&apos; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.1&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files classpath &apos;com.novoda:bintray-release:0.8.0&apos; &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125; tasks.withType(Javadoc) &#123; options&#123; encoding &quot;UTF-8&quot; charSet &apos;UTF-8&apos; links &quot;http://docs.oracle.com/javase/7/docs/api&quot; &#125; &#125;&#125; 模块gradle配置信息： 123456789101112131415161718192021222324252627282930313233343536373839404142apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.novoda.bintray-release&apos;apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos;android &#123; compileSdkVersion 27 defaultConfig &#123; minSdkVersion 16 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot; implementation &apos;com.android.support:design:27.1.1&apos; implementation &apos;com.contrarywind:Android-PickerView:4.1.4&apos;&#125;publish &#123; userOrg = &apos;sugarya&apos; groupId = &apos;com.sugarya&apos; artifactId = &apos;spinnerlayout&apos; publishVersion = &apos;0.1.1&apos; desc = &apos;This is a nice custom library about spinner layout for android&apos; website = &apos;https://github.com/Sugarya/SpinnerLayout&apos;&#125; 小结折腾了两天，总算大功告成。 下拉列表自定义控件SpinnerLayout(https://github.com/Sugarya/SpinnerLayout)，目前是开发版本，欢迎关注。 参考资料 多个语言项目发布JCenter仓库的小结 Gradle版本和gradle 插件版本对照关系 Github:novoda/bintray-release 放弃JitPack，发布Android Library到Bintray、JCenter]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android Widget</tag>
        <tag>Kotlin</tag>
        <tag>Bintray</tag>
        <tag>Jcenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么Flutter放弃xml而使用代码写布局]]></title>
    <url>%2F2018%2F06%2F30%2F2018%2F2018-06-30%2F</url>
    <content type="text"><![CDATA[在Flutter的Github的Issue上有人提出了一个问题：Consider JSX-like syntax inside dart code。问题传送门 这让我想起之前曾经有人问 为什么Flutter放弃xml而使用代码写布局？ 对于这个问题，我正好有一些思考，借助这篇文章说说我的看法。 我认为Flutter有必要舍弃xml，使用代码写布局。因为使用代码来组织布局，会是未来的新趋势，至少是一个方向。 已有语言尝试代码组织布局用相对现代化的语言Kotlin写Android App时，我发现JetBrains搞了一个gradle插件用来支持在代码里写布局。可见Kotlin是支持和提倡用DSL代码来写布局的。 链接里的issue讨论中提到JSX，JSX的理念我赞同（刚刷了一篇文章，文中提到，组件模板和组件逻辑分离让问题复杂化了，应该让模板和组件关联），flutter现在也是朝这个方向来的。 和Hot Reload特性搭配Flutter舍弃xml使用代码描述布局，能更方便的和Dart的hot reload特性配合使用，代码改动能立刻反映布局变化。 后续更有力的资源支持之前参加flutter技术分享，我问过这个问题，谷歌工程师给的答复是，后续会进一步增强Dart的语言特性，让代码组织widget tree起来更易读更简洁。比如Dart2比Dart1多了一个特性：可以省略new关键词。 说个题外话，他们还透露了目前他们花了大量精力在减少开发Flutter依赖包的大小，目标是把在安卓的包从8M减到5M, iOS的从16M减到9M左右。 未来肯定会出现对布局和语法高亮的Dart插件，让开发人员阅读布局代码更舒适。 查阅的资料 为什么要引入 JSX 这种语法(https://hulufei.gitbooks.io/react-tutorial/content/jsx.html Flutter中文社区(https://flutter-io.cn/)]]></content>
      <categories>
        <category>Flutter征程</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半月小结]]></title>
    <url>%2F2018%2F06%2F28%2F2018%2F2018-06-28%2F</url>
    <content type="text"><![CDATA[这半个月的经历比较杂，捡几个事件，做简单的记录和思考。 Flutter技术分享上周参加了Flutter技术分享，在北京谷歌办公室。办公室位于中关村，一贯的谷歌范。一位高级工程师给40多位参加分享的同学说了Flutter在移动端的情况，之后Flutter的产品经理为我们答疑。半天的活动，感受最深的有以下几点： 阿里闲鱼团队在Flutter领域走在了国内公司的前头，他们已经作出了成熟的基于Flutter开发的App，用户数达到几百万。 Flutter是第三代跨平台移动开发的解决方案，相对与React Native，性能更高，几乎和原生开发比肩。 Flutter是继Kotlin之后，对Android开发人员的又一大福利。在早期使用Flutter平台开发App期间能和Flutter社区共同成长，甚至有机会影响Flutter的发展进程。这是非常好的契机让我们重新接触操作系统基础的知识，并在与安卓系统的比较中深化理解。 使用Flutter开发App需要使用Dart语言；Java到Kotlin，再到Dart。语言特性是不变的关注点。 会上我提了一个问题：在Flutter开发里使用Dart代码写布局，而不像安卓使用XML文件，这会不会降代码可读性，页面布局起来不够友好？ 谷歌工程师的回答是：Dart2新增的一些特性提高了代码的可读性，通过规范化书写，Hot reload辅助你写出你想要的布局。 未来也许会多一个软件岗位：Flutter开发工程师，拭目以待。 Kotlin技术分享难以为继之前在部门组织发起了Kotlin学习小组，每周或半个月一次分享。持续了两个多月，这周大家忙碌以及某些不知情的原因，本周的Kotlin技术分享没有办成。 非常遗憾，大家学习Kotlin的热情并不是很高涨，并没有感受到Kotlin对Java程序员与众不同的意义—编程思维的进化，跟进现代化编程语言的潮流。这样的跟进能为后续新编程语言学习平稳过渡和打下良好的基础。 下一步考虑打算扩大范围，如果时间允许通过视频的方式在网上传播和分享来获取反馈，让Kotlin技术分享继续往前。 安卓项目交接和饭局同组的安卓同事本周离职，项目交接中。我和他一同参加了Kotlin分享活动，在共同开发安卓App期间，合作顺利。尽管他对App项目方案选型和处理上不够好，项目架子用起来不够畅快。但是相处近两年，坦诚而善辩，有雅号杠王，留下的传说将从离别的饭局开始。 时间来到了2018年6月底，也意味着2018年已经过去了一半，下半年旅途即将开启。]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次述职演讲]]></title>
    <url>%2F2018%2F06%2F20%2F2018%2F2018-06-20%2F</url>
    <content type="text"><![CDATA[各位评委，技术大神，你们好。接下来我将用大约12分钟的时间，讲述过去一年里我在安卓客户端上的工作情况。 工作业绩和成果首先说说我的工作业绩和成果，分为两个部分： 京旺安卓客户端开发 第一部分，京旺安卓客户端迭代开发 该App是面向京东家电专卖店店主使用。作为主程，独立完成了从1.8版本到2.0，2.1大版本的改造。在京旺App里我引入了Material Design材质设计的交互，实现了材质设计的部分动画效果。 举两个我在京旺App里实现的例子： 左图，是京旺App主页，当手指向上滑动时，轮播图的阴影和背景色从深到浅形成渐变，100%的实现了设计师的设计意图和理念，让App变得灵动。 在材质设计的世界里，水波纹是典型的交互方式，我把这一方式应用到了搜索栏上，如右图所示：用户点击搜索图标，搜索栏水波纹展开。 京商慧安卓客户端开发第二部分，京商慧安卓客户端迭代开发 该App是VC系统的移动端，我参与了从1.5版本到2.3.2版本的迭代开发，完成了厂直管理模块，定额返利与返利协议模块，部分售后管理模块，意见反馈和回复相关页，分类，待办页和我的页面 技术成长与积累接下来，是我的技术成长与积累 我将从四个部分进行陈述，分别是第一安卓自定义控件，第二UI适配，第三面向对象的设计能力，第四App性能 安卓自定义控件我的技术成长第一部分是实现了可复用的安卓自定义控件 有下拉列表控件，该控件实现的功能是：如图，点击服务单详情展开一个下拉列表。 第二个自定义控件是图片选择器，该控件实现的功能是：提供用户从手机相册里选取至多5张图片进行上传。 第三个自定义控件是下拉刷新控件，该控件实现的功能是：用户下拉页面刷新时，展示铜钱和金元宝滚动的动画，直至刷新结束，传递京旺App能带给家电专卖店主金钱收益。在安卓开源世界里，下拉刷新控件已经有很好的轮子了。我实现的这个控件多少有重复造轮子的嫌疑。 所以，我重点说下第一个控件，下拉列表。 先说说当前行业里下拉列表的情况 如左图，是美团App的外卖主页，可以看到点击筛选，展开下拉列表之前有短暂的停顿，同时下拉列表的展开也缺乏动画过渡。 右图是我实现的下拉列表控件的效果。消除了下拉时不自然的停顿，增加了下拉展开的动画效果。 接下来，我简单地说下，我做的下拉列表的实现思路：我把下拉列表拆分成两个部分：父控件FilterLayout和子控件FilterFooter。父控件负责核心的交互逻辑，如下拉列表的展开和收缩。子控件实现下拉列表的内容，不同的下拉内容用不同的子控件实现。通过这样组合的方式，保证逻辑耦合处在一个合适的程度。 现阶段下拉列表主要支持的特性有：支持代码和布局混合控制，支持两种动画下拉，支持父控件和子控件协同控制下拉动画的方式 UI适配我的技术成长第二部分是UI适配 现在市面上各主流App，都实现了沉浸式的标题栏–即把顶部状态栏和页面内容融合在一起，如左图所示。对于安卓4.4及以下的系统，如右图所示。统一了不同安卓系统版本下的UI展示。 面向对象的设计能力我的技术成长第三部分是提高了面向对象的设计能力 App项目中，对话框使用频率很高，不同的页面的对话框要求展示不同的内容。如何更好的维护和管理项目里的对话框呢？为此我建立了一套对话框管理体系。根据谷歌官方的文档，对话框最佳实践是：页面Activity里的FragmentManager管理DialogFragment，DialogFragment管理AlertDialog。基于这样的认识我去考虑逻辑和组织类。如下图所示，蓝色的FragmentManager在Activity里，黄色的DialogFragment部分通过继承体现，绿色的AlertDialog在DialogFragment里通过工具类生成。 传统的安卓App页面使用的是重量级的Activity，带来的问题是：安卓App页面跳转不如苹果App那般畅快？为了解决这个问题，在京旺App里我使用了更轻量的Fragment建立起单Activity多Fragment的页面组织体系。有效提高了App页面切换响应的速度，这样做的代价是增加了我对页面状态的维护难度，增加了代码量。如下图，我建立起了四级Fragment继承体系和三级Activity继承体系，为了防止基类的脆弱性问题，我对每个类和方法写了详细的说明和注释。 App性能我的技术成长第四个部分是优化App性能 我尝试并实践了从这三个方面来优化App性能：分别是避免内存泄漏，优化布局以及优化App响应。 典型事件分析说完了技术成长与积累，接下来我说说典型事件介绍。 前几周，新上线的厂直管理待出库列表页，当列表只剩下一条记录时，点击出库按钮，App崩溃。我在测试环境里复现了该问题，该问题使用了第三方开源框架，通过阅读相关类的源码推测得出：我调用的方法在这个场景下存在问题。于是尝试了调用新的方法，问题得到了解决。 其他能力展示接下来，我说说自己在其他方面的能力，分为两个部分。 技术博客第一部分对外技术输出在京旺App上实践了单Activity多Fragment的页面组织方式，提高了页面跳转的响应速度，我把对这块内容的思考写成了技术博客，发布到简书后，有4千多的阅读量，获得15次评论和2次赞赏。发布到掘金后，获得了255个点赞，并成为当天的热门文章。 第二部分是，对内Kotlin知识分享。今年年初我在部门做了主题为：开启Kotlin编程之旅的技术分享。之后我和同样对Kotlin感兴趣的小伙伴组成了Kotlin学习小组。分享频率是：1到2周，分享一次。右图是我们Kotlin知识分享的海报（在这里顺带感谢下靖莹设计师的友情支持），目前小组内我进行了5次Kotlin分享。我把分享的知识点整理成文章放到了知乎专栏上，分享产生的代码上传到了Github上。 之所以投入如此多的精力在Kotlin上，是因为我看好Kotlin的发展，因为作为一门新语言，繁荣所满足的几个条件，Kotlin现在都具备了。 第一，有程序界里的大神背书（前段时间Think In Java的作者Bruce在京东的演讲就在推广Kotlin）； 第二，新的编程语言是否有杀手级的应用场景？有的，Kotlin目前杀手级应用是在安卓上，它得到了谷歌官方的支持； 第三，新的语言学习和迁移的成本是否足够低？是的，够低。Kotlin支持和Java100%的兼容和相互调用； 第四，新的语言是否足够先进，以提高代码生产力？—Kotlin够先进。Kotlin是2016年发布1.0正式版本的现代化的简洁语言，有着动态语言的语法以及高程度的函数式编程支持。 所以我非常看好Kotlin，Kotlin里这些新的更现代化的语言特性，是我喜欢Kotlin的原因。 不足和改进计划最后，说说我的不足和改进计划 在过去一年工作中，我感受到自己编程基础知识的薄弱，安卓系统Fragmentwork层工作机制不够熟悉，项目架构能力不够，对此，我打算通过阅读技术书籍：比如算法，Effective Java和Java函数式编程以及通过坚持写博客和技术分享来提高项目架构能力和编程基础知识。 小结以上是我述职的所有内容，谢谢大家]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第六讲-委托类和属性]]></title>
    <url>%2F2018%2F06%2F12%2F2018%2F2018-06-12%2F</url>
    <content type="text"><![CDATA[委托类实现一个接口，可以使用by关键字将接口实现委托给另一个对象。 1234567891011121314151617181920212223interface OnClickListener&#123; fun onClick() fun onLongClick()&#125;class ViewClickDelegate : OnClickListener&#123; override fun onClick()&#123; println(&quot;ViewClickDelegate onClick&quot;) &#125; override fun onLongClick() &#123; println(&quot;ViewClickDelegate onLongClick&quot;) &#125;&#125;class View(val name: String, onClickListener: OnClickListener) : OnClickListener by onClickListener&#123; override fun onLongClick() &#123; println(&quot;$name onLongClick&quot;) &#125;&#125; 类委托后我们依然可以通过重写的方式来覆盖委托类的实现，这里View实现onLongClick方法，覆盖重写了ViewClickDelegate类里的onLongClick方法。 类委托的本质是：把抽象方法的实现交给了by后的委托对象 延迟初始化和委托属性延迟初始化属性不在对象创建的时候初始化，而是在第一次使用时初始化。完成后像普通属性一样使用 123456789101112open class Food(val name: String) &#123; override fun toString(): String &#123; return &quot;[$name]&quot; &#125;&#125;class Container(val name: String) &#123; lateinit var foodList: List&lt;Food&gt;&#125; 惰性初始化属性第一次使用该属性时才初始化，且只初始化一次。用旗号标示是否初始化过，旗号有多种选择和实现方式。 在代码定义处执行初始化，有助于代码维护。 对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。 普通实现12345678910class Container2(val name: String) &#123; private var _foodList: List&lt;Food&gt;? = null val foodList: List&lt;Food&gt; get() &#123; if (_foodList == null) &#123; _foodList = arrayListOf(Food(&quot;米糊&quot;)) &#125; return _foodList!! &#125;&#125; by lazy(){}实现惰性初始化1234567891011121314151617181920class Container4(val name: String) &#123; val food: Food by lazy&#123; Food(&quot;米糊&quot;) &#125;&#125;//指定锁class Container5(val name: String) &#123; val food: Food by lazy(Container5::class)&#123; Food(&quot;米糊&quot;) &#125;&#125;//默认 线程安全 SYNCHRONIZED//PUBLICATION，同步锁不是必需的，允许多个线程同时执行class Container6(val name: String) &#123; val food: Food by lazy(LazyThreadSafetyMode.SYNCHRONIZED)&#123; Food(&quot;米糊&quot;) &#125;&#125; 在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性，索引属性；关联属性，限制属性。接下来看下Kotlin如何实现关联属性和限制属性的 关联属性（可观察属性）通过PropertyChangeSupport代码实现属性监听12345678910111213141516171819class Shelf(val name: String, _book: Book) &#123; private val propertyChange: PropertyChangeSupport = PropertyChangeSupport(this) var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把逻辑封装，抽取出基类 123456789101112131415161718192021222324252627282930open class BasePropertyChange &#123; val propertyChange = PropertyChangeSupport(this) protected fun addChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(key, propertyChangeListener) &#125; protected fun removeChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(key, propertyChangeListener) &#125;&#125;class Shelf_2(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把book里的set访问器的逻辑封装成一个类 123456789101112131415161718192021222324252627282930class BookDelegate(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book fun getValue(): Book = field fun setValue(value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf2(val name: String, _book: Book) : BasePropertyChange() &#123; val _bookDelegate: BookDelegate = BookDelegate(_book, propertyChange) var book: Book set(value) &#123; _bookDelegate.setValue(value) &#125; get() = _bookDelegate.getValue() fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 至此，我们用Kotlin手工实现了可观察属性变化的功能，测试下 12345678910111213fun testObserverField() &#123; val shelf = Shelf2(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt.newValue as Book println(&quot;old book = $oldBook , new book = $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行上述代码结果如下： old book = Book(name=Think in java) , new book = Book(name=Kotlin in action) 使用Kotlin委托实现Kotlin的委托属性在语言层面提供了在属性的读访问器里调用委托类里operator修饰的两参数getValue方法，属性写访问器调用operator修饰setValue三个参数方法 12345678910111213141516171819202122232425class BookDelegate2(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book operator fun getValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;): Book = field operator fun setValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;, newValue: Book) &#123; val oldBook = field field = newValue propertyChange.firePropertyChange(&quot;book&quot;, oldBook, newValue) &#125;&#125;class Shelf3(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate2(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 通常借助ReadWriteProperty接口能方便我们实现委托 12345678910111213141516171819202122232425class BookDelegate3(var field: Book, val propertyChange: PropertyChangeSupport) : ReadWriteProperty&lt;Shelf3_1, Book&gt; &#123; override fun getValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;): Book &#123; return field &#125; override fun setValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;, value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf3_1(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate3(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 测试上述代码： 1234567891011121314fun testDelegateFieldForKotlin() &#123; val shelf = Shelf3_1(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt?.newValue as Book println(&quot;Kotlin委托 old book is $oldBook, and new book is $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action!&quot;)&#125; 运行结果如下： Kotlin委托 old book is Book(name=Think in java), and new book is Book(name=Kotlin in action!) 委托属性的本质：把属性访问器的实现交给了by后的委托对象 使用Kotlin的自带的实现可观察属性其实，Delegate.observable()类实现了上面提到的所有逻辑了。 我们看下Delegate.observable方法的源码 1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 该方法返回ObservableProperty对象，看下ObservableProperty对象源码 1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 该对象有getValue和setValue方法，这和我们自己实现的BookDelegate3类里的getValue和setValue方法逻辑几乎相同。不同之处是，官方还多了beforeChange()控制，和afterChange()供实现类覆盖重写。 Kotlin标准库已经提供了可观察属性的属性委托实现了 123456class Shelf4(val name: String, _book: Book) &#123; var book: Book by Delegates.observable(_book, &#123;property, oldValue, newValue -&gt; println(&quot;The old book&apos;s name is \&quot;$&#123;oldValue.name&#125;\&quot;, and the new book&apos;s name is \&quot;$&#123;newValue.name&#125;\&quot;&quot;) &#125;)&#125; 测试下上述的代码 1234fun testObserverFieldForKotlin()&#123; val shelf = Shelf4(&quot;书架&quot;, Book(&quot;think in java&quot;)) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行结果如下 The old book’s name is “think in java”, and the new book’s name is “Kotlin in action” 限制属性Kotlin也为我们提供了现成的委托类来实现限制属性 12345class Shelf5(val name: String, val book: Book ,_year: Int) &#123; var year: Int by Delegates.vetoable(_year, &#123;property, oldValue, newValue -&gt; newValue &lt;= 99 &#125;)&#125; 测试上述代码 12345678fun testVetoableFieldForKotlin()&#123; val shelf = Shelf5(&quot;书架&quot;, Book(&quot;think in java&quot;), 0) shelf.year = 200 println(&quot;current book is $&#123;shelf.year&#125;&quot;) shelf.year = 20 println(&quot;current book is $&#123;shelf.year&#125;&quot;)&#125; 运行结果如下： current book is 0current book is 20 注意：上述用的是成员函数，事实上，扩展函数也能实现委托属性 使用Map实现委托属性MapAccessors.kt文件里，有如下扩展函数源码 1234567891011@kotlin.jvm.JvmName(&quot;getVarContravariant&quot;)@kotlin.internal.LowPriorityInOverloadResolution@kotlin.internal.InlineOnlypublic inline fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V = @Suppress(&quot;UNCHECKED_CAST&quot;) (getOrImplicitDefault(property.name) as V)@kotlin.internal.InlineOnlypublic inline operator fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) &#123; this.put(property.name, value)&#125; 由此可见， MutableMap存在getValue方法和setValue方法，那么就可以用于委托，事实上，也确实如此。 举个例子: 123456789101112131415161718192021class Fruit(name: String) : Food(name)&#123; private val attributeMap = HashMap&lt;String, String&gt;() val color: String by attributeMap val size: String by attributeMap fun setAttributeMap(name: String, value: String)&#123; attributeMap.put(name, value) &#125;&#125;fun testDelegateMap()&#123; val fruit = Fruit(&quot;西瓜&quot;) fruit.setAttributeMap(&quot;color&quot;, &quot;绿色&quot;) fruit.setAttributeMap(&quot;size&quot;, &quot;2kg&quot;) println(&quot;color = $&#123;fruit.color&#125;, size = $&#123;fruit.size&#125;&quot;)&#125; 运行结果 color = 绿色, size = 2kg 小结类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 参考资料维基百科：惰性初始化模式 维基百科：惰性求值]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第五讲-Kotlin的类型和空处理]]></title>
    <url>%2F2018%2F06%2F07%2F2018%2F2018-06-07%2F</url>
    <content type="text"><![CDATA[##Kotlin的类型类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 以字符串类型举例，字符串平台类型如下： String！ 程序员不能使用这种语法，Java代码转Kotlin代码的时候会出现，表示可控性未知，也可以理解为己有肯能是非空类型也有可能是可空类型 ####非空类型和可空类型的理解可空类型 = 非空类型 + null Type? = Type + null 因此，String？，String是两种不同的数据类型，就像Int和String是两种数据类型那般。 ###基本数据类型Kotlin不区分基本数据类型和包装类型，都是使用一种基本类型： 下面是非空基本类型 Char, Boolean, Byte, Short, Int，Long, Float, Double 可空基本类型 Char？, Boolean?, Byte?, Short?, Int?，Long?, Float?, Double? Kotlin的基本类型如果转成Java基本数据类型，要怎么办？ 对于变量、属性、参数和返回类型，Kotlin的基本类型会被编译成Java的基本数据类型。用作泛型类型参数的基本数据类型会被编译成对应的Java包装类型。 注意： 和Java不同，小范围的值不能自动转化为大范围的值，而是看成两种不同的类型 下面的代码演示了数据类型的表示，各类型转化，数据类型智能推断，字符串类型转成基本数据类型 1234567891011121314151617181920212223242526272829303132333435fun testBasicType() &#123; val bb: Byte = 127 val boolean = false val aa: Char = &apos;a&apos; var i: Int = 21_4748_3647 //10位 var l: Long = 922_3372_0368_5477_5807L //19位 //不存在小写的l val f: Float = 123f val f2: Float = 124F val a16 = 0x123ef3 val b16 = 0XcCCef3 val c2 = 0b1010 val cc2 = 0B11001 val b: Byte = 1 val eas = b + 1L //Long + Byte =&gt; Long , eas为Long类型 fun foo(l: Long) &#123; println(l) &#125; foo(44) //单独写44可能是byte，int long，这里智能推断44会被认为是long //字符串转基本数据类型 val p = &quot;44&quot;.toInt() val p2 = &quot;44&quot;.toLong() val p3 = &quot;44&quot;.toFloatOrNull() val p4 = &quot;44&quot;.toDouble() val translate = l.toInt().toLong().toFloat().toDouble().toInt()&#125; ###Any，Unit，Nothing类型 Any 相当于 Object，不同点：是非空类型，缺少Object的wait，notify方法 Unit相当于Java的Void；不同点：Unit是一个完备的类型，可以作为类型参数。Unit是Any的子类 Nothong表明函数不会有返回类型（没有返回类型），该函数不会正常终止，Nothing是Unit的子类 1234567891011121314151617181920212223242526272829303132fun getStrinLenght(s: String?): Int &#123; if (s == null) &#123; throw IllegalArgumentException() &#125; else &#123; return s.length &#125;&#125;fun fail(): Nothing = throw IllegalArgumentException()fun getStrinLenght2(s: String?): Int = if (s == null) &#123; fail() &#125; else &#123; s.length &#125;fun testAnyAndNothing(o: Any?): View &#123; val filterO = o ?: fail() return when (filterO) &#123; is View -&gt; &#123; View(&quot;View&quot;) &#125; is TextView -&gt; &#123; TextView(&quot;TextView&quot;, &quot;&quot;) &#125; else -&gt; &#123; fail() &#125; &#125;&#125; 可以认为：throw IllegalArgumentException()返回的类型是Nothing，nothing是Int的子类型。 ####小结Any，Unit和Nothing三者关系： A Whirlwind Tour of the Kotlin Type Hierarchy ##空安全相关的运算符 ###安全调用？.如果值是null，整个表达式的值为null。 12345678open class Company(val name: String, val address: String?)fun testNullType()&#123; val company = Company(&quot;京东&quot;, null) val length = company.address?.length println(&quot;length = $length&quot;)&#125; ###Elvis运算符 ？： 12345678910fun testElvis(list: List&lt;Company?&gt;?, defaultAddress: String?)&#123; val defaultAdd = defaultAddress ?: &quot;&quot; val length = defaultAddress?.length ?: 0 //.?为空调用，表达式返回null，遇到了？： println(&quot;defaultAdd = $defaultAdd, length = $length&quot;) val companyList = list ?: throw IllegalArgumentException(&quot;null list&quot;) val address = companyList[0]?.address?.toUpperCase() ?: defaultAddress //多重空安全调用和Elvis联合使用 println(&quot;address = $address&quot;)&#125; ###安全转换as?as？运算法尝试把值转换成制定的类型，如果值不是合适的类型就返回null。 1234567891011121314151617181920212223open class View(val name: String)class TextView(name: String, val text: String) : View(name)fun testAsClient()&#123; val company = Company(&quot;JD&quot;, &quot;亦庄&quot;) testAs(company) testAs2(company) val tv = TextView(&quot;TextView&quot;, &quot;I am a message content&quot;) testAs2(tv)&#125;fun testAs(o: Any)&#123; val tv = o as TextView println(&quot;name = $&#123;tv.name&#125;&quot;)&#125;fun testAs2(o: Any)&#123; val tv = o as? TextView ?: TextView(&quot;Default TextView&quot;, &quot;&quot;) println(&quot;The content of $&#123;tv.name&#125; is = $&#123;tv.text&#125;&quot;)&#125; ###非空断言 !! 把任何值转换成非空类型 12345678910fun testNoNullClient()&#123; val result = testNoNull(&quot;Kotlin&quot;) println(&quot;result = $result&quot;)&#125;fun testNoNull(s: String?) : String&#123; val length = s!!.length println(&quot;$s&apos;s length is $length&quot;) return s!!.toUpperCase()&#125; ###let函数 把可空值作为实参传递一个只接收非空值的函数 1234567891011121314151617fun testLet()&#123; val length = getTheBigCompanyInTheWorld().address?.length val upperCase = getTheBigCompanyInTheWorld().address?.toUpperCase() val letter = getTheBigCompanyInTheWorld().address?.get(0) println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;)&#125;fun testLet2()&#123; getTheBigCompanyInTheWorld().address?.let &#123; val upperCase = it.toUpperCase() val length = it.length val letter = it[0] println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;) &#125;&#125;fun getTheBigCompanyInTheWorld(): Company = Company(&quot;JD&quot;, &quot;Beijing&quot;) ###可空类型的扩展函数 允许接收者为null的调用，在扩展函数内部处理null。不需要安全调用了 看几个Kotlin标准库，String定义的扩展函数isNullOrEmpty 123public inline fun CharSequence?.isNullOrEmpty(): Boolean &#123; return this == null || this.length == 0&#125; 注意： 在Java中，this永远是非空的，在Kotlin中，this可以为null。 因此在定义扩展函数时，需要考虑扩展是否需要为可空类型定义。本质上是对null在哪个环节处理的思考，是要在调用时使用空安全调用处理呢，还是在调用的函数内部处理。 ###泛型参数默认是可空类型 1234567fun &lt;T&gt; myPrintln(t: T)&#123; println(t.toString())&#125;fun testGenericityClient()&#123; myPrintln(null)&#125; ###转Java代码为Kotlin代码时，对空的处理 ####带注解的Java变量翻译到Kotlin时被认为是可空类型或者非空类型 Javax.annotation包下 android.support.annotation包下 org.jetbrains.annotations下 @Nullable + Type = Type?@NotNull + Type = Type ##参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马龙--坚如磐石的战士]]></title>
    <url>%2F2018%2F06%2F03%2F2018%2F2018-06-03%2F</url>
    <content type="text"><![CDATA[正文乒乓球偶像，88年的马龙，今年正好三十岁，对于乒乓球职业选手，这不是个年轻的岁数。从竞技水平来看，马龙仍是巅峰状态，如此高龄依然保有极高的竞技水平，这源于马龙持续的自律和刻苦训练。 他的职业荣耀无与伦比，乒坛史上第10位大满贯，首位集奥运会、世锦赛、世界杯、亚运会、亚锦赛、亚洲杯、巡回赛总决赛、全运会单打冠军于一身的超级全满贯。 高光时刻 2003年，年仅15岁进入国家队。 2006年，出征不莱梅世锦赛团体赛，获得自己第一个世界冠军 2011年8月苏州公开赛到2012年1月底的斯洛文尼亚公开赛，224天实现了的56场不败的记录。 2014年当选中国乒乓球男队队长 2016年 里约奥运会男子单打冠军，实现男单大满贯和全满贯… 黯然时光在这高光的时刻背后，有着一段黯然，隐没在2012到2014的张继科的辉煌下，尤其是2014年10月的世界杯输给张继科之后。但是，马龙没有放弃，积极的调整自己，听取了刘国梁指导的建议，换了新胶皮，改进了打法，突出了更多的旋转和变化。 转折点来自2015年苏州世乒赛，在领先后被方博追到2:3时刻，马龙没有心理崩盘，而是顶住压力，完成逆袭，取得了胜利。这次胜利，龙队犹如脱胎换骨，开启了走向全满贯之路 马龙赛后真情流露： 其实这么多年来，我一直被人期望着，每年自己都有进步，但跟大家想象的还是差一些。这几年张继科成绩很惊人，大家拿我跟继科比较，因为成绩一直不如他，这让我很没自信。不过自己从来没有放弃，压力都顶住了，非常兴奋 进击的国手龙队一直保持着对乒乓球的热爱，在困难面前不放弃，积极调整，持续练习，形成了独属于自己的球路风格–弧线，旋转，力量，落点，速度，节奏这六个方面全都超一流，成为了独特的六边形战士，地表最强第一人。 在龙队身上，我看到了一位职业选手，在自己职业生涯的中后期勇敢转型，不放弃自己的热爱，不懈地去努力，直至迎接独属自己的辉煌时代，这是韧性的霸气。 马龙让我佩服得五体投地之处还在于他不断地顶住樊振东一波又波的猛烈冲击，从2014年开始到现在，15胜1负（就在昨晚中国深圳白金公开赛4-1战胜樊振东夺冠），这源于他极强的自律和刻苦训练，以及他对乒乓球的异乎常人的深刻理解。 获得此次的中国公开赛后，马龙公开赛冠军数达到了26个，距离最萨姆索诺夫的27个不远了。往后马龙的每一次比赛夺冠，都将创造乒坛历史记录。 向继续前行在乒坛之路，有可能双全满贯的马龙致敬。 小结编程如乒乓，在不如意时不放弃，在困难时不放弃，在春风得意的时候不松懈，持续的练习，持续的思考，持续的积累，持续的精进。站在最高的高处，领略四时风光和巅峰的精致]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Sports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第四讲-Kotlin的类、对象和接口]]></title>
    <url>%2F2018%2F05%2F27%2F2018%2F2018-05-27%2F</url>
    <content type="text"><![CDATA[类类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 为了简化，Kotlin支持步骤2和步骤1合并操作，在主构造函数参数前加var/val； 支持步骤3和步骤2合并，对定义的属性直接赋值。支持步骤3和步骤2和步骤1合并操作，使用主构造函数的默认参数表达。 当然这些合并带来简便的同时，降低了构造的能力。 最初的状态（步骤1，步骤2，步骤3都存在） 123456789class User(_sickName: String)&#123; val sickName: String init &#123; println(&quot;init&quot;) sickName = _sickName &#125;&#125; 步骤2和步骤1的合并，在主构造函数里传参和定义类的属性 123456class User(val sickName: String)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 步骤3，步骤2和步骤1的合并 123456open class User private constructor(val sickName: String = &quot;Kotlin&quot;, var age: Int)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 注意：Java中需要重载构造方法的场景大多数都被Kotlin参数默认值和参数命名的语法特性涵盖了 子类的构造方法 123456789101112131415 open class AirBook(name: String, val year: Int, val size: Int) &#123; constructor(name: String, year: Int) : this(name, year, 22)&#123; println(&quot;constructor&quot;) &#125;&#125; class MacBookPro: AirBook&#123; public constructor(name: String, year: Int) : super(name, year) &#123; &#125; public constructor(name: String, year: Int, size: Int) : super(name, year, size)&#123; &#125;&#125; 子类在创建的时候，必须调用父类的构造函数，如果其父类还有父类，仍然要调用父类的父类的构造函数，直至顶层的基类。 12345678open class AirBook(name: String, val year: Int, val size: Int)&#123; init &#123; &#125; constructor(name: String, year: Int) : this(name, year, 22)&#123; &#125;&#125; 构造函数可以调用当前自身的构造函数，因为自身的构造函数必然有至少一个调用了父类的构造函数。 属性访问器在kotlin里，一个属性 = 字段 + 属性访问器；这里的字段是Java里的成员变量 属性访问器分为读访问器getter，和写访问器setter 访问器里存在field字段，用来连接写访问器和读访问器，作为两者的通信桥梁 val修饰的属性只有读访问器，var修饰的属性既有有读也有写访问器 Kotlin引入属性访问器后，凡事对属性进行赋值操作，就会调用属性的写访问器setter；读取值的操作对应调用的是属性的读访问器 那么如果我们要自定义一个类似Java里的setter方法，要怎么做呢？ 通过var变量的私有setter来实行 代码如下: 12345678910class TableLamp(val name: String, lightness: Int)&#123; var lightness: Int = 1 private set fun setupLightness(lightness: Int)&#123; this.lightness = lightness println(&quot;setupLightness lightness = $lightness&quot;) &#125;&#125; 这样对属性lightness的修改，只能通过setupLightness方法。 修饰词final, open, abstract相互影响和使用Kotlin的函数，类默认是final的，如果想重写函数，类有子类，则需使用open修饰。abstract修饰的函数和类，意味着有open的特性。这和Java的用法是一致的。 Kotlin自带的特殊类数据类，嵌套类，内部类，密封类的基本写法这里就略去不谈。 数据类datadata修饰的类，必须有主构造函数，且主构造每个入参必须都val或var修饰 data修饰补充的方法里的所用的变量取决于主构造函数的入参 嵌套类和内部类定义在某个类内部并用inner修饰的类称为内部类 嵌套类可以类比Java的静态内部类，Kotlin的内部类类比Java的内部类，他们含有外部类的引用。与Java内部类不同的是，Kotlin的内部类能对外部类的变量进行写操作。 举个例子 123456789class TextView&#123; var counter: Int= 0 inner class Operator&#123; fun calculate()&#123; counter ++ &#125; &#125;&#125; 内部类Operator的成员函数可以写外部类的counter属性，这在Java里是做不到的。 密封类sealed关键词修饰的类，表达有限个子类。 123456789sealed class Color constructor(val name: String)class Red : Color(&quot;Red&quot;)class Green : Color(&quot;Green&quot;)class Blue : Color(&quot;Blue&quot;)class Gray : Color(&quot;Gray&quot;) 上述写法，编译器就会知道，Color的子类的数量，此例Color一共只有四个子类，分别是：Red，Green， Blue， Gray。如果增加或删除Color的子类，编译器是能感知到的。密封类的子类可以作为嵌套类，也可以写在密封类所在的文件里，但是不能写在其他文件里。 举个和When搭配的应用例子： 12345678910111213141516171819fun testSealed(color: Color): Int = when (color) &#123; is Red -&gt; &#123; println(&quot;Red&quot;) 1 &#125; is Green -&gt; &#123; println(&quot;Green&quot;) 2 &#125; is Blue -&gt; &#123; println(&quot;Blue&quot;) 3 &#125; is GRAY -&gt;&#123; println(&quot;GRAY&quot;) 4 &#125; &#125; 密封类的意义：如果不用密封类，使用when总是不得不添加一个默认分支。更重要的是，如果你添加了一个新的子类，编译器并不能发现有地方改变了。如果你忘记了添加一个分支，就会选择默认的选项，这可能导致潜在的bug。 使用密封类就能解决上述的问题。 Object的使用声明一个类并创建一个对应的实例。与类一样，对象可以包含属性，方法，初始化语句块等的声明。对象声明可以继承类和实现接口，尤其不包含状态的时候很适用，也可以有扩展函数。 对象声明创建单一的实例，对象声明在定义的时候就创建了，不需要在代码的其他地方调用构造方法。 因此，对象声明不允许有构造函数。 123456object NameComparator : Comparator&lt;String&gt;&#123; override fun compare(o1: String, o2: String): Int &#123; return o1.compareTo(o2, true) &#125;&#125; Java调用上述代码，则需要通过INSTANCE来调用，如下 1CaseInsensitiveFileComparator.INSTANCE.compare(&quot;abc&quot;, &quot;abe&quot;); 伴生对象创建单一的实例，可以实现Java里访问类的私有成员的静态方法 在对象声明的基础上，使用companion关键字来标记，这样做就获得了直接通过容器类名称来访问这个对象的方法和属性的能力。 举个例子，实现CarFactory工厂 通过对象声明的实现 1234567891011class CarFactory&#123; object Instance&#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.Instance.newCar(&quot;Mini Cooper&quot;) 通过伴生对象的实现 1234567891011class CarFactory&#123; companion object &#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.newCar(&quot;Mini Cooper&quot;) 对象表达式既然是表达式，就意味着有返回值 与Java的匿名内部类只能扩展一个类或者实现一个接口不同，Kotlin的匿名对象可以实现多个接口或者不实现接口。 与对象声明不通，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。在对象表达式里不经可以访问创建它的函数中的变量，还可以修改变量的值 举个例子 12345678910fun countClick(view: View)&#123; var clickCount = 0 view.addClick(object : IClick&#123; override fun onClick() &#123; clickCount ++ &#125; &#125;)&#125; 小结object对象在Kotlin中的意义： 实现Java里静态的功能，等效实现静态调用 代替Java匿名内部类书写 接口123456789interface IFocus &#123; val focusName: String fun showOff()&#123; println(&quot;IFocus foucusName length = $&#123;focusName.length&#125;&quot;) &#125; fun onFocus()&#125; IFocus接口声明函数，让子类实现，默认方法showOff，和抽象方法onFucus 123456789class View : IFocus&#123; override val focusName: String get() = &quot;View&quot; override fun onFocus() &#123; showOff() &#125; &#125; View实现IFocus接口，focusName由View来确定，获取focusName逻辑写在IFocus的默认方法里。调用如下 val view = View() view.onFocus() 调用返回内容 IFocus foucusName length = 4 其他访问权限修饰词protected在Kotlin和Java的区别kotlin中protected只能是其子类和自身才能访问；Java中则是同包下所有文件和不同包的子类能访问 Kotiln访问权限由小到大排列依次是：private, protected, internal, public Kotlin函数和属性默认是public的，Java的默认是包级访问范围，即同一个包下的类能访问。Kotlin缺少包级别访问控制，而多了一个模块访问范围internal。internal表示同一个项目模块下的类都能访问 参考资料 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法岗位知多少]]></title>
    <url>%2F2018%2F05%2F19%2F2018%2F2018-05-19%2F</url>
    <content type="text"><![CDATA[算法工程师这个带着亮光的耀眼称呼，和AI有着紧密的天然联系，令人向往。今天和算法工程师午饭闲聊，对算法工程师的工作有了新的感触和认知。 正文验证算法实验时用Python，工程应用时用Spark，sql查询使用基于Hadoop的Hive工具。一些常规的数据处理，比如计算均值，寻找最大，最小值，这些并不需要用到高深的算法知识。 前端通过调用API和开源类库就可以实现相当多的算法，并不要算法工程师参与。当遇到如下的情况：对某个算法进行修改，定制化功能等，算法工程师才有很大的发挥空间和价值 算法工程师的价值，是引入算法或者改进已有算法后，能增加多少效益。但是，有时候这个效益是比较难量化的。比如推荐算法，对这个人推荐的效果好，对其他人的推荐效果可能就不好。任何算法，只要找到切入点，都能讲出算法的可行性和良好效果。 人工智能现在是很热的概念，就像前几年的云计算，大数据，物联网。自从AlphaGo战胜人类围棋天才，人工智能走入了大众的视野。有清晰的规则，算法的威力才会很强大。算法工程师真实的工作内容和AlphaGo的是两个世界，人工智能是算法的一个领域。 算法工程师的成长路径： 已知算法融会贯通，然后研究出新的算法，形成影响，给其他的算法工程师使用 转型成为算法类的产品经理或者团队管理者，知道这个算法能解决什么问题，有什么优势和不足，适用范围，连接业务和商业化。 算法工程师的成长路径放到其他领域同样成立。纵向学习成为领域专家，横向扩展成为产品经理、团队管理者。 算法浩如烟海，每年都有大量的新算法诞生，算法工程师需要大量的学习、跟进和迭代算法。这个过程是走向领域专家的自然过程，如果期间有了量变，将爆发出惊人的能量。 建立算法模型需要选取特征量，考虑影响因素。这些因素如何而来？在模型理论上的输入值和具体业务之间找到对应关系，一个学术上的因素会裂变为工程上多个影响因素，因素和因素之间还需要他们的依赖关系。即使考虑很清楚了，想到的影响因素也只是客观存在的全部影响因素里的一小部分，没有办法全部找到。 如何解决这个难题呢？通过神经网络、深度学习。让数据一个一个的进入神经网络，拟合出满足业务需求的曲线。根据全息理论：部分是整体的缩影。因此每一个数据点上包含了所有的影响因素的影响。 小结技术环节可以有这样的分类：底层算法研究性，中间过渡带，业务开发。每个环节都需要管理者，但是管理者的角色在不同环节上是有差异的，算法和中间过渡带是相对更强调技术能力的。越往下，技术的力量越能显现出威力和价值，相伴而生的是技术精进的难度也越来越大。]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国佛教发展史略一书随感]]></title>
    <url>%2F2018%2F05%2F13%2F2018%2F2018-05-13%2F</url>
    <content type="text"><![CDATA[上周开始读南师的中国佛教发展史略，书里阐述了从佛教在印度产生的文化背景到佛教在中国历朝历代的发展脉络，再到二十世纪的中国佛教的状况。特别地，南师说了更多有关推动中国佛教发展历程的历史人物。 书里有下面这段话 我认为人世间最高的组织，是由于人与人之间真感情的结合，所谓至性至情的流露。其次，才是如宗教一样的信仰，所谓崇拜的服从。再其次，才是法律和规范。至于从利害相关的集合，用权位生杀来范围，那是等而下之，等于市场的交易而已 人与人的真感情以及至诚至性，就是说充分发挥成员的天性，组织提供充分的的安全感，成员们不必掩饰的表达自我。 稻盛和夫说，人有三等资质 一等资质深沉厚重，二等资质磊落豪雄，三等资质聪明才辩 比必聪明才辩更高的是情感的力量，不管是深沉厚重还是磊落豪雄，都是对情感的描述。 中庸一文，类似的观点有 唯天下至诚，为能尽其性；能尽其性，则能尽人之性；能尽人之性，则能尽物之性；能尽物之性，则可以赞天地之化育；可以赞天地之化育，则可以与天地参矣。 要达到尽人之性（做到至情至性和深沉厚重），就需要至诚（唯天下至诚）。常有国学从说文解字开始，那么诚，是什么含义呢？ 123基本字义1. 真心，诚意：～恳。～朴。～实。～挚。忠～。心悦～服。2. 实在，的确：～然。～有此事。 真心实在，就是诚。 真心、实在能尽人之性，让我们与周围人形成感情的回路，这样至诚至性的流露，促成了坦荡和磊落，也就深沉和厚实了。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin百问]]></title>
    <url>%2F2018%2F05%2F11%2F2018%2F2018-05-11%2F</url>
    <content type="text"><![CDATA[02表达式和语句的差别？ 表达式有返回值，语句没有 表达式可以成为另一个表达式的一部分，而语句是并列关系 延伸：根据上述差异可知，if，when是表达式，for, while循环结构和赋值操作是语句。利用表达式有返回值，可以用来替换函数里出现的return，通过kotlin类型推导也可以省略函数返回类型的声明，或者变量的类型声明 补充：Java中的赋值操作是表达式，赋值表达式的值等于要赋的值 在Kotlin中，不可变性体现在哪些方面？变量声明分为：val不可变引用，var可变引用 集合声明分为：可变性集合和不可变集合，不可变集合在集合初始化的时候填充数据，不支持add／remove方法。可变性集合通过mutable打头的方法声明 成员方法默认是不能被重写的，需要方法的关键词fun前增加open关键词改变 类默认是不能被继承的，需要在class关键词前添加open关键词改变 延伸：Kotlin上述的设计，符合Effective Java2中第15条：使可变性最小。不可变引用，不可变对象和无副作用的函数让代码更接近函数式编程 补充：对象不可变性给编码带来如下影响： 易于逻辑维护，对象只有单一的初始化状态 满足线程安全的 构成函数式编程的要素之一 对每个不同的值都要一个单独的对象，因此有可能存在潜在的性能问题 Kotlin为什么不区分受检异常和非受检异常？对于这个问题，我希望Kotlin能支持受检异常，王垠在这篇文章Kotlin 和 Checked Exception提到，我表示赞同。 补充：Java异常继承体系：第一层Throwable， 第二层：Exception， Error Exception分为两类：受检异常（checkedException）和运行时异常（RuntimeException），运行时异常也叫非受检异常。 编程人员必须强制处理（捕获或者抛出）受检异常，不要求强制处理非受检异常（可处理也可以不处理，不处理有可能崩溃）。 常见的受检异常Exception, FileNotFoundException, IOException, SQLException 常见的未检查异常NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException 03Kotlin里没有static修饰词，如何实现静态方法或者属性呢？有两种方式实现： 顶层函数和顶层属性 类的匿名伴生对象companion object 为什么扩展函数不能被子类重写？因为扩展函数不是真的类的成员函数，扩展函数的本质是：接收者对象作为第一个参数的静态函数，所以不能被子类重写。 增加类的能力，什么情况下使用成员函数，什么情况下使用扩展函数？这个新增的能力只需要访问public的成员和函数，同时不想修改这个类的源代码，同时不属于成员函数的考虑范围的，使用扩展函数。比如对第三方类库的拓展能力 需要在子类重写这个函数，把这个函数纳入到继承体系里时，使用成员函数。 什么情况需要引入局部函数？逻辑复用的作用域只在某个函数体内时，在这个函数里定义局部函数]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第三讲-拓展函数及其他]]></title>
    <url>%2F2018%2F05%2F07%2F2018%2F2018-05-07%2F</url>
    <content type="text"><![CDATA[集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 1234567891011121314151617181920212223242526public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123; override fun add(element: E): Boolean override fun remove(element: E): Boolean override fun addAll(elements: Collection&lt;E&gt;): Boolean public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean override fun removeAll(elements: Collection&lt;E&gt;): Boolean override fun retainAll(elements: Collection&lt;E&gt;): Boolean override fun clear(): Unit public operator fun set(index: Int, element: E): E public fun add(index: Int, element: E): Unit public fun removeAt(index: Int): E override fun listIterator(): MutableListIterator&lt;E&gt; override fun listIterator(index: Int): MutableListIterator&lt;E&gt; override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;&#125; MutableList接口提供了增加和删除集合元素的能力。 创建不可变集合val list = listOf&lt;String&gt;(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val letter = list[0] var list1 = listOfNotNull&lt;Int&gt;(1, 4, 8) 创建可变集合val list2 = arrayListOf&lt;Int&gt;(1, 2, 3, 4) list2.set(0, 10) list2[0] = 10 list2.add(5) println(&quot;list2 = $list2&quot;) val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.add(&quot;d&quot;) println(&quot;e = $list3&quot;) println(&quot;last element = ${list3.last()}&quot;) val list4 = mutableMapOf&lt;String, String&gt;(&quot;1&quot; to &quot;A&quot;, &quot;2&quot; to &quot;B&quot;) val list5 = mutableSetOf&lt;String&gt;(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;) 参数Kotlin的函数比Java函数强大的地方之一是入参可以有默认值，即默认参数； 在Kotlin调用函数时，可以指定入参的名称，即命名参数； 与Java不同，Koltin表示可变参数，不是参数后面加三个点，，而是在入参前加vararg关键词即可。Kotlin中存在一个展开运算符 – *（星号），它和可变参数搭配使用；作用是把一个数组展开成可变参数传入 详细说明，可看这篇文章Kotlin里的输入参数 顶层函数与属性 很多代码并不能归属到任何一个类中，有时一个操作对应两个不同的类的对象，而且重要性相差无几。 有时存在一个基本的对象，但不想通过实例函数来添加操作，让它的API继续膨胀。 在Java里，我们使用静态方法。Kotlin里没有static修饰词，它一种方式，使用顶层函数来实现相同的效果。 顶层函数实现一个功能，把集合中元素添加前缀，后缀，用分隔符间隔展示 在kt类里直接写 12345678910111213141516171819const val counter: Int = 0fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String ): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 顶层函数是包内成员，包内直接访问。若包外访问，需要import（IDEA等开发工具会为你自动import） 顶层函数是都是静态函数，默认函数所在的文件名加KT作为容器类，比如上述joinToString方法是在Example3_2文件名下的顶层函数，在Java里调用是时 Example3_2Kt.joinToString(collection, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;); 如果我想更改调用静态方法的容器类的类名为StringUtils，则需要在kotlin文件里添加 @file:JvmName(&quot;StringUtils&quot;) 这时候调用形式如下： StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 顶层属性counter就是顶层属性，等效于容器类的静态成员变量，即Java里如下写法 public static final int counter = 0; 拓展函数与属性拓展函数基本使用StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 每次调用上述实现的joinToString方法传入四个参数，有点多，我希望减少入参数量。StringUtils是工具类类名，工具类类名在整个调用过程中是不够高效的。达到优雅的途径之一就是做到高效而简洁。这个工具类具体是什么名字并不会影响这个函数的输入和输出，这个类名的意义是作为joinToString容器的标示，如果能把其中一个入参名作为类名，这个入参同时做两件事：传入自身到函数体里，作为调用的句柄名。 强大的Kotlin为我们实现了这样的能力：扩展函数。把上述方法生命为一个拓展函数，如下所示： 1234567891011fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;)&#123; val sb = StringBuilder() sb.append(prefix) for((index, element) in this.withIndex())&#123; if(index &gt; 0)&#123; sb.append(separator) &#125; sb.append(element.toString()) &#125; sb.append(postfix)&#125; 接收者类型：函数名前的类，上例Collection就是该扩展函数的接收者类型 接收者对象：接收者类的实例，上例this.withIndex方法的this指代的就是Collection对象，是该扩展函数接收者对象 这时候我们要使用joinToString方法，变成这样用了 val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.joinToString(&quot;_&quot;, &quot;[&quot;, &quot;]&quot;) 导入范围需要进行导入扩展函数才能生效，好在开发工具为我们自动导入了。如果定义的扩展函数所在的类和其接收者类型的类在一个包下，可以不需要显式导入。 有一种情况，如果你定义的扩展函数名和其他包里定义的函数名相同，你需要导入全类名以示区分。还有另一种方式，通过as在导入的地方重命名扩展函数名 import sugarya.chapter3.joinToString as jts 这时候，就可以调用jts就相当于调用joinToString方法 扩展函数的本质和特性其实，Kotlin把上述代码翻译到JVM上运行时。拓展函数的本质是：把接收者对象作为第一个入参的函数。通常我们在顶层位置定义扩展函数，这样扩展函数就能被其他包的文件调用。因此，扩展函数并没有改变接收者类里的代码，扩展函数并不是类的一部分，它是声明在类之外的，却能像成员变量那般使用。 像成员变量那般使用，扩展函数和成员变量不是一回事，它们之间是有区别的 扩展函数不能访问私有或者受保护的成员，因为接收者对象只是静态方法的一个入参，这个入参有大的访问能力，扩展函数就是多大访问能力。 扩展函数不能被接收者类的子类重写／继承。前面说了，扩展函数只是静态方法，并不是真实的接收者里的成员，自然也就无法重写了。 对于第2点的理解，我们举一个例子 12345678910111213class Person(name: String, var age: Int) : Animal(name)//拓展定义是写在Example2_4.Kt文件里fun Animal.move()&#123; println(&quot;animal move&quot;)&#125;fun Person.move()&#123; println(&quot;Person move&quot;)&#125;val animal: Animal = Person(&quot;Kotlin&quot;, 5)animal.move() 输出结果： animal move animal.move是拓展函数，转化为静态方法是Example2_4.move(animal),所以，move方法调用的就是Animal类下的move。 扩展属性扩展属性是对扩展函数能力的弱化／简化使用。相当于Java里第一个参数是接收者对象的静态getter方法和setter方法。扩展函数和扩展属性搭配使用，在扩展函数里访问扩展属性。举个例子 val Animal.length: Int get() = this.name.length * 10 fun Animal.move(){ println(&quot;animal move ${this.length}&quot;) } 扩展函数的应用看几个扩展函数的应用例子 分割字符串有一个字符串“ab.cd12.ef”，需要分割成三部分：ab, cd12, ef 使用Java，我们很容易写成这样 String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;.&quot;); java里split（）方法入参的字符串表示的正则表达式，在正则表达式里“.”表示任意字符，所以，如果照上面所写，返回为空，找不到字符。 使用Java正确实现是： String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;\\.&quot;); Kotlin在此基础上，通过扩展函数扩展字符串方法，通过默认参数实现重载效果。 123456789101112131415161718192021/** * Splits this char sequence to a list of strings around occurrences of the specified [delimiters]. * * @param delimiters One or more strings to be used as delimiters. * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`. * @param limit The maximum number of substrings to return. Zero by default means no limit is set. * * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from * the beginning to the end of this string, and matches at each position the first element in [delimiters] * that is equal to a delimiter in this instance at that position. */public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123; if (delimiters.size == 1) &#123; val delimiter = delimiters[0] if (!delimiter.isEmpty()) &#123; return split(delimiter, ignoreCase, limit) &#125; &#125; return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map &#123; substring(it) &#125;&#125; Kotlin实现 &quot;ab.cd12.ef&quot;split(&quot;.&quot;) Kotlin里用Regex类表示正则，使用正则实现如下 val regex = Regex(&quot;\\.&quot;) val result = &quot;ab.cd12.ef&quot;.split(regex.toPattern()) 解析字符串在Kotlin变得更容易了，除了split，Kotlin还提供了其他方法，再看一个例子 解析文件路径解析一个文件路径：“/Users/mine/Documents/MyDocument/Photoes／546294_308008399296566_779316797_n.jpg”,获取目录路径，文件名，文件拓展名 Kotlin代码实现 val msg = &quot;/Users/mine/Documents/MyDocument/Photoes/546294_308008399296566_779316797_n.jpg&quot; val dirPath = msg.substringBeforeLast(&quot;/&quot;) val filePath = msg.substringAfterLast(&quot;/&quot;) val fileName = filePath.substringBeforeLast(&quot;.&quot;) val extendName = filePath.substringAfterLast(&quot;.&quot;) println(&quot;directory path = $dirPath, fileName = $fileName, extendName = $extendName&quot;) 输出： directory path = /Users/mine/Documents/MyDocument/Photoes, fileName = 546294_308008399296566_779316797_n, extendName = jpg 局部属性在Java里，函数的最小的作用域是在一个类里（private修饰的方法），而Kotlin引入局部函数–允许在函数里定义一个函数，让函数（方法）的最小作用域降到一个函数体里。提供更小粒度的复用，这样有什么意义呢？ 这样是有意义的。 没有局部函数的特性的Java语言里，对方法最小作用域的组织方式是这样的：一个复杂的类里有很多方法，当方法A里的代码行数很多时，通常拆分出几个新的方法a1，a2，a3等等，这些新的方法之间如果存在整体的逻辑关系，就能组合成一个内部类，a1，a2，a3是该内部类的方法。直接在A里新建内部类并调用即可。外部类的其他方法比如方法B也能方便的调用。 Kotlin局部函数提供了比上述Java更细致的代码组织方式：如果我们只在一个方法A里多次用到，这时候在方法A里，定义a1，a2，a3，在方法A里多次使用方法a1，a2，a3。这种方式相较于上面的内部类组织方式，带来的益处是降低定义内部类带来的语法开销。 对于什么时候引入局部函数，我们有了下述认识：当需要在方法粒度上多次调用一段逻辑时。具体的场景有，登录验证，表单数据校验。 中缀调用 对只有一个参数的函数使用中缀调用 中缀调用的函数，需要对其使用inflix修饰符 中缀不仅适用于成员函数也适用于扩展函数 举个中缀的例子 val pair: Pair&lt;String, String&gt; = &quot;a&quot; to2 &quot;A&quot; 上面的中缀调用是怎么定义呢？ infix fun &lt;T, V&gt; T.to2(v: V): Pair&lt;T, V&gt; = Pair(this, v) 三重引号的字符串三重引号字符串不仅在于避免转义符，而且可以包含任何字符，包括换行符。 看一个佛祖镇楼的例子 1234567891011121314151617181920212223 val bless = &quot;&quot;&quot; _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG &quot;&quot;&quot; println(bless) 这样控制台按原样格式输出佛祖图 小结这是Kotlin实战第三章涉及的所有知识点，结合自己的理解整理归纳成本篇文章。]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次龙泉寺周末心旅]]></title>
    <url>%2F2018%2F05%2F05%2F2018%2F2018-05-05%2F</url>
    <content type="text"><![CDATA[感恩此因缘参加龙泉寺的周末心旅。感恩义工师兄的辛苦付出，感恩共业师兄们一起学习陪伴，感恩结行之际贤方法师的答疑解惑。 缘起我的家乡在福建，那一带寺庙众多。妈妈信佛，每逢节日必会上山入寺，或烧香拜拜，或求签祈福。小时候在一旁默默观看，俱是不以为然，不明所以。 大四那年在一家早教公司做实习，期间公司安排同事们每日一起晨读论语，或大学，或中庸，或道德经半个小时，每逢周三下班，聆听一位历史老师的论语讲解，老师的讲解不仅从儒家文化出发，还会引据佛经和相关的故事来论证观点，比如：天下无二道，圣人无两心，圣人只说家常语；认识生命的本来面目，明明德、觉、佛、观自在，实事求是，为人民服务说得都是一件事，三藏十二部就说一句话：别胡思乱想，等等。这些和佛学有关的论点在我心里埋下了对佛法好奇的种子，它们和儒家经典一同在我混沌朦胧的内心世界犹如一道闪电乍现而过，明亮夺目，事后又难寻痕迹。只好闲暇晨起诵读经典，回忆咀嚼，心向往之，不求甚解。 行路中周末心旅早晚课给我留下了深刻的印象。第一天晚课非常可惜，在那本黄色的小册子里找不到诵读对应的经文，最后只好闭上双眼感受音律，唱诵经文当成了聆听歌曲。第二天的早课，时间紧张，如则不便，没有像往日早起出恭。早课期间肚子不适，课至中段，只觉得双脚酸麻，头晕欲坠，现在想来，和佛经因缘未至吧。 比早晚课更让我印象深刻的是第二天下午临近结业的法师答疑。见到法师笑容温暖，话语连续，语速平和，全程能感受到法师的真诚，在大学一文里说至诚如神，大抵就带这般光彩了。师兄们提出了若干问题，匀得到了法师细致的回答，现在凭着印象，简要记录如下： 问1：怎么样化解自己的嗔心？答：提高自己的慈悲心，用慈悲心化解。具体步骤1.找到嗔心的根源，2.使用拆分，分析根源。 问2：性格缺陷（如何排除执念）？答：拿出笔和纸，在纸上记录，如果这个场景下，你做了这个事有什么坏处，如果不做有什么好处，并记录下你要怎么不做它。然后下次真遇到了，你会意识自己正面临着，就会让自己平静下来。另一方面，产生了一个念头，就让它过去，不要再追它。 问3：晚上跑步，一脚踩死爬虫，怎么办？要当场念诵往生咒么？答：如果不是故意的，就不是什么大罪。可以早起诵读出行咒。 问4：追我的男生我不喜欢，我喜欢的男生，我又怕对方不理我，怎么办？答：求不得是人生八苦之一，不是选择钱最多或者最帅的，而是选择能让自己身、心、灵进步的人作伴侣 问5：为什么修行的法师们能一晚上只睡2，3个小时？答：山上修行生活，不像山下，不用花费很多精力。花费精力更多的是心劳累。 问6：如何找到自己的天赋所在？或者说自己性格的特质？答：寻找反馈，往往周围的人比你自己更了解你 问7：和我们凡人拜佛相比，法师你们和佛是什么样的关系呢？答：我就像佛，有时候诵读静坐观想，面前的菩萨进入我的心轮出，她的慈悲遍布我的身体里。 问8:出家能放下所有烦恼么？答：真不能，就我而言出家能放下的仅仅是初猛的烦恼，细微的烦恼还有。法师的讲解，充满智慧。这和我从前在德行高深的作者上获知的内容异常的相似，对法师心生敬佩。有师兄说过，科学之上是哲学，哲学之上是神学，我想这是对的。 一些有趣的名词解释师兄： 在寺里称呼周围的人叫师兄 海青：指早晚课穿的衣服，汉服风格 大寮：寺庙食堂里的厨房 出坡：指山上劳动 过堂：指在斋堂吃饭，分为一堂，二堂，三堂。一堂指第一批吃饭，二堂指第二批吃饭，三堂指第三批吃饭 行堂：指在斋堂从一端走到另一端帮人打饭打菜的行为 排班：指排队，寺里活动先排班，然后有序的进场、出场 皈依：身心归向和依靠佛、法、僧 居士：指没有出家的信教人士 问讯：礼敬请安的方法，一般动作为双手合掌，弯腰作揖，常用于佛教徒向师父长辈请安时的一种礼节 法门：指修行者入道的门径，佛家共计八万四千法门 小结感恩法师，感恩师兄。一直以来特别喜欢一首偈语，就作为本文的结尾吧。希望有因缘和合，寻觅到这如来的真实本意。 无上甚深微妙法，百千万劫难遭遇。我今见闻得受持，原解如来真实意。 相关资料 龙泉之声传统文化网 论坛首页 - 龙泉论坛 - Powered by Discuz!]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再读编程的智慧一文有感]]></title>
    <url>%2F2018%2F05%2F04%2F2018%2F2018-05-04%2F</url>
    <content type="text"><![CDATA[记得是2015年还是2016年读过王垠的这篇文章–编程的智慧，收益良多。一些当时让我影响深刻的点，自那以后就一直用于生产了。 今天重温此文，感触最深的有以下三个点： 循环时避免使用continue和break，并提供了如何去掉的方法 如何正确的处理Java里的异常和错误 如何正确的处理Java里的空指针 本文是编程的智慧一文的内容概要。当然最好的方式，是花上2到3小时认真阅读王垠的原文，相信你会有很多感触和收获。 正文内容推敲代码反复推敲代码，仔细领悟，积累灵感和智慧，为了在遇到新问题的时候直接朝正确，或者接近正确的方向前进。 优雅代码的形状特征看起来像整整齐齐，套在一起的盒子。抽屉里分门别类，再放几个小盒子。逻辑上是枝丫分明的树状结构。程序所做的几乎一切事情，都是信息的传递和分支。 模块化代码模块化不是简单的把代码切割开来，分放在不同的位置。指的是逻辑上模块化。 需要做到以下几点： 一个函数不超过40行 制造小的工具函数。函数内联，内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数，对于小内存空间的函数非常受益 每个函数只做一件简单的事 避免使用全局变量和类成员来传递信息 可读的代码 使用有意义的函数和变量 局部变量应该尽量接近使用它的地方，加强读者对于这里的“计算顺序”的理解，局部变量的本质——它们就是电路里的导线 局部变量名字应该简短 不要重用局部变量，否则会把局部变量的作用域不必要的增大。 把复杂逻辑提取出来，做成帮助函数， 把复杂的表达式提取出来，做成中间变量 合理的地方换行 简单的代码程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。 并不是语言提供什么，你就一定要把它用上的。**实际上你只需要其中很小的一部分功能，就能写出优秀的代码。 避免使用自增减表达式（i++，++i，i–，–i）用在复杂的表达式里面永远不要省略花括号合理使用括号，不要盲目依赖操作符优先级，能降低视觉疲劳。避免使用continue和break。这点更新了我的认知。它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。 如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。 如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。 有时候你可以把break替换成return，从而去掉break。 如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。 写直观的代码如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它 写无懈可击的代码处理所有可能出现的情况，避免漏掉corner case。if语句就要把else情况都写上。 正确处理异常Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。 catch异常的时候，你不应该使用Exception这么宽泛的类型或者。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B） 在自己函数的类型加上throws Exception，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着throws Exception，这毛病就传得更远 try { … } catch里面，应该包含尽量少的代码，一个try里包含做一件事的逻辑代码 正确处理null指针尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制 不要catch NullPointerException，而应该是在角色函数里处理过滤空指针 不要把null放进“容器数据结构”里面 其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责，采用强硬态度一个很简单的做法是使用Objects.requireNonNull() 使用@NotNull和@Nullable标记，它们的作用是：IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现NullPointerException的地方。在运行时，会在null指针不该出现的地方产生IllegalArgumentException 使用Optional类型，设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。 附带：Java里closure的自由变量是只读的。所以内部类里的函数可以读外部的局部变量，但是不能对其写操作。 过度工程的征兆 就是当你过度的思考“将来” 过度的关心“代码重用” 过度地关心“测试” 小结如果对上面的概述若有所思，有更多详细的细节在原文里-编程的智慧]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国佛教发展史简述]]></title>
    <url>%2F2018%2F05%2F03%2F2018%2F2018-05-03%2F</url>
    <content type="text"><![CDATA[这个标题很宏大，很学术。因着周末心旅的契机，我大胆尝试，通过网络的资料搜索、摘录归纳出中国佛教的发展历史和源流。中国佛教的历史粗略可分为古印度佛教传入中国前，和传入中国后这两大阶段。 佛教按照语言分为三大系，即汉语系、藏语系、巴利语系。中国佛教按古印度传入途径的位置分为北传佛教，南传佛教。北传佛教细分为藏传佛教，汉传佛教。 传入中国前传入中国前印度佛教的发展，我选择从集结过程来切入。对于释迦牟尼佛去世时间主流有这几种说法： 等南传佛教国家，一般认为释伽牟尼佛卒于公元前544年 中国近代学者依南齐僧伽跋陀罗“众圣点记”里，推测释加牟尼佛灭于公元前486年。 第一次结集释迦牟尼本人，原是迦毗罗卫国的一位王子。在他寂灭之后的第一年，便由他的上首弟子摩诃迦叶主持，召集了五百长老诵集了佛陀生前所说的教法，集会把当时诵出的教法分为毗奈耶（戒律）和达摩（法）两大类（律藏和经藏）。使其用口授的方式代代保存下去。从释迦牟尼佛到其去世一百年期间，称为‘原始佛教’时期 第二次结集释迦牟尼佛去世约一百年后，因为对于戒律的见解有分歧，僧团内部发生了分裂，东部大多数的僧人不同意当时东、西部长老们的决议，另外订正戒律，退出原来教团的主体，自成一派，因为他们人数多，就叫做‘大众部’，原来的僧人就叫‘上座部’，到二百多年这期间，被叫做‘部派佛教’ 第三次结集释迦牟尼佛去世二百多年后，阿育王统治时期由于国王虔诚信仰佛教，因此便有许多非佛教徒，那些行为纯洁而真正信奉佛教的比丘，不愿与这些行为不正的人为伍。阿育王并召集一千位长老，举行第三次结集，会诵出比较完整的经律论主要成分，其中有上座部巴利语三藏。 此大会有一个决议，派遣传教师到世界各国去传播佛教。经古印度向北往传入中国，再由中国传入朝鲜、日本、越南等地的佛教变成了北传佛教，北传佛教包括藏传佛教和汉传佛教。由印度南传到斯里兰卡而后发展起来的便成了南传佛教（又称上座部佛教）。盛行于东南亚的越南、泰国、缅甸、老挝、柬埔寨及我国云南省傣族地区等 第四次结集公元前29年，国内有时也发生内乱，只依赖某些人用不可靠的生命对记诵的方法来保存经典，是一件冒险的事。在斯里兰卡中部举行四次结集，诵出上座部的三藏和义疏，并决定把一向口口相传的三藏经典第一次用巴利文字写在贝叶上保存。从此以后才开始有了书写在册的佛经。 还有第五次和第六次结集，但是和中国佛教发展关联不大了，就此略过。 传入中国之后汉语系和藏语系中的大乘理论为大乘，称巴利语系的佛教及其他类似的佛教为小乘。 汉传佛教由西域传入佛教，东汉末年陆续译出佛教典籍，佛教教义开始与中国传统思想文化相结合，至隋唐而臻于鼎盛，形成天台、华严、法相、律、净土、禅等宗派。宋代以后又渐与儒道融合。汉译佛典的数量极大，其后经历三国、两晋以至唐、宋各时代，均有译本推出。 佛教在中国传播中经历了漫长的民族化过程。佛经原是用梵文或葱岭以东的“胡”文写的，有一系列专门术语和概念。中国在佛教传入前已拥有高度发达的儒、道传统文化。站在传统文化的基础上来看待和理解佛教，借用为中国人熟悉的概念、用语来翻译佛经，解释佛经。各代的译经僧在佛教界有很大影响力，都把当时印度最新的学说传译到中国。译经时必须从汉文中选择与原文意思相当的词概念，用汉文文法进行表述。译者中的很多人和他们的助手都通晓中国传统文化，善于文墨。他们在译经时自然而然地把他们对经文的理解，把带有民族和时代特色的汉文汉语掺杂到佛经中去。 汉传佛教教宗的缘由佛经中说：“佛一圆音演说法，众生随类各得解”。 谈到佛教的各宗各派，追溯佛陀最初创教之时，为了适应众生的根器而说了种种的法门并未曾提到宗派的分别。到了后代，由于社会环境以及历代大德依个人研究兴趣的不同，而对佛陀的教化作各种不同偏重性的探讨，加上个人的修持体验，而对经典产生种种的诠释，以自己所阐扬的最为代表佛陀的教义，衍变所及，乃渐渐形成各种的宗派。 起初没有区分大小乘经典，立宗立派也没有区别，最初有十三宗之说，流传迄今者，实唯十宗，后来俱舍宗、成实宗列属小乘经典没落了。最后剩下有影响的、现今仍流行的实属八大宗派： 三论宗 天台宗 华严宗 唯识宗 律宗 禅宗 净土宗 密宗 八大宗派的特点可以用一偈浅而概之： 密富禅贫方便净，唯识耐烦嘉祥空。 传统华严修身律，义理组织天台宗。 自晚唐以下的中国佛教，禅宗特盛，而后禅净合一。 禅宗传说创始人为菩提达摩，下传慧可、僧璨、道信，至五祖弘忍下分为南宗惠能，北宗神秀，时称“南能北秀”。惠能指出佛性人人皆有，创顿悟成佛之学，一方面使繁琐的佛教简易化，一方面也使从印度传入的佛教中国化。因此，他被视为禅宗的真正传承人。 北宗神秀一派主张渐修，盛极一时，但不久便衰歇，有偈语如下： 身是菩提树，心如明镜台 时时勤拂拭，勿使惹尘埃 南宗惠能主张顿悟，有偈语如下 菩提本无树，明镜亦非台 本来无一物，何处惹尘埃 后世尊为六祖，弘传甚盛。从唐到宋，南宗的禅师辈出，在此三、四百年中又分为五家七派，后来的禅宗只有临济、曹洞两派流传不绝，临济宗更是兴旺。近代所有的禅宗子孙，都是临济、曹洞两家后代。此宗和净土宗一样，一直是中国流传最广的宗派。 净土宗五代至宋，净土宗一直盛行，净土法门深受民间百姓欢迎，教、禅、律、净诸宗继续呈现融合兼修。宋代开始的禅净合流，带动了天台、华严、法相和律宗同归净土。明清以后，净土宗更是一枝独秀，成为中国民众宗教信仰的中心。 净土信仰，大致曾分为弥勒净土和弥陀净土两种。弥勒净土信仰由道安首倡，一时盛行于北魏，梁齐间还有所闻，不久即衰。弥陀净土信仰在中国的流行始于东晋慧远大师。 中国净宗十三祖分别是：慧远、善导、承远、法照、少康、延寿、省常、祩宏、智旭、行策、实贤、际醒及印光大师慧远大师、善导大师以后，净土宗继续流传，历代名师辈出。 净土宗十三祖：苏州灵岩量公大师(1861年-1941年)，即印光大师，别号常惭愧僧。 藏传佛教又称藏语系佛教，或俗称喇嘛教，是指传入中国西藏的佛教分支，归属于大乘佛教之中，但以密宗传承为其主要特色。藏传佛教的起源可以追溯到一千八百多年前的古象雄王朝。 从公元七世纪印度佛教传入吐蕃以后，印度佛教与本波佛教之间各自互相吸收了许多对方的内容而各自得到了发展，因为印度佛教与本波佛教在信仰的本源上是完全一致的。印度佛教大量吸收了本波佛教的内容，使其能够更深入地根植于当时的社会并逐渐发展成为了现代的“藏传佛教”。 藏传教派有： 宁玛派 噶举派 萨迦派 噶当派 格鲁派 其派别差异是因不同师承、不同修持教授、所据不同经典和对经典的不同理解等佛教内部因素和不同地域、不同施主等教外因素而形成众多派别。 “仁波切”，是藏文（rin—po—che）的音译，意指”珍宝”或”宝贝”。这是广大藏族信教群众对活佛敬赠的最亲切、最为推崇的一种尊称。 藏传佛教的理论可以这样概括：藏传佛教认为人想成佛是没有其他简单途径的，唯一正确的方法就是照释迦牟尼佛的方法去做，也就是释迦牟尼佛怎么做就应怎么做，因此藏传佛教提出”身口意”的修炼方法。 所谓”身口意”的修炼方法是指，如果你在身体上，言语上和思想上都能做到和释迦牟尼佛一样了，那么你就一定能够成佛，这就是藏传佛教思想的核心。 藏传佛教中的密宗和显宗在一致坚持”身口意”修行方式的前提下,有一个主要的差别。这个差别在于如何达到”身口意”与佛相同的途径上。显宗认为只要按照那些公诸于世的佛经去做就可以了，所以显宗主张公开宣道弘法。显宗被称为显宗也是因为他们的这个观点。而密宗认为要想达到到”身口意”除了公开的佛教以外，还有一套秘密的方法，没有人传授密法修行很难达到”身口意”。所以密宗强调传承、真言、密咒和灌顶。这就是密宗和显宗的区别。 南传佛教它是原始佛教时期之后，部派佛教中的一个派系。现在盛行于东南亚的越南、泰国、缅甸、老挝、柬埔寨及我国云南省傣族地区等。 在现代物质文明高度发达的今天，仍然过着挨家挨户托钵乞食、不非时食，半月诵戒、雨季安居、行自恣法。南传上座部佛教严格依照戒定慧的路线开展禅修。 小结本文尝试了从佛教起源开始，追溯源头，自上游一路向下，展开中国佛教的发展历程，对佛教发展经过有了一次全面的了解。 参考资料 百度百科：藏传佛教 百度百科：北传佛教 百度百科：南传佛教 百度百科：中国佛教八大宗派 百度百科：净土宗]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客马拉松之外的杂感]]></title>
    <url>%2F2018%2F04%2F23%2F2018%2F2018-04-23%2F</url>
    <content type="text"><![CDATA[文思泉涌时顺势下笔，如果只停留在思绪上，几天后这种感觉就会变得像清晨的雾气，慢慢淡出。趁着周末参加黑客马拉松的契机，释放此刻的泉涌。 周六早上9点半开始coding，到第二天中午12点半结束，我和我的小伙伴完成了一款简易的安卓下的AR应用：扫一扫菜肴，弹出食材活物，大体效果如下图： 开发一款安卓AR，需要用到谷歌去年年底开源的ARCore类库之外，还要求开发人员有深入的OpenGL ES的知识。我们产品完成度不够，最终没有入围第二轮。 比赛项目内容两周前其实就已经定下来了，很不巧的是，这两周工作之外还给自己安排了若干件事情。计划的一场Kotlin分享，地图SDK调研，还赶上了工作上提交测试，开发任务量增加，原本可以用于学习OpenGL ES学习的时间被分到了上述事情上。如果这期间不留神给了自己娱乐消遣的时间，节奏就更紧张了。想要把每件事都做好，结果每件事都没做好。想做更多更好，把一件件事情都捡起来放到自己兜里，结果发现捡到都是芝麻，而不是西瓜。成百上千的芝麻都不如一个西瓜来得大。 抬头看看外面的程序世界。安姐（朱赟）写了一本技术管理的书–跃迁，安姐在2016年开了公众号嘀嗒嘀嗒，写了好多笔触细腻，文笔亲切的文章，她有多个光环：计算机博士，Airbnb技术经理。今年又在极客时间开了专栏，而且是两个娃的妈妈。另一位大神陈天老师忙着研究区块链技术，就在半个月前从tubi tv辞职，全身心投入到了区块链技术。 吴军老师在见识里第二章说，人生要做减法。在安姐和陈老师身上似乎并不奏效。其实这不矛盾，生活中我们被超出我们意料的许多琐碎分神，无意识地抢走了我们的精力却不被我们察觉。生活做减法，做成一件事捡到一个西瓜，然后再去做捡下一个西瓜，并让这个过程持续的发生。 最后，想再聊聊安姐的这本书，全书分为五个部分 技术管理 技术实践 硅谷文化 个人成长 杂谈 跃迁，由书名便可窥知一二，跃迁也是物理世界粒子的一种运动状态—从能量较底的初态跃迁到能量较高的激发态。错过了这次的签售会，希望下次有机会见到安姐本人。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Hackthon</tag>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各家地图JavaScript版SDK调研]]></title>
    <url>%2F2018%2F04%2F13%2F2018%2F2018-04-13%2F</url>
    <content type="text"><![CDATA[现在主流的地图有三家：百度地图，高德地图，腾讯地图，尝试分析下这三家地图的异同。 JavaScript API百度地图支持PC端和移动端基于浏览器的地图应用开发，且支持HTML5特性的地图开发 支持的功能列表定位 优先调用浏览器H5定位接口，如果失败会调用IP定位 根据用户IP 返回城市级别的定位结果 当您的APP中有内置的Web页面，同时在Web页面需要提供您的当前位置信息时，可调用集成在App中的百度地图定位SDK来获取更精准的位置信息 覆盖物 添加标注／自定义标注 叠加图层／自定义图层 POI检索 地址解析 出行线路规划 街景图 个性化地图 提供开源库或组件 鹰眼轨迹服务追踪您所管理的车辆/人员等运动物体。基于鹰眼提供的接口和云端服务，开发者可以迅速构建一套完全属于您自己的完整、精准且高性能的轨迹管理系统，可应用于车队管理、人员管理等领域 版本说明最新版本：v3.0, 更新于 2017-12-27 腾讯在网站或移动端中构建功能丰富、交互性强的地图应用程序 附加库支持的功能有差异 腾讯JavaScript支持自定义地图，使用自己的数据或图片，取图、切图规 具体每个可实现的功能点查看实例说明，手册方便 版本说明最新版本v2.4.43，更新于2017-05-23 高德 支持3D地图 室内地图 云图 行政区划分 提供了现成的UI组件库，比如海亮点展示，城市选择器，POI选点 版本说明最新版本v1.4.5, 更新于2018-03-12 商业收费情况关于调用配额百度地图，配额超限了怎么办？回答看这里~ 高德传送门 Javascript API，对地点检索，地理编码，IP定位，天气查询，线路规划做请求次数限制。 未认证的开发者，默认配额比较低，通过申请个人开发者认证，企业开发者。如果还不够用，可以发起配额申请。 比如百度web地图，地址解析服务，对未认证的开发者只有2000次/天，个人开发者认证100万次/天，企业开发者认证：300万次/天。 比如高德地图Web驾车路径规划，未认证个人开发者2千次／天，认证开发者3万次／天，企业开发者30万次／天 腾讯调用配额对每个Key的每个服务接口的调用量做了如下限制： 日调用量：10,000次/接口/Key 并发限制：5次/秒/接口/Key 需要大配额来满足应用需求的，请在控制台-&gt;配额申请中申请你需要的配额 百度地图授权说明商业使用授权说明 未获得商用授权可以继续使用百度地图开放平台产品及服务，开放平台将保留相关法律追究权利及责任，但不会随意阻止或干扰开发者的使用 授权生效期起有效期为2年 商用授权是收费的，合作咨询申请链接 是否有商业版与大众版之分？百度地图API收费服务可提供更高的服务权限和技术支持 高德地图收费说明分为自定义地图和技术支持两种服务，每种服务分为免费版，专业版，旗舰版 免费版：入门级自定义地图适用于普通应用与2D游戏，可修改42种地图元素，可在Web/Android/iOS三端调用自定义地图样式 专业版（399/月）：专业版自定义地图适用于普通应用，2D游戏，3D游戏，在入门版的基础上增加移动端SDK配置地图纹理与在线调用自定义地图样式的功能，并享有平台高级功能使用权限 旗舰版（价格联系商谈）：自定义地图旗舰版涵盖普通版与专业版的所有权限，同时享有在移动端SDK中绘制3D模型与自定义建筑模型的功能，并享有开发支持的特权 服务协议 签署在线服务协议，以获得免费使用 商业授权 5万／年 腾讯地图收费说明免费向第三方提供，任何非盈利性网站均可使用传送门 无收费版本，不需要商业授权。 小结Web端地图从功能特性上，高德地图最强大，提供了最多的特性；其次是百度地图，最后是腾讯地图。 收费情况上看：腾讯地图完全免费，而百度地图和高德地图都需要授权才能用于非公共服务的，商业环境下使用。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Map</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速查看Gradle项目类库依赖情况]]></title>
    <url>%2F2018%2F04%2F11%2F2018%2F2018-04-11%2F</url>
    <content type="text"><![CDATA[正文Gradle项目中，导入依赖包和并对其管理是开发人员绕不开的事情，在导入的过程中，一不小心就会遇到新导入的依赖库和原有的类库冲突的问题，我在之前的一篇文章遇到异常Multiple dex files define时里提供了解决方法。本文对如何定位依赖冲突这个环节提供更多的方法 方式1./gradlew 模块名：dependencies 这个命令会打印出该模块下的所有第三方类库的依赖情况，有多种展示情况，complie编译时的，Runtime运行时（打到APK包时）的，debug下，release下。 如下展示的是debugCompileClasspath即debug编译时的引包情况： 1234567891011121314151617181920212223242526272829303132333435debugCompileClasspath - Resolved configuration for compilation for variant: debug+--- org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.31| \--- org.jetbrains.kotlin:kotlin-stdlib:1.2.31| \--- org.jetbrains:annotations:13.0+--- com.android.support:appcompat-v7:27.1.1| +--- com.android.support:support-annotations:27.1.1| +--- com.android.support:support-core-utils:27.1.1| | +--- com.android.support:support-annotations:27.1.1| | \--- com.android.support:support-compat:27.1.1| | +--- com.android.support:support-annotations:27.1.1| | \--- android.arch.lifecycle:runtime:1.1.0| | +--- android.arch.lifecycle:common:1.1.0| | \--- android.arch.core:common:1.1.0| +--- com.android.support:support-fragment:27.1.1| | +--- com.android.support:support-compat:27.1.1 (*)| | +--- com.android.support:support-core-ui:27.1.1| | | +--- com.android.support:support-annotations:27.1.1| | | +--- com.android.support:support-compat:27.1.1 (*)| | | \--- com.android.support:support-core-utils:27.1.1 (*)| | +--- com.android.support:support-core-utils:27.1.1 (*)| | +--- com.android.support:support-annotations:27.1.1| | +--- android.arch.lifecycle:livedata-core:1.1.0| | | +--- android.arch.lifecycle:common:1.1.0| | | +--- android.arch.core:common:1.1.0| | | \--- android.arch.core:runtime:1.1.0| | | \--- android.arch.core:common:1.1.0| | \--- android.arch.lifecycle:viewmodel:1.1.0| +--- com.android.support:support-vector-drawable:27.1.1| | +--- com.android.support:support-annotations:27.1.1| | \--- com.android.support:support-compat:27.1.1 (*)| \--- com.android.support:animated-vector-drawable:27.1.1| +--- com.android.support:support-vector-drawable:27.1.1 (*)| \--- com.android.support:support-core-ui:27.1.1 (*)\--- com.android.support.constraint:constraint-layout:1.0.2 \--- com.android.support.constraint:constraint-layout-solver:1.0.2 分层展示，不仅展示了该模块下每个类库的名称、版本号，还展示了各类库里所需依赖的类库。 方式2如果你嫌命令行麻烦，还有鼠标操作的方式 鼠标双击即可运行 其实方式一的命令行执行的就是截图里dependencies任务。 Gradle项目构建的过程就是依次执行完所有任务的过程。 方式3如果你嫌在命令行窗口展示观看不友好，这里还有一种体验更好的方式。 输入下面命令行： ./gradlew build --scan 出现如下： Publishing a build scan to scans.gradle.com requires accepting the Terms of Service defined at https://scans.gradle.com/terms-of-service. Do you accept these terms? [yes, no] 输入yes同意，将会出现一个网页地址，登录该网址。 该网页还提供冲突提示，列出了引用了此类库的类库，效果如下 小结方式1和方式2实际上是同一种方法，方式3借助了Gradle官网为我们提供了视觉上更友好的查看包依赖。当编译出现包依赖冲突的问题时，使用这种方式能极大的提高我们快速定位问题来源的效率。 参考资料 Get started with build scans]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇到异常Multiple dex files define时]]></title>
    <url>%2F2018%2F04%2F10%2F2018%2F2018-04-10%2F</url>
    <content type="text"><![CDATA[正文这段时间有一个新需求，安卓App通过URL在线预览PDF。选择使用并倒入PdfViewPager库时，报了如下异常： 12345jdmerchants:transformDexArchiveWithExternalLibsDexMergerForTestServerDebugcom.android.builder.dexing.DexArchiveMergerException: Unable to merge dexMultiple dex files define Luk/co/senab/photoview/log/Logger 出现Multiple, dex字样，直接想到的可能就是重复倒入依赖了，那么问题来了： 为什么我导入PdfViewPager类库的时候会产生重复依赖问题？PdfViewPager类库里和我现有的依赖类库什么文件重复？如何确定是哪某个类库里的文件和PdfViewPager类库产生重复的依赖了？ 定位问题缘由我用的是Mac下的Android Studio 3.1开发 首先需要找到一个工具或者方法，能了解到当前项目中所有类库内部的依赖情况。这里提供一种方法，输入下面命令 ./gradlew -q 模块名：dependencies 在命令行窗口就能列出当前模块的所有依赖情况。我选取了和这次问题有关内容的，展示如下： \--- es.voghdev.pdfviewpager:library:1.0.3 +--- com.android.support:appcompat-v7:25.4.0 (*) \--- com.commit451:PhotoView:1.2.4 \--- com.android.support:support-v4:23.0.1 -&gt; 25.4.0 (*) \--- com.github.chrisbanes.photoview:library:1.2.4 \--- com.android.support:support-v4:22.0.0 -&gt; 25.4.0 (*) 会发现，新引入的pdfviewpager类库用到了com.commit451:PhotoView:1.2.4；这和com.github.chrisbanes.photoview:library:1.2.4类库重复了 解决问题问题我们找到了：pdfviewpager类库依赖了chrisbanes.photoview类库，造成chrisbanes.photoview类库重复使用，因此只要在引入pdfviewpager的时候，排除掉com.commit451:PhotoView:1.2.4就可以了 那么如何排除呢？Gradle构建项目肯定想到了这种情况下的处理–引入第三方类库时排除掉里面的某个依赖库： compile (&apos;es.voghdev.pdfviewpager:library:1.0.3&apos;){ exclude group: &apos;com.commit451&apos;, module:&apos;PhotoView&apos; } 小结遇到了之前未曾遇到的问题，这个问题所需的知识点又是之前未曾储备的盲区，这时候google搜索找到相似的问题的答案要能作类比和知识延伸，慢慢思考，有效思考，得出一点新的结论，然后继续思考，就能越来越接近解决问题的成功路径了 参考资料 Gradle依赖排除 有关 Android Studio 重复引入包的问题和解决方案 跟我学Gradle-5.3:依赖-管理依赖的版本]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第二讲-初出茅庐]]></title>
    <url>%2F2018%2F04%2F05%2F2018%2F2018-04-05%2F</url>
    <content type="text"><![CDATA[年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？val = 加了final的变量 val message = &quot;Kotlin&quot; // final String message = &quot;Kotlin&quot;; var count = 0 val msg: String = &quot;Kotlin&quot; //value var count2: Int = 0 // variant val p = Person(&quot;Kotlin&quot;) p.name /* Q1 var与val什么区别？ val = 加了final变量 */ val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;) languageList.add(&quot;Go&quot;) 字符串模板类比Java Web JSP里的EL表达式 println(&quot;message = &quot; + message) println(&quot;message = $message&quot;) println(&quot;count = ${count}&quot;) println(&quot;language list size = ${languageList.size}&quot;) println(&quot;\$: ${count2}&quot;) 函数fun max(a: Int, b: Int): Int { if (a &gt; b) { return a } return b } fun max2(a: Int, b: Int) = if (a &gt; b) a else b 问题：表达式和语句有什么区别？ 表达式有返回值，语句没有。表达式可以包含在语句或表达式里。语句与语句之间是并列的 Kotlin常见的表达式有：if，when，try{}catch 关于Whenfun filter(a: Int) { when (a) { 0 -&gt; println(&quot;0&quot;) 1 -&gt; println(&quot;1&quot;) in 2..10 -&gt; println(&quot;in 2..10&quot;) !in 11..20 -&gt; println(&quot;! in 11..20&quot;) Integer.parseInt(&quot;21&quot;) -&gt; println(&quot;21&quot;) 22, 23 -&gt; println(&quot;22 , 23&quot;) else -&gt; println(&quot;else&quot;) } } fun filter2(x: Any) { when (x) { is Int -&gt; println(&quot;Int&quot;) is String -&gt; println(&quot;String&quot;) is Person -&gt; print(&quot;JavaPerson&quot;) } } fun filter3(x: Any) = when (x) { is Int -&gt; { val a = 3 &quot;Int&quot; } is String -&gt; { val b = &quot;&quot; &quot;String&quot; } else -&gt; { &quot;else&quot; } } fun filter4(x: Any) = when { x is Int -&gt; &quot;Int&quot; x is String -&gt; &quot;String&quot; else -&gt; &quot;else&quot; } } 关于Kotlin里的循环和迭代for (i in 0..5) { println(&quot;i : $i&quot;) } for(j in 0 until 5){ println(&quot;j : $j&quot;) } for(k in 5 downTo 0){ println(&quot;k : $k&quot;) } val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;, &quot;Go&quot;) for((index, value) in languageList.withIndex()){ println(&quot;index = $index, value = $value&quot;) } val languageMap = hashMapOf&lt;String, String&gt;(&quot;j&quot; to &quot;Java&quot;, &quot;k&quot; to &quot;Kotlin&quot;, &quot;g&quot; to &quot;Go&quot;) for((key, v) in languageMap){ println(&quot;$key : map value = $v&quot;) } 异常处理背景知识： Java异常继承自Throwable，分为两种 运行时异常RuntimeException，也叫非受检异常 受检异常 CheckedException Java处理异常有两种方式： try catch 捕获异常 throws抛出异常 先看下Java的例子 //非受检异常 private static void testRuntimeException() { int i = Integer.parseInt(&quot;!&quot;); } //受检异常 private void testCheckedException() { try { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } catch (FileNotFoundException e) { e.printStackTrace(); } } private void testCheckedException2() throws FileNotFoundException { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } 从上面程序可知：Java强制要求开发人员处理受检异常. 常见的受检异常： Exception, FileNotFoundException, IOException, SQLException 常见的未检查异常： NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException 上述Kotlin下的代码如下： fun testRuntimeException(){ val i = Integer.parseInt(&quot;!&quot;) } fun testCheckedException(){ val fis = FileInputStream(&quot;/temp&quot;) throw IllegalArgumentException(&quot;&quot;) } 可知：与Java不同，对受检异常，Kotlin不强制开发人员处理。 小结对于异常，Kotlin与Java的不同之处如下： Kotlin不区分受检异常和非受检异常, 都不强制处理异常 Kotlin不存在throws，不允许抛出异常 当try{}catch{}作为表达式的使用时fun readNumber(){ val a = try { val c = &quot;&quot; Integer.parseInt(&quot;!&quot;) }catch (e: Exception){ e.printStackTrace() 0 } println(&quot;a = $a&quot;) } 关于枚举1234567891011121314enum class Season&#123; SPRING, SUMMER, AUTUMN, WINTER&#125;enum class Color(val r: Int, val g: Int, val b: Int)&#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0,0,255); fun rgb() = r * 255 * 255 + g * 255 + b&#125; 关于类和属性我们看下Java的 123456789101112131415161718192021222324252627public class Rectangle &#123; private final int width; private final int height; private final boolean isSquare; public Rectangle(int width, int height, boolean isSquare) &#123; this.width = width; this.height = height; this.isSquare = isSquare; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public boolean isSquare() &#123; return isSquare; &#125;&#125;``` 等效Kotlin实现 class Rectangle(val width: Int, val height: Int){ val isSquare get() = width == height}` Java中，成员变量就是一个字段，访问成员变量通过setter或者getter方法，相当于变量的访问器。Kotlin把这个概念作为语言层面的支持了。kotlin中每个属性，如果是val变量就自带访问器get(),如果是var属性则自带get()和set() 因此Kotlin中，一个属性 = 字段 + 访问器；这是Kotlin对Java语言的进化。 小结该文是对Kotlin实战一书第二章知识点代码的梳理和总结，完整代码，已上传到GitHub上，KotlinInActionExample 传送门]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启Kotlin编程之旅&Java程序员的思维进化]]></title>
    <url>%2F2018%2F03%2F29%2F2018%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[这周在部门进行了一场Kotlin分享，于是把分享内容整理出这篇文章 Kotlin编程语言简介 由Intelij IDEA生产商JetBrains开源 2011年开始，2016年初发布1.0正式版，目前最新1.2.31 基于JVM平台，JS平台和Native的编程语言 静态的，支持函数式编程范式 与Java语言极高的兼容和互操作 Kotlin的生态环境 GitHub star 2万多 Kotlin在2018 TIOBE 3月份语言排行榜38名 国外Stackoverflow 发布的2018 Developer Survey Results报告中，75.1%对Kotlin感兴趣 Spring 5.0版本将支持Kotlin Kotlin不足：编译器存在优化空间，大范围使用目前只在Android开发领域 Kotlin的语言特性&amp;Kotlin与Java的差异空指针安全引用／对象为空时调用报NullPointException异常 Java世界里Java对空指针的处理的方式有以下： if判断，过滤null，缺陷：代码冗余 做一层包装，比如Java世界里，Double，Int 装箱；Java8里Optional包装; 缺陷：代码冗余，额外的包装接口影响运行时性能，即使在代码中到处都使用了Optional，仍然需要处理JDK、Android框架，以及其他第三方库中的方法返回null值。 使用注解（@nullable，@NotNull） + 插件代码检测；缺陷：这些工具不是标准Java编译过程的一部分，很难保证她们自始至终都被应用，而且很难使用注解标记覆盖所有可能发生错误的地方 Kotlin要怎么做的？ Kotlin世界里以字符串对象为例 在Java里： 1String = String + null 在Kotlin里 12String = String String？= String + null 因此，String和String？是两种类型。Kotlin中的String？相当于Java里的String 对类型，Kotlin让我们有了新的认识： Kotlin中，所有常见类型默认都是非空的。 什么是类型？就是对数据的分类，分类的类目里有一类是null 隆重登场, Kotlin的处理程序执行顺序上出了偏差或是其他原因，对象引用没有就建立起来，就会出现空指针，空指针在逻辑上就存在了 ?.调用 把一次null检查和一次方法调用合并成一个操作。 ?: Evlis运算符：问号前面的对象是null么？如果是则返回冒号后面的值，如果不是则返回问号前的值 拓展函数 12345678910111213data class Person(val name: String, val age: Int)&#123; fun walk()&#123; println(&quot;$name is walking&quot;) &#125;&#125;val p = Person(&quot;Kotlin&quot;,6)val p2 = nullp2?.walk()val p3 = p2?:pprintln(&quot;$&#123;p3.name&#125;&quot;) 简洁、高效性 好吃的语法糖，少了Java冗余啰嗦；比如类型推断与自动强转，引入数据类data 语言层级提供了大量的非常方便的实现；比如Kotlin的标准库封装了大量对集合操作的快捷方法 命名参数，默认参数 拓展函数 高阶函数，局部函数实现闭包 kotlin提供了一些特性保证Kotlin简洁高效，比如： 拓展函数StringUtil.captitalize(s) s.captitalize 意义：一方面让代码组织的更简洁，另一方面暗合了Java6大设计原则的开闭原则。对原来的类的定义不做修改，而是通过拓展特性来完成（java实现上是通过工具类组合的方式来做的） 运算符重载set.add(2) set += 1 中缀调用1.to(&quot;one&quot;) 1 to one get方法约定 当作成员变量般调用 map.get(&quot;key&quot;) map[&quot;key&quot;] invoke约定／对（）操作符的重载有了这个约定，在Kotlin的世界里，一切对象都可以认为是函数了。比如lambda表达式，可以这样使用labmda()就是因为 Kotlin约定了，除非是内联，lambda表达式都会被编译成实现了函数式接口（Function1）的类，这些接口定义了具有对应数量参数的invoke方法 比Java8更接近的函数式/声明式范式Lambda表达式存在三个简化约定： 如果lambda表达式，参数类型为空，可以省略参数和箭头 如果lambda表达式参数类型只有一个，可以省略参数和箭头并使用it作为形参 如果lambda表达式作为函数的最后一个参数，可以把放到括号外 来一段代码实例现在有一个需求：添加前缀，分隔符，后缀，打印出某个给定的集合里的所有元素 java实现： 12345678910111213141516171819202122232425262728public class SeparatorUtils &#123; /** * * @param collections 集合 * @param prefix 前缀 * @param separator 分隔符 * @param postfix 后缀 * @param &lt;T&gt; 集合泛型 * @return 分隔后的结果 */ @NotNull public static &lt;T&gt; String separate(Collection&lt;T&gt; collections, String prefix , String separator, String postfix) &#123; Objects.requireNonNull(collections); StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(prefix); int index = 0; for (T t : collections) &#123; if(index &gt; 0)&#123; stringBuilder.append(separator); &#125; stringBuilder.append(t.toString()); index ++; &#125; stringBuilder.append(postfix); return stringBuilder.toString(); &#125;&#125; 对应Kotlin实现： 1234567891011121314151617@JvmOverloadspublic fun &lt;T&gt; separate( collection: Collection&lt;T&gt;, prefix: String = &quot;(&quot;, separator: String = &quot;,&quot;, postfix: String = &quot;)&quot;): String &#123; val stringBuilder = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; stringBuilder.append(separator) &#125; stringBuilder.append(element) &#125; stringBuilder.append(postfix) return stringBuilder.toString()&#125; 对上述代码作简化，如下 123456789101112131415161718@JvmOverloadsfun &lt;T&gt; separate3( collection: Collection&lt;T&gt;, prefix: String = &quot;(&quot;, separator: String = &quot;,&quot;, postfix: String = &quot;)&quot;): String &#123; return StringBuffer(prefix) .apply &#123; for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; append(separator) &#125; append(element) &#125; append(postfix) &#125;.toString()&#125; 使用拓展函数，减少一个入参 123456fun &lt;T&gt; Collection&lt;T&gt;.separateInto(prefix: String = &quot;(&quot;, separator: String = &quot;,&quot;, postfix: String = &quot;)&quot;): String &#123; return separate3(this, prefix, separator, postfix)&#125; Kotlin中闭包的实现一个简易的方法调用次数计数器： 12345678fun compute(): () -&gt;Int&#123; var count = 0 fun inner(): Int&#123; count ++ return count &#125; return &#123;inner()&#125;&#125; 调用 1234val message:() -&gt; Int = compute() for(i in 0..3)&#123; println(message()) &#125; 输出结果 11234 此时，compute()方法里的count像全局变量，累加记数。简易的访问流程：外部的A访问B函数，B内部的函数C访问B，同时B返回C。 闭包就是这样一种结构：函数嵌套一个访问自己变量的内部函数结构 闭包带给我们两个好处： 让某个变量保存在内存里，能起到消除不与其他方法通信的成员变量的作用 外部能访问到函数内部的变量 相关链接 2018 TIOBE 3 月排行榜 2018 Developer Survey Results Spring 5 支持Kotlin Talk is cheap, show me the code出处 Kotlin学习资源： JetBrains官网 Kotlin官方语言文档 GitHub: Kotlin Kotlin的Twitter账号 书籍：Kotlin实战 书籍：Effective Java 中文版（第2版）]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第一讲-输入参数]]></title>
    <url>%2F2018%2F03%2F22%2F2018%2F2018-03-22%2F</url>
    <content type="text"><![CDATA[本专栏的第一篇，分享下Kotlin里输入参数的特性 命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下： 1234567891011121314151617181920212223242526272829public class SeparatorUtils &#123; /** * * @param collections 集合 * @param prefix 前缀 * @param separator 分隔符 * @param postfix 后缀 * @param &lt;T&gt; 集合泛型 * @return 分隔后的结果 */ public static &lt;T&gt; String separator(Collection&lt;T&gt; collections, String prefix, String separator, String postfix) &#123; Objects.requireNonNull(collections); StringBuilder sb = new StringBuilder(); sb.append(prefix); int size = collections.size(); int index = 0; for (T t : collections) &#123; sb.append(t.toString()); if(index &lt; size - 1)&#123; sb.append(separator); &#125; index ++; &#125; sb.append(postfix); return sb.toString(); &#125;&#125; private static void testSeparator(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Java&quot;); list.add(&quot;Kotlin&quot;); list.add(&quot;Python&quot;); list.add(&quot;JavaScript&quot;); list.add(&quot;Ruby&quot;); list.add(&quot;Go&quot;); String separator = SeparatorUtils.separator(list, &quot;(&quot;, &quot;,&quot;, &quot;)&quot;); System.out.println(&quot;separator result = &quot; + separator); } 输出结果： separator result = (Java,Kotlin,Python,JavaScript,Ruby,Go) 这是一个完整的编码过程，来了一个需求，通过新增类和方法，在需要的地方，调用实现。需求被解决了，代码默默地在角落发挥着作用。 转眼三个月过去，团队里来了新人，他阅读到testSeparator方法；当读到SeparatorUtils.separator（）方法，对于传的四个参数代表什么含义，乍看之下他并不清楚，需要点进去读实现代码或者看注释说明才确切明白。那么还有没有更易于阅读的方式呢？Kotlin的命名参数能做到。 SeparatorUtils.separator方法用Kotlin重写如下： 123456789101112131415161718fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 调用joinToString方法可以这样 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val s = joinToString(list, postfix = &quot;)&quot;, separator = &quot;,&quot;, prefix = &quot;(&quot;) println(&quot;s = $s&quot;) 上述即是命名参数，在调用处使用，形式为：参数名=参数值；这样的入参带来了两个便利： 便于阅读，按顺序阅读代码就能知晓方法参数的含义 调用时入参的位置可以任意（调用的入参顺序和定义的入参的顺序允许不一致） 这样看起来真不错的 默认参数定义函数时，给入参提供默认值，在调用处，如果不传入实参，则该参数使用默认值，可用于方法重载。例如对上述Kotlin代码的joinToString方法改变入参 12345678910111213141516171819@JvmOverloadsfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 在Kotlin调用joinToString（）支持如下，最后一个我们同时使用了Kotlin的命名参数和默认参数的特性。 val list = arrayListOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;Ruby&quot;, &quot;Go&quot;) val s = joinToString(list) val s2 = joinToString(list,&quot;,&quot;) val s3 = joinToString(list,&quot;,&quot;,&quot;[&quot;) val s4 = joinToString(list,&quot;,&quot;,&quot;[&quot;,&quot;]&quot;) val s5 = joinToString(list, prefix = &quot;[&quot;, postfix = &quot;]&quot;) 上述调用体现了方法重载，默认参数可提供方法重载的效果 上面出现的@JvmOverloads注解是用来做什么的呢？ 默认参数特性，使用是有前提的：用Kotlin定义函数，并在Kotlin代码里调用该函数。因此，如果在Java文件里调用Kotlin定义的joinToString方法，默认不支持默认参数特性的，也即方法重载失效。 @JvmOverloads提供了让默认参数特性在Java环境也得到支持。原理是：kotlin代码编译成java代码时，会增加增加下面的方法，这些正是Java方法重载。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class StringUtils &#123; public static final int count = 11; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix, @NotNull String postfix) &#123; Intrinsics.checkParameterIsNotNull(collection, &quot;collection&quot;); Intrinsics.checkParameterIsNotNull(separator, &quot;separator&quot;); Intrinsics.checkParameterIsNotNull(prefix, &quot;prefix&quot;); Intrinsics.checkParameterIsNotNull(postfix, &quot;postfix&quot;); StringBuffer sb = new StringBuffer(prefix); Object element; for(Iterator var6 = CollectionsKt.withIndex((Iterable)collection).iterator(); var6.hasNext(); sb.append(element)) &#123; IndexedValue var5 = (IndexedValue)var6.next(); int index = var5.component1(); element = var5.component2(); if (index &gt; 0) &#123; sb.append(separator); &#125; &#125; sb.append(postfix); String var10000 = sb.toString(); Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;sb.toString()&quot;); return var10000; &#125; // $FF: synthetic method // $FF: bridge method @JvmOverloads @NotNull public static String joinToString$default(Collection var0, String var1, String var2, String var3, int var4, Object var5) &#123; if ((var4 &amp; 2) != 0) &#123; var1 = &quot;,&quot;; &#125; if ((var4 &amp; 4) != 0) &#123; var2 = &quot;(&quot;; &#125; if ((var4 &amp; 8) != 0) &#123; var3 = &quot;)&quot;; &#125; return joinToString(var0, var1, var2, var3); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix) &#123; return joinToString$default(collection, separator, prefix, (String)null, 8, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator) &#123; return joinToString$default(collection, separator, (String)null, (String)null, 12, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection) &#123; return joinToString$default(collection, (String)null, (String)null, (String)null, 14, (Object)null); &#125; public static final void testExtend(@NotNull Container $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, &quot;$receiver&quot;); String var1 = &quot;call the container testExtend method&quot;; System.out.println(var1); &#125;&#125; 可变参数可变参数关键词：vararg(分别取variate和arguments前三个字母) 来看一个Kotlin的Collections类里的一个方法 123456/** * Returns a new [ArrayList] with the given elements. * @sample samples.collections.Collections.Lists.arrayList */public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt; = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true)) 调用 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) arrayListOf入参数量可以任意多个 Java实现可变参数，在数据类型后面加三个点：… ，看下Java里的Arrays里的一个方法 12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 展开运算符 *把数组展开成一个一个元素。展开运算符常与可变运算符联合使用。比如这样： 12val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)val list = arrayListOf(*array) 我得到了一个ArrayList集合，集合里的元素是”a”, “b”, “c”]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Kotlin构建内部DSL]]></title>
    <url>%2F2018%2F03%2F14%2F2018%2F2018-03-14%2F</url>
    <content type="text"><![CDATA[正文通过Kotlin来构建内部DSL，所需的前置知识点有： 如果lambda表达式作为函数的最后一个参数，可以把放到括号外 lambda表达式&amp;高阶函数 带接收者的lambda表达式（对lambda表达式的拓展） 拓展函数和拓展属性 因此假设我们都了解并能熟练使用上面的知识点，那么Kotlin构建DSL也就成功了一半，我们来看一个例子： 我有一个书房，书房里有一张桌子和装有若干书籍的书柜 用dsl表达效果如下： 12345678910111213141516171819202122private fun dslTest2()&#123; createHouse().studyRoom &#123; desk &#123; width = 50 length = 100 heigth = 75 &#125; bookShelf &#123; book &#123; title = &quot;Kotlin实战&quot; page &#123; index = 40 &#125; &#125; book &#123; title = &quot;Effective Java&quot; &#125; &#125; &#125;&#125; 上述实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455open class Node public constructor(var name: String) &#123; fun &lt;T : Node&gt; init(child: T, action: T.() -&gt; Unit) &#123; child.action() &#125;&#125;class BookShelf : Node(&quot;BookShelf&quot;) &#123; fun book(action: Book.() -&gt; Unit) = init(Book(), action)&#125;class Desk : Node(&quot;Desk&quot;) &#123; var width: Int = 0 var heigth: Int = 0 var length: Int = 0 override fun toString(): String &#123; return &quot;Desk(width=$width, heigth=$heigth, length=$length)&quot; &#125;&#125;class Page : Node(&quot;Page&quot;) &#123; var index: Int = 1 override fun toString(): String &#123; return &quot;Page(index=$index)&quot; &#125;&#125;class Book : Node(&quot;Book&quot;) &#123; var title: String = &quot;&quot; var count: Int = 1 fun page(action: Page.() -&gt; Unit) = init(Page(), action) override fun toString(): String &#123; return &quot;Book(title=&apos;$title&apos;, count=$count)&quot; &#125;&#125;class StudyRoom : Node(&quot;StudyRoom&quot;) &#123; fun bookShelf(action: BookShelf.() -&gt; Unit) = init(BookShelf(), action) fun desk(action: Desk.() -&gt; Unit) = init(Desk(), action)&#125;class House : Node(&quot;House&quot;) &#123; fun studyRoom(action: StudyRoom.() -&gt; Unit) = init(StudyRoom(), action)&#125;fun createHouse(): House = House() 参考资料 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里Android开发手册读后感 下篇]]></title>
    <url>%2F2018%2F03%2F09%2F2018%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[阅读阿里安卓开发手册系列最后一篇，以下是一些让我印象深刻的点，顺带记录自己简单的思考 【强制】使用完毕的图片，应该及时回收，释放宝贵的内存。 我的思考：及时回收的含义是说，对于Bitmap对象用完后要在Activity回调方法里置空。 【推荐】应根据实际展示需要，压缩图片，而不是直接显示原图。【推荐】使用 ARGB_565 代替 ARGB_888，在不怎么降低视觉效果的前提下，减少内存占用 说明: android.graphics.Bitmap.Config 类中关于图片颜色的存储方式定义: ALPHA_8 代表 8 位 Alpha 位图; ARGB_4444 代表 16 位 ARGB 位图; ARGB_8888 代表 32 位 ARGB 位图; RGB_565 代表 8 位 RGB 位图。 位图位数越高，存储的颜色信息越多，图像也就越逼真。大多数场景使用的是 ARGB_8888 和 RGB_565，RGB_565 能够在保证图片质量的情况下大大减少内存的开销，是解决 oom 的一种方法。 但是一定要注意 RGB_565 是没有透明度的，如果图片本身需要保留透明度，那么就不能使用 RGB_565。 我的思考：压缩图片有两种方式：1.采样压缩 2.质量压缩 采样压缩模版代码： fun sampleBitmapFromResource(res: Resources, resId: Int, reqWidth: Int, reqHeight: Int): Bitmap { val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeResource(res, resId, options) options.inJustDecodeBounds = false options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight) return BitmapFactory.decodeResource(res, resId, options) } fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int { var outWidth = options.outWidth var outHeight = options.outHeight var sampleSize = 1 while (outWidth &gt; reqWidth || outHeight &gt; reqHeight) { outWidth = outWidth / 2 outHeight = outHeight / 2 sampleSize = sampleSize * 2 } return sampleSize } 质量压缩就是把没有透明度的位图从ARGB_8888转成RGB_565，让每个像素占用的内容从4byte降到1byte。 Drawable转BitmapKotlin代码： fun drawableToBitmap(drawable: Drawable): Bitmap { return when (drawable) { is BitmapDrawable -&gt; drawable.bitmap else -&gt; { val config = if (drawable.opacity != PixelFormat.OPAQUE) Bitmap.Config.ARGB_8888 else Bitmap.Config.RGB_565 val intrinsicWidth = drawable.intrinsicWidth val intrinsicHeight = drawable.intrinsicHeight val bitmap = Bitmap.createBitmap(Math.max(intrinsicWidth, 2), Math.max(intrinsicHeight, 2), config) val canvas = Canvas(bitmap) drawable.setBounds(0, 0, canvas.width, canvas.height) drawable.draw(canvas) return bitmap } } } 【推荐】使用inBitmap重复利用内存空间，避免重复开辟新内存 【强制】META-INF 目录中不能包含如.apk,.odex,.so 等敏感文件，该文件夹没有经过签名，容易被恶意替换 【推荐】在有强依赖 onAnimationEnd 回调的交互时，如动画播放完毕才能操作页面，onAnimationEnd 可能会因各种异常没被回调，建 议加上超时保护或通过postDelay替代onAnimationEnd]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里Android开发手册读后感 中篇]]></title>
    <url>%2F2018%2F03%2F08%2F2018%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 Executors 返回的线程池对象的弊端如下: 1)FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM 2）CachedThreadPool 和 ScheduledThreadPool : 允许 的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 我的思考：FixedThreadPool和SingleThreadPool的执行策略存在堆积大量任务；CachedThreadPool，ScheduledThreadPool则存在堆积大量线程。这两种情况都可能造成OOM异常。 详细说明看这篇英文文章：传送门 概述为： It’s unbounded, which means that you’re opening the door for anyone to cripple your JVM by simply injecting more work into the service (DoS attack) The unbounded problem is exacerbated by the fact that the Executor is fronted by a SynchronousQueue which means there’s a direct handoff between the task-giver and the thread pool 【强制】新建线程时，必须通过线程池提供(AsyncTask 或者 ThreadPoolExecutor 或者其他形式自定义的线程池)，不允许在应用中自行显式创建线程 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解 决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰 我的思考：也就是说不要使用new Thread(new Runnable(){}).start()来开启子线程任务 【推荐】ThreadPoolExecutor 设置线程存活时间(setKeepAliveTime)，确保空闲时线程能被释放 我的思考：该推荐是对上面点的细节的展开 【推荐】禁止在多进程之间用 SharedPreferences 共享数据，虽然可以 (MODE_MULTI_PROCESS)，但官方已不推荐 【推荐】谨慎使用 Android 的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题: 1) 不能实现完全退出所有 Activity 的功能 2） 首次进入新启动进程的页面时会有延时的现象(有可能黑屏、白屏几秒，是白屏还是黑屏和新 Activity 的主题有关) 3）应用内多进程时，Application实例化多次，需要考虑各个模块是否都需要在所有进程中初始化 4）多进程间通过 SharedPreferences 共享数据时不稳定 我的思考：3）问题需要获取当前进程名呢？Kotlin代码如下 fun getProcessName(): String{ val currentPid = android.os.Process.myPid() val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager val runningAppProcesses = activityManager.runningAppProcesses for(process in runningAppProcesses){ if(process.pid == currentPid){ return process.processName } } return &quot;&quot; } 【强制】应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用 FileProvider 我的思考：具体实现步骤，参考官网文档https://developer.android.com/reference/android/support/v4/content/FileProvider.html 【强制】多线程操作写入数据库时，需要使用事务，以免出现同步问题 说明： Android 的通过 SQLiteOpenHelper 获取数据库SQLiteDatabase 实例，Helper 中会 自动缓存已经打开的 SQLiteDatabase 实例，单个 App 中应使用SQLiteOpenHelper的单例模式确保数据库连接唯一。由于 SQLite 自身是数据库级锁，单个数据库操作是保证线程安全的(不能同时写入)，transaction 时一次原子操作，因此处于事务中的操作是线程安全的。 若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示数据库已被锁住。 1234567891011121314public void insertUserPhoto(SQLiteDatabase db, String userId, String content) &#123; ContentValues cv = new ContentValues(); cv.put(&quot;userId&quot;, userId); cv.put(&quot;content&quot;, content); db.beginTransaction(); try &#123; db.insert(TUserPhoto, null, cv); // 其他操作 db.setTransactionSuccessful(); &#125; catch(Exception e) &#123; // TODO &#125; finally &#123; db.endTransaction(); &#125;&#125; 我的思考：db.beginTransaction();db.setTransactionSuccessful();db.endTransaction();通过上述事务语句，就能保证线程安全了 【强制】执行 SQL 语句时，应使用 SQLiteDatabase#insert()、update()、delete()， 不要使用 SQLiteDatabase#execSQL()，以免SQL注入风险。 ####【强制】如果 ContentProvider 管理的数据存储在 SQL 数据库中，应该避免将不受 信任的外部数据直接拼接在原始 SQL 语句中，可使用一个用于将 ? 作为可替换参 数的选择子句以及一个单独的选择参数数组，会避免 SQL 注入。 我的思考：使用execSQL（），该方法参数是传入的查询语句，如果对这个语句不做过滤而是直接使用用户提交的表单内容，那么查询语句里包含着表单内容，那么用户可能在表单里写上相关的查询的数据库语句，此时就可能造成SQL注入。 【强制】png 图片使用 tinypng 或者类似工具压缩处理，减少包体积 我的思考：tinyPng是一个网站，在改网站上传一张png，能为你压缩该png。发现一个Mac的客户端支持批量操作（https://github.com/kyleduo/TinyPNG4Mac); 实践证明，效果是惊人的。我的一个drawable-xxdpi里的png图片经tinypng压缩一次后，容量从3.4M降到了1.1M。二次压缩后容量为1M。 【强制】在 Activity.onPause()或 Activity.onStop()回调中，关闭当前 activity 正在执 行的的动画。 我的思考：而不是放在Activity.onDestroy()回调中，因为destroy回调时机过晚，如果不退出或者不做销毁，动画资源便不会被释放]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里Android开发手册读后感 上篇]]></title>
    <url>%2F2018%2F03%2F05%2F2018%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[上周阿里公布了她的Android开发规范手册，读完一半就有相当多让我感受深刻的，做些简单的思考，记录如下 【推荐】使用Toast时，建议定义一个全局的 Toast 对象，这样可以避免连续显示 Toast 时不能取消上一次 Toast 消息的情况(如果你有连续弹出 Toast 的情况，避免 使用 Toast.makeText) 我的思考：使用单例而不是静态工具类 不要在 Android 的 Application 对象中缓存数据。基础组件之间的数据共享请使用Intent 等机制，也可使用 SharedPreferences 等数据持久化机制 我的思考：通过Application缓存对象会带来两个方面的问题： 大作用域增加了数据管理的成本，注意保证存储数据在前和读取数据顺序在后 App切换到后台，当内存不够时，会回收资源，当从新切回前台时，相当于重新启动App，走App初始化和Activity初始化流程，如果缓存的数据不在生命周期进行，那么这个数据就将不存在，之后用户操作读取数据时报NulllPointException崩溃 【推荐】当前 Activity 的 onPause 方法执行结束后才会执行下一个 Activity 的 onCreate 方法，所以在 onPause 方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率 我的思考：ActivityA跳到ActivityB，生命周期调用将是A的onPause，A的onSaveInstatnceState方法（一定时在onStop之前，和onPause方法没有先后关系），B的onCreate()， B的onStart(), B的onResume（）A的onStop方法能确定的是在onPause方法之后。 【推荐】对于只用于应用内的广播，优先使用LocalBroadcastManager来进行注册和发送，LocalBroadcastManager安全性更好，同时拥有更高的运行效率。 我的思考：有针对性，便能更好 【推荐】总是使用显式Intent启动或者绑定Service，且不要为服务声明IntentFilter， 保证应用的安全性。如果确实需要使用隐式调用，则可为Service提供Intent Filter并从Intent中排除相应的组件名称，但必须搭配使用Intent#setPackage()方法设置 Intent 的指定包名，这样可以充分消除目标服务的不确定性。 我的思考：隐私Intent跳转，范围是从前手机系统下所有的App里筛选，有理由推测：android系统维护了一个总的Manifest的清单文件。因此，若要使用隐式跳转，增加筛选条件IntentFilter，比如指定Package包名。 【推荐】如非必须，避免使用嵌套的 Fragment 嵌套 Fragment 是在 Android API 17 添加到 SDK 以及 Support 库中的功能，Fragment 嵌套使用会有一些坑，容易出现 bug，比较常见的问题有如下几种: 1) onActivityResult()方法的处理错乱，内嵌的 Fragment 可能收不到该方法的回调，需要由宿主 Fragment 进行转发处理 2) 突变动画效果; 3) 被继承的setRetainInstance()，导致在 Fragment 重建时多次触发不必要的逻辑。 【推荐】添加Fragment时 ，确保FragmentTransaction#commit()在Activity#onPostResume()或者 FragmentActivity#onResumeFragments()内调用。不要随意使用FragmentTransaction#commitAllowingStateLoss()来代替，任何 commitAllowingStateLoss()的使用必须经过code review，确保无负面影响 说明: https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html https://developer.android.com/reference/android/app/FragmentTransaction.html#commit() Activity 可能因为各种原因被销毁，Android 支持页面被销毁前通过 Activity#onSaveInstanceState() 保 存 自 己 的 状 态 。 但 如 果FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重 建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体验，系统会抛出IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的onPostResume() 或 onResumeFragments() ( 对 FragmentActivity ) 里 执 行 FragmentTransaction.commit()，如有必要也可在 onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss()或者直接使用 try-catch 避免 crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，本次commit丢失不会造成影响时才可这么做。 我的思考：https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html 这个链接的英文文章非常值得一读 【推荐】在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局 layout 刷新: 1) 设置固定的view大小的高宽，如倒计时组件等; 2) 调用view的layout方式修改位置，如弹幕组件等 3）通过修改canvas位置并且调用invalidate(int l, int t, int r, int b)等方式限定刷新区域 4）通过设置一个是否允许requestLayout的变量，然后重写控件的requestLayout，onSizeChanged方法，判断控件的大小没有改变的情况下，当进入requestLayout的时候，直接返回而不调用super的requestLayout方法 我的思考：手册里出现的好文章Android UI性能优化详解 【推荐】尽量不要使用 AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错。 我的思考：当项目有这样的需求：加载几十张大图的帧动画，要怎么办？ 手册提供了细致的解决方案的文章Android 帧动画OOM问题优化 【强制】不能使用 ScrollView 包裹 ListView/GridView/ExpandableListVIew;因为这 样会把 ListView 的所有 Item 都加载到内存中，要消耗巨大的内存和 cpu 去绘制图。 说明：ScrollView 中嵌套 List 或 RecyclerView 的做法官方明确禁止。除了开发过程中遇到的各种视觉和交互问题，这种做法对性能也有较大损耗ListView 等UI组件自身有垂直滚动功能也没有必要在嵌套一层 ScrollView。目前为了较好的UI体验，更贴近Material Design的设计，推荐使用 NestedScrollView 我的思考：看下NestedScrollView的体系，public class NestedScrollView extends FrameLayout implements NestedScrollingParent, NestedScrollingChild2, ScrollingView {} 由此可见，NestedScrollView相比传统的ScrollingView，多了NestedScrollingParent和NestedScrollingChild2赋予的能力]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对2017年的年度小结]]></title>
    <url>%2F2018%2F02%2F13%2F2018%2F2018-02-13%2F</url>
    <content type="text"><![CDATA[临近春节之际，我来回顾下我的2017年 The end of the year is the best time to take a look back and see the things we achieved, and also to decide what to do with the new year that comes. Here’s my summary. 2017年我做了哪些事儿工作之内2017年，接手了一个App项目，做了一些自我感觉好的技术实践。 从事件消费出发自定义了下拉刷新的控件，支持两层嵌套子控件 自定义了排序栏，下拉栏控件 尝试了水波纹淡入的布局级别转场效果（传送门） 实践了单Activity多Fragmnet的页面组织方式（打造安卓App丝滑的操作体验－－Fragment深入使用和封装之道） 在部门做了三次分享。分享主题为： 聊聊安卓里的搜索栏–实现水波纹展开搜索栏效果 传送门； Java8之Lambda表达式实战分析 2017年读过的书籍：技术相关的 Java8实战 Java8函数式编程 代码的未来 Kotlin语言文档 pdf 看了部分章节的Java编程思想，Effective Java（Java编程思想知识点过于细和繁杂，收获效率低，不适合我现在阅读） 人文思维的 异类一万小时理论出自此书 浪潮之巅吴军老师为我们抽丝剥茧的讲述了近代互联网巨头的兴衰变迁 两性关系的 完美关系的秘密 爱的艺术 男人这个东西 女人这个东西 CodeThings公众号2017年开通了个人微信公众号CodeThings，一共写了27篇文章。 技术类文章： 软件随想录 Lambda表达式实战分析（上篇） Lambda表达式实战分析 (下篇) 再谈Java反射 美剧评析： 美剧This Is Us札记01 美剧This Is Us札记02 活动类文章： 滨海图书馆半日游 谷歌上海参观之旅，有幸参观了谷歌上海办公室 Kotlin学习自从谷歌在2017年I/O大会上宣布，Kotlin成为了安卓App开发官方支持的语言，安卓圈子便兴起了Kotlin的学习高潮。年底两个多月和另外一个安卓团队（非常感谢，彼此成全），每周两次晚分享，全程过了一遍Kotlin的语法和基本使用 对2018年的安排记得去年年度小结时对下一年的安排共有五点（传送门 2017年度小结）。其中，完成了第四点以及部分完成的第2点和3点：阅读了部分章节的Java编程思想，Effective Java和算法第四版。执行完成度并不好，今年调整新年计划，如下： 1.技术进阶安排基本功 数学 英语 数据结构 Java Effective Java 设计模式 安卓 安卓自定义控件系统学习 Kotlin 2.阅读的书籍人文类 解忧杂货店 思维 见识 少有人走的路 思考 快与慢 眨眼之间 金融类 时寒冰说：未来二十年，经济大趋势 原则（by 瑞·达利欧） 3.技术分享进行若干次有效的带干货的技术分享 4.考驾校，顺利拿本希望2018年能顺利的完成上述计划，明年再续。]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再识函数式编程]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2F2018-02-12%2F</url>
    <content type="text"><![CDATA[关键词：引用透明（Referential transparency），副作用，对调用者无副作用，纯函数，柯里化（currying），编程范式paradigm，声明式编程 之前陆陆续续接触和学习了函数式编程，这是再梳理和再认识。 Java8流收集器带来的启示我们可以选择在Java的接口里定义若干函数式接口，这样这个接口所实现的逻辑便被分割成了若干函数式接口。在抽象层，关心的是封装过程中涉及的入参的类型和转化。具体的抽象数值计算交给调用方传入，比如Java JDK里的Collectors就是使用这种思路完成的对各种流做收集的工具类 副作用与引用透明函数的副作用是指：调用该函数的过程里，修改了任何全局数据结构或者任何传入的参数结构。 没有副作用的函数就是纯粹的函数，以kotlin为例 fun f(x:Int): Int{ return x + 1 } 函数f就是纯粹的函数（纯函数），没有副作用。 有一种特殊情况，尽管函数修改了全局变量，但是对于这个函数的调用者没有产生影响，也可以认为这个是函数式的。比如对于I／O的读写，这类输入输出结构是独立于运行环境之外的系统全局变量 fun p(message: String){ println(message) } p函数就是非纯函数 引用透明：调用纯函数这被称为引用透明 柯里化函数式编程里，还有一个概念叫做函数柯里化。即是把一个带多参的函数转成带部分参数的函数，它返回一个新的函数，剩余的参数传入这个新的函数。用公式表达即为：f（x,y） = (g(x))(y) 柯里化能让一大块逻辑以入参的维度划分成几个子模块，增加了灵活，逻辑粒度更细腻了，能更好的应对业务场景的变动。 函数式的解决思路如何解决数据结构修改的可见性缺陷？ 函数式的解决办法是禁止使用带有副作用的方法，由于函数式方法不允许修改任何全局数据结构或者任何传入的参数，因此如果需要使用表示计算结果的数据，则创建它的一个副本而不直接修改现存的数据结构。也即在做任何改动之前都创建一份新的数据结构，只要确保按照用户的需求传递给他正确版本的数据结构就好了。 如何保存状态？使用递归 在Java里，被final修饰的对象能保证的不会有新的引用指向该对象，但是对象本身的数据结构允许改变，这是违背函数式引用透明原则的。 模式匹配先看个Kotlin的模式匹配，不完全的pattern matching 12345when (x) &#123; in 2..20 -&gt; print(&quot;x is in the range&quot;) in Numbers -&gt; print(&quot;x is valid&quot;) else -&gt; println(&quot;none&quot;)&#125; 其实Kotlin对模式匹配支持的不够好 函数式编程的优势 天然的支持并发 一旦并发和可变状态的对象揉到一起，它们引发的复杂度要远超我们的想象。而纯函数由于输出的值只依赖于输入，所以可以放心的在多个线程调用。 代码逻辑接近自然语言的逻辑，各种DSL就是通过函数式的语言特性来组织的，这样的实现得益于引用的改动，行为的参数化 参考资料 Java8实战 现代编程语言最有趣的 10 大特性 Data class 是好东西，Kotlin 就差一个 pattern matching 了]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
        <tag>Functional Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThisIsUs美剧观后感 下]]></title>
    <url>%2F2018%2F02%2F02%2F2018%2F2018-02-02%2F</url>
    <content type="text"><![CDATA[自从设计师朋友推荐了This is us，《我们这一天》美剧后，我抽空往下看了看，这次我们来看看第二集。第二集的内容很多，我只说其中一条故事情节。 出场人物妈妈：Rebecca 瑞贝卡 爸爸：Jack 杰克 姐弟三人：Kate凯特，Kevin凯文，Randall兰德尔 场景一某天清早，妈妈在准备早餐，姐弟三人下楼吃早饭。姐姐凯特体重肥胖，想吃甜食，可是妈妈不让。爸爸走了过来，给凯特倒了麦片，这时候妈妈神情表达了不满。因为爸爸破坏了自己在孩子面前建立起来的规矩。想喝咖啡的Jack发现咖啡机里没有咖啡，他想让自己的妻子帮忙，这时候妻子时间都花在给孩子准备早餐上，忙不过来，Jack感到失落，上班之前Jack主动提醒妻子和自己吻别。有意思的是，这个早上妻子对Jack不满意，Jack对妻子没有在乎自己的需要同样不满意。 来，我们接着看下场景二 场景二Jack和好友在酒吧喝酒 Jack向好友抱怨，妻子婚后变的陌生了 为什么Jack有这种感觉呢？结合最近看了一本书–男人这个东西（by 渡边淳一），我尝试从这本书里找出一些解答，书里说道 123男人的爱情似乎没有那么顺理成章的目的性，对他们来说，恋爱就是恋爱，恋爱和结婚之间并没有必然的联系。女人对于结婚的期望或者幻想远远高过男人，认为结婚是男女关系进一步的开始。与男人相比，女人异常看重双方之间的感情，并且期待着自己的人生会因结婚而发生戏剧性的变化。 打从一开始，男人和女人对婚姻的认识和对自己的影响就不相同了。 场景三妻子瑞贝卡费劲的把三个孩子哄睡，坐在客厅的沙发上等丈夫，一个小时后杰克从酒吧回家了，他们两开始了一场谈话。 杰克准备了一件礼物打算送给妻子，这时候瑞贝卡已经没有心思收礼物了，她的心思在丈夫是不是有家庭责任感上，看一组截图 瑞贝卡一心想在家庭里做个优秀的妈妈，而杰克没有用心投入和自己一起努力。瑞贝卡埋怨杰克只顾自己，喝酒晚回家，她正式的要求丈夫戒酒，留下杰克一个人在沙发。 这是他们第一次吵架，瑞贝卡和杰克两人都对婚后的生活产生了烦恼。杰克觉得结婚后，妻子不像以前那样关心自己，只好下班后喝酒排解。而妻子每天忙忙碌碌地照顾三个孩子吃饭和睡觉，她希望丈夫能加入进来多分担自己的压力，但是显然丈夫没有。 面对这样的困境，杰克会怎么办？妻子瑞贝卡接下来要怎么做？ 场景四早上醒来的瑞贝卡发现丈夫在自己的卧室外的走廊睡了一晚，接下来是一场对话 我把这段对话分为以下几个部分 第一部分杰克开场说了以下几句话： I don’t like sleeping far away from you.我不想睡得离你太远 No more drinking我再也不喝酒了 for you, I can为了你，我会戒酒 杰克谈话一开始就摆明了自己的想法：戒酒，表达了自己对妻子的依恋：不想睡得离你太远 第二部分杰克回忆了小时候的事情，大人常问小孩长大后要成为什么样的人？当时我并不知道，直到28岁，直到遇到了你，我知道，我要成为能让你幸福的人。再一次陈述自己以后会怎么做：为孩子做到11分，为瑞贝卡，我的妻子做到12分 第三部分瑞贝卡感受到了杰克的心，当杰克问是否能原谅自己时，瑞贝卡同意了。杰克亲吻了妻子，精神上通了，紧接着加上肢体接触：亲吻妻子的手，送上昨晚没送出去的礼物。 第四部分这时候夫妻俩又重新有了情感的互动。接吻等更多的肢体行为，这一切又被他们三个醒来的孩子打断，溢出了满满的温馨。 小结我想在事件里的杰克并不是通过理性（像上面这些的逻辑分析）来做出行为的，而是用内心的念想做出了自己的行为。他将心注入，与妻子情感形成了回流，便有了这样一次有效的沟通。家庭就在这起起伏伏里温暖地前行了。 我想到了开头，却没猜到结尾]]></content>
      <categories>
        <category>美剧</category>
      </categories>
      <tags>
        <tag>This is us</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈Java反射]]></title>
    <url>%2F2018%2F01%2F22%2F2018%2F2018-01-22%2F</url>
    <content type="text"><![CDATA[在日常开发中尽量不要用反射，如果需要，先考虑通过复制原始类的形式来避免反射，还不行再考虑通过反射。 反射能帮我们做什么？ 反射构建出无法直接访问的类 set或get到无法访问的类变量 调用不可访问的方法 每个包装器原始数据类型类具有名为 TYPE 的静态字段int.class 和 Integer.TYPE 指的是同一个类对象。 上一篇我在Java反射札记里说了如何反射一个类，代参实例对象，反射属性和方法。这次我们来看一个开源类库 jOOR 传送门 (https://github.com/jOOQ/jOOR) 我们一起学习下这个库的代码 这个开源库适配了Java6，Java8 和2017年11月份已经发布的Java9，作者在开发这个类库使，借鉴了已有的项目，做了调研和测试。 github上给出的Demo代码段： 12345String world = on(&quot;java.lang.String&quot;) // Like Class.forName() .create(&quot;Hello World&quot;) // Call most specific matching constructor .call(&quot;substring&quot;, 6) // Call most specific matching substring() method .call(&quot;toString&quot;) // Call toString() .get(); 上述代码采用链式调用，on方法 create方法，call方法内部都是调用的on的重载方法，返回Reflection类，最后的get()内部采用了泛型返回，如下： /** * Get the wrapped object * * @param &lt;T&gt; A convenience generic parameter for automatic unsafe casting */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T get() { return (T) object; } 关于泛型的使用，可以查阅之前的两篇： 重识Java泛型 上 重识Java泛型 下 在Android项目中，findViewById经过这样封装后，再也不用强转类型了。 类加载机制JVM里java的类的加载流程图这部分内容已在：Java反射札记 这篇讲解了，这里不重复了 Loading -&gt; Linking -&gt; Initialization 类一定会初始化的五大情况 使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。 关于第五点，没有接触过 现在通过代码实践来试试看吧 我定义了SuperClass类和SubClass类 SuperClass类 123456789101112131415161718public class SuperClass &#123; public static String sValue = &quot;666&quot;; public static final String HELLO_WORLD = &quot;hello world!&quot;; static &#123; Out.println(&quot;SuperClass init&quot;); &#125; public String getContent()&#123; return &quot;This is String result&quot;; &#125; public static void setsValue(String value)&#123; sValue = value; &#125;&#125; SubClass 12345678910111213public class SubClass extends SuperClass &#123; public static String sTemp = &quot;&quot;; static &#123; sTemp = &quot;sub class temp&quot;; Out.println(&quot;Subclass init&quot;); &#125; public void instanceTest()&#123; Out.println(&quot;instanceTest&quot;); &#125;&#125; 测试下第一点，new的时候/** * 类初始化 */ private static void testVersion1_2() { SubClass subClass = new SubClass(); } 输出： 12SuperClass initSubclass init 子类SubClass和SuperClass都经历了类初始化阶段 测试下第一点里提到的引用静态字段时/** * 类初始化3 */ private static void testVersion1_3() { Out.println(SubClass.sTemp); } 输出： SuperClass init Subclass init sub class temp 再看下这段代码 /** * 类初始化1 主动引用／被动引用 */ private static void testVersion1_1() { Out.println(SubClass.sValue); } 你觉得SubClass类会调用static静态代码块么？ 输出: 12SuperClass init666 答案是不会，神奇的一幕，SubClass没有经过类初始化 Java“相等”判定相关方法我们最熟悉的是instanceof方法，这个是实例对象的方法，判断当前对象是否是某个类的实例。 如果我要比较class类与类之间是否子类关系呢？要比较class对象和一个实例对象呢？ Java反射为我们提供了解决方法 /** * 相等判断 除了 instanceof */ private static void testVersion2_1() { Out.println(SuperClass.HELLO_WORLD); } private static void testVersion3_1() { boolean isAssignable = SuperClass.class.isAssignableFrom(SuperClass.class); Out.println(&quot;isAssignable = &quot; + isAssignable); } private static void testVersion3_2() { SubClass subClass = new SubClass(); boolean isInstance = SuperClass.class.isInstance(subClass); Out.println(&quot;isInstance = &quot; + isInstance); } 说明：使用isInstance，isAssignableFrom是需要注意判断的逻辑关系。比如拿testVersion3_1方法举例，boolean isAssignable = SuperClass.class.isAssignableFrom(SuperClass.class);说的是SuperClass是否是SuperClass的子类啊？isAssignable的布尔值就是答案 参考资料 Java反射最佳实践 JVM类加载机制详解（一）JVM类加载过程]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式实战分析 下篇]]></title>
    <url>%2F2018%2F01%2F17%2F2018%2F2018-01-17%2F</url>
    <content type="text"><![CDATA[引子还记得上次分享的练习题么 有一箱东港九九草莓，想吃其中最大的一颗草莓？（可模拟所需的所有数据） 自己实现筛选工具类public static &lt;T&gt; T getMax(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) { Objects.requireNonNull(list); Iterator&lt;T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext()) { T next = iterator.next(); int value = comparator.compare(result, next); if (value &gt; 0) { result = next; } } return result; } 其中Comparator不是系统的类，是我自己实现的接口 Comparator类代码： 123456789101112131415161718@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T t1, T t2); static &lt;E&gt; Comparator&lt;E&gt; comparing(ToIntFunction&lt;E&gt; function) &#123; return (E b1, E b2) -&gt; function.applyAsInt(b2) - function.applyAsInt(b1); &#125; static &lt;E&gt; Comparator&lt;E&gt; comparing(ToIntFunction&lt;E&gt; function, ToIntFunction&lt;E&gt; function2) &#123; return (E b1, E b2) -&gt; function.applyAsInt(b2) - function.applyAsInt(b1) == 0 ? function2.applyAsInt(b2) - function2.applyAsInt(b1) : function.applyAsInt(b2) - function.applyAsInt(b1); &#125; default Comparator&lt;T&gt; thenCompare(ToIntFunction&lt;T&gt; function)&#123; return (T t1, T t2) -&gt; compare(t1, t2) == 0 ? Comparator.comparing(function).compare(t1, t2) : compare(t1, t2); &#125;&#125; 使用lambda如何实现private static void filterVersion1() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, (Strawberry b1, Strawberry b2) -&gt; b2.getWeight() - b1.getWeight()); Out.println(&quot;我想吃最大的草莓是：&quot;); Out.println(strawberry.toString()); } 通过方法引用如何实现private static int getComparator(Strawberry b1, Strawberry b2) { return b2.getWeight() - b1.getWeight(); } private static void filterVersion2() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, Practice2Client::getComparator); Out.println(&quot;我想吃最大的草莓是：&quot;); Out.println(strawberry.toString()); } 在使用方法引用时，取方法名要格外恰当，好的方法名能让代码像是在描述问题而不是在解决问题 现在我不想吃最大的草莓了，我想吃最甜的草莓，要怎么做呢？高阶函数：如果一个函数的输入或者输出也是函数，那么这个函数就是高阶函数。举个例子 private static com.sugarya.interfaces.Comparator&lt;Strawberry&gt; comparing(Function&lt;Strawberry, Integer&gt; function) { return (Strawberry b1, Strawberry b2) -&gt; function.apply(b2) - function.apply(b1); } private static void filterVersion4() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, comparing(Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } 如果最大的草莓重量相同时，我想吃其中最甜的，怎么做？private static com.sugarya.interfaces.Comparator&lt;Strawberry&gt; comparing(Function&lt;Strawberry, Integer&gt; function, Function&lt;Strawberry, Integer&gt; function2) { return (Strawberry b1, Strawberry b2) -&gt; function.apply(b2) - function.apply(b1) == 0 ? function2.apply(b2) - function2.apply(b1) : function.apply(b2) - function.apply(b1); } /** * 找到最大的草莓，如果一样大，就要其中最甜的 */ private static void filterVersion5() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, comparing(Strawberry::getWeight, Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } java8的接口允许定义静态方法，要定义实例方法，需要关键词default，即为默认方法 如果要在其他类里再次筛选，代码就要重复，因此，考虑把逻辑封装到接口里，代码如下： 有没有办法像链式调用那样，在外层添加新的判断逻辑呢？可以的，Comparator接口里，实现thenCompare方法。 default Comparator&lt;T&gt; thenCompare(ToIntFunction&lt;T&gt; function){ return (T t1, T t2) -&gt; compare(t1, t2) == 0 ? Comparator.comparing(function).compare(t1, t2) : compare(t1, t2); } /** * 最大的草莓，如果一样大，就要其中最甜的 */ private static void filterVersion7() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, Comparator.comparing(Strawberry::getWeight).thenCompare(Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } 复合Lambda表达式这里我们自己实现了一个Lambda表达式的复合使用。把多个简单的Lambda复合成复杂的表达式 lambda重构Lambda与匿名内部类的差异匿名类中this代表的是函数式接口对象，但是在Lambda表达式中代表的是外部所在的类。 lambda表达式里的局部变量不能和外部的变量重名，匿名内部类可以 匿名内部类可以实现非函数式接口，lambda表达式只能作为是函数式接口的传入 lambda表达式的类型问题lambda表达式反映的是结构 12345678910111213private static void testLambda() &#123; testLambdaSign((Task) () -&gt; &#123; println(&quot;&quot;); &#125;);&#125;private static void testLambdaSign(Runnable runnable) &#123; println(&quot;testLambdaSign Runnable&quot;);&#125;private static void testLambdaSign(Task task) &#123; println(&quot;testLambdaSign task&quot;);&#125; lambda实战应用表达式解决设计模式与生俱来的设计僵化问题 lamdba表达式与设计模式对策略方法，观察者模式时，把设计模式里涉及到函数式接口替换成lambda表达式表示即可。 模板设计模式模板设计模式，通过继承抽象类，实现抽象方法来实现。这时候可以直接引入一个新的参数，来替换抽象类，函数描述符。 1234567891011121314151617181920212223242526public abstract class AbstractComputer &#123; public void work()&#123; powerOn(); int hardware = checkHardware(); loadOS(hardware); &#125; public void work(Consumer&lt;Integer&gt; consumer)&#123; powerOn(); int hardwareParam = checkHardware(); consumer.accept(hardwareParam); &#125; protected void powerOn()&#123; Out.println(&quot;开启电源&quot;); &#125; protected int checkHardware()&#123; Out.println(&quot;检查硬件&quot;); return 1; &#125; protected abstract void loadOS(int hardware);&#125; 责任链模式而责任链模式使用了复合lambda表达式 把数据结构里的链式思维应用在面向对象的编程里，将每一个链条的节点看作是一个对象，每个对象拥有不同的处理逻辑。一个业务逻辑被看作从链条的首端发出，途径一个个链节点，至末端结束。 面向对象的编程： 使用父类&amp;子类建立思维体系 通过类与类的相互联系和通信来组织逻辑 用重写来表达变化 用抽象方法表达抽象 用接口来表达抽象 链节点：作为对象，我们建立一个基类来表示，具体的每个节点是它的子类。 每个对象／节点处理不同的逻辑：不同是变化，需要抽象出来，可以用抽象方法表达抽象，也可以用接口表达抽象。这里我们用抽象方法来做 链式思维：每个当前节点，持有下一个节点，如果是双向的链式，则再持有上一个节点。常用的方式，当前节点的输出作为下一个节点的输入 代码实现123456789101112131415161718192021222324public abstract class AbstractNode&lt;T&gt; &#123; private AbstractNode&lt;T&gt; nextNode; public T startChain(T t)&#123; T element = handle(t); if(nextNode != null)&#123; return nextNode.handle(element); &#125; return t; &#125; public AbstractNode&lt;T&gt; getNextNode() &#123; return nextNode; &#125; public void setNextNode(AbstractNode&lt;T&gt; nextNode) &#123; this.nextNode = nextNode; &#125; public abstract T handle(T t);&#125; FirstNode1234567public class FirstNode extends AbstractNode&lt;String&gt; &#123; @Override public String handle(String s) &#123; return &quot;Hello, &quot; + s; &#125;&#125; SecondNode1234567public class SecondNode extends AbstractNode&lt;String&gt; &#123; @Override public String handle(String s) &#123; return s.replace(&quot;lamda&quot;,&quot;lambda&quot;); &#125;&#125; 使用12345678private static void testChainByLambda() &#123; Function&lt;String, String&gt; firstNode = s -&gt; &quot;Hello, &quot; + s; Function&lt;String, String&gt; secondNode = s -&gt; s.replace(&quot;lamda&quot;, &quot;lambda&quot;); Function&lt;String, String&gt; chain = firstNode.andThen(secondNode); String result = chain.apply(&quot;This is lamda&quot;); Out.println(&quot;chain result = &quot; + result); &#125; 简单工厂工厂设计模式，使用到构造函数的方法引用 123456789101112131415public class FruitFactory2 &#123; private static Map&lt;FruitType, Supplier&lt;? extends Fruit&gt;&gt; FRUIT_MAP = new HashMap&lt;&gt;(); static &#123; FRUIT_MAP.put(FruitType.Apple, Apple::new); FRUIT_MAP.put(FruitType.Strawberry, Strawberry::new); &#125; public static &lt;T extends Fruit&gt; T createFruit(FruitType fruitType) &#123; Objects.requireNonNull(fruitType); return (T)FRUIT_MAP.get(fruitType).get(); &#125; &#125; Java8的lambda表达式与Kotlin，Python的差异这些设计模式在使用lambda表达式重写会更简洁，但是也有人疑问，lambda只是让代码简洁而已，我用匿名内部类或接口仍然可以健壮的实现功能啊。对于这个疑问，我的理解是，如果赞同函数式编程是未来的方向，那么就很有必要使用lambda表达式，lambda表达式这套新的符号背后承载的是不同以往的思维方式–即所谓的“函数式”的思维。不够好的式Java8的lambda是不完全的函数式，但是从另一个角度来说，这也是好的，java8不完全的函数式能让java 7的程序员更容易和平稳得从面向对象过渡到函数式编程。 函数式的程度由低到高是： Java8 《 Kotlin 《 Python 我分别举个Koltin和Python的例子 Kotlin实现链式private fun startChain(str: String): String{ val firstNode: (String) -&gt; String = {s -&gt; &quot;Hello, &quot; + s} val secondNode = { s: String -&gt; s.replace(&quot;lamba&quot;, &quot;lambda&quot;)} return secondNode(firstNode(str)) } Kotlin比Java8更加函数式 Python实现链式1234567def startChain(x): firstNode = lambda x: &quot;Hello, &quot; + x secondNode = lambda x: x.replace(&quot;lamda&quot;, &quot;lambda&quot;) return secondNode(firstNode(x))print(startChain(&quot;This is lamda&quot;)) Python比Kotlin更加函数式]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Functional Programming</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式实战分析 上篇]]></title>
    <url>%2F2018%2F01%2F10%2F2018%2F2018-01-10%2F</url>
    <content type="text"><![CDATA[lambda表达式是Java 8中最大语言改变了，允许我们将函数当作参数传递给其他方法，简而言之就是实现了：行为参数化。 lambda表达式是函数式编程里重要的概念。现在我尝试通过一个例子来说明Lambda表达式的演化过程 一个果农的需求变化有个应用程序是帮助果农了解自己的库存的。这位果农可能想有一个查找库存中所有绿色苹果的 功能。但到了第二天，他可能会告诉你:“其实我还想找出所有重量超过150克的苹果。”又过了两天，农民又跑回来补充道:“要是我可以找出所有既是绿色，重量也超过150克的苹果，那就太 棒了。” 你要如何应对这样不断变化的需求? 需求变更过程1. 果农查找库存中所有绿色苹果实现代码如下： 1234567891011121314151617/** * 筛选绿苹果 * @param rawAppleList * @return */private static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; rawAppleList)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty())&#123; return result; &#125; for(Apple apple : rawAppleList)&#123; if(&quot;Green&quot;.equalsIgnoreCase(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result;&#125; 2. 果农查找库存中所有红色苹果需求从查找绿苹果变成了查找红苹果，可以推测之后农户有可能要查询黄苹果，因此新增一个颜色入参 12345678910111213141516171819/** * 筛选任意一颜色的苹果 * @param rawAppleList * @param color * @return */private static List&lt;Apple&gt; filterApplesWithColor(List&lt;Apple&gt; rawAppleList, String color)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty())&#123; return result; &#125; for(Apple apple : rawAppleList)&#123; if(color.equalsIgnoreCase(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result;&#125; 3. 果农查找库存中超过150克的重苹果方法的入参增加一个形参：重量 /** * 筛选出大苹果 * @param rawAppleList * @param weight * @return */ private static List&lt;Apple&gt; filterApplesWithWeight(List&lt;Apple&gt; rawAppleList, int weight){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(weight &lt; apple.getWeight()){ result.add(apple); } } return result; } 4. 果农查找库存中的绿苹果和超过150克的重苹果引入表示重量和颜色的入参 /** * 通过颜色和重量筛选苹果 * @param rawAppleList * @param color * @param weight * @return */ private static List&lt;Apple&gt; filterApplesByProperty(List&lt;Apple&gt; rawAppleList, String color, int weight){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(color != null &amp;&amp; weight &gt; 0) { if (weight &lt; apple.getWeight() &amp;&amp; color.equalsIgnoreCase(apple.getColor())) { result.add(apple); } } } return result; } 果农之后想对苹果的不同属性做筛选，比如大小、形状、产地，品种等，怎么办？ 如果这位果农想多个属性组合查询，做更复杂的查询，比如红色的来自福建的大苹果，又该怎么办？ 应对这些需求，需要给方法里添加很多参数，有没有更好的封装？ 接口上述过程，复制了大部分的代码来实现遍历查询。如果你想要改变筛选遍历方式来提升性能呢? 那就得修改所有方法的实现，而不是只改一个，这代价太大了。我们需要复用，我们需要抽象。 提取抽象要确定抽象的部分，确定要求我们对需求的变更和未来的演化过程有清晰的认识，基于这种认识来确定抽象。 使用接口定义一个抽象方法，不同的判断条件交给不同的实现类来完成。一次判断条件看作一种行为，不同的实现类表达不同的筛选行为。 /** * 筛选苹果 * @param rawAppleList * @param predicate * @return */ private static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; rawAppleList, IApplePredicate predicate){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(predicate.test(apple)){ result.add(apple); } } return result; } 此时，filterApples方法的行为的差异取决于我们传给IApplePredicate的实现类的行为，filterApples行为被参数化了。 匿名内部类在使用过程中，发现如果判断条件有很多种，会生成多个实现类。使用匿名内部类能化简代码，减少啰嗦 List&lt;Apple&gt; apples = filterApples(RAW_APPLE_LIST, new IApplePredicate() { @Override public boolean test(Apple apple) { if (&quot;Red&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &lt; apple.getWeight() &amp;&amp; &quot;福建&quot;.equals(apple.getProducingArea())) { return true; } return false; } }); 果农需要查询什么，我传入不同筛选条件的匿名内部类。 使用Lambda表达式使用匿名内部类存在一段模板代码，我们希望连这样的模板代码都没有，让代码更简洁些。 然后，简洁性和易读性这两者看起来存在矛盾，简洁就意味着代码量少，往往也带来不易读。 Oracle工程师提出了一种处理方式： Lambda表达式来化解简洁性和易读性的冲突。 1234567filterApples(RAW_APPLE_LIST, (Apple apple) -&gt; &#123; if(&quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight())&#123; return true; &#125; return false;&#125;); lambda表达式详解lambda表达式组成部分使用匿名内部类和lambda表达式对比 123456789101112private static void testFilterAnonymous()&#123; filterApples(RAW_APPLE_LIST, new IApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); &#125; &#125;);&#125;private static void testFilterApplesLambda()&#123; filterApples(RAW_APPLE_LIST, (Apple apple) -&gt; &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight());&#125; lambda表达式由参数，箭头和方法体三部分组成. 一个方法有入参，返回值和方法实现。匿名内部类的里的test方法的入参，作为lambda箭头左侧部分，(当入参达到两个以上时使用圆括号)，test方法实现作为了lambda箭头右侧部分，test方法的返回值用右侧表达式返回值来表达。当需要多条语句时，需要用花括号{}，并显示声明返回的类型 1234567apple -&gt; &#123; println(&quot;&quot;); return &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); &#125;;``` lambda表达式是有返回类型的，是对应的接口名 Predicate filter = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566### 什么地方使用lambda表达式有函数式接口的地方就可以使用lambda表达式。**函数式接口：**只定义了一个抽象方法的接口。@FunctionalInterface我们熟悉的Runnable，Callback，Comparator, Comparable都是函数式接口写lambda表达式时，入参数量，各个参数的类型以及表达式返回类型怎么确定呢？这些信息，需要熟悉对应的函数式接口。Java8引入了一些新的函数式接口，常见的如下* Predicate\&lt;T&gt; boolean test(T t); * Consumer\&lt;T&gt; void accept(T t); * Supplier\&lt;T&gt; T get(); * Function\&lt;T, R&gt; R apply(T t); * BiFunction R apply(T t, U u); * UnaryOperator\&lt;T&gt; public interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123;&#125;* BinaryOperator\&lt;T&gt; public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;&#125; * Comparator int compare(T o1, T o2);**说明：**Java库提供的这些接口，没有异常处理，因此，要么我们自己定义函数式接口抛出一场，要么在使用这些系统提供的函数式接口写Lambda表达式时，自己捕获异常### lambda的相关概念#### 目标类型lambda表达式返回类型，也即函数式接口#### 函数描述符比如，上文的Predicate&lt;Apple&gt;的抽象方法的函数描述符为： (Apple) -&gt; Boolean ### Lambda表达式的类型检查Java编译器如何检查Lambda表达式的类型？1. 在调用lambda表达式处，找到目标类型，即函数式接口2. 找到在函数式接口里，抽象方法函数名，入参，返回值，生成函数描述符号。3. 抽象方法的函数描述符和lambda表达式的签名比对### 同样的Lambda表达式，可以有不同返回类型看下面的例子 Predicate appleFilter = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();12 Function&lt;Apple, Boolean&gt; appleFilter1 = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();1234相同的Apple-&gt;Boolean 返回类型可以是Predicate，也可以是Function### 类型推断利用泛型的类型推断，可以省略lambda表达式入参的类型声明，比如 Predicate filter = apple -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); 12 filterApples(RAW_APPLE_LIST, apple -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight());123456## 方法引用方法引用能有效的简化lambda表达式，我们来举个例子创建一个草莓类，Strawberry public class Strawberry { private int weight; private String color; public Strawberry() { } public Strawberry(int weight) { this.weight = weight; } public Strawberry(int weight, String color) { this.weight = weight; this.color = color; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return &quot;Strawberry{&quot; + &quot;weight=&quot; + weight + &quot;, color=&apos;&quot; + color + &apos;\&apos;&apos; + &apos;}&apos;; } }12 public class TransferUtils { public static int doubleValue(int value){ return 2 * value; } public void tripleOver(int a){ System.out.println(String.valueOf(3 * a)); } }1234### 构造函数的方法引用无参构造 Supplier strawberrySupplier = Strawberry::new;Strawberry strawberry = strawberrySupplier.get();1一个参数的构造 IntFunction f = Strawberry::new;Strawberry strawberry = f.apply(10);1两个参数的构造 BiFunction&lt;Integer, String, Strawberry&gt; biFunction = Strawberry::new;Strawberry strawberry = biFunction.apply(20, “RED”);1234### 静态方法类名::方法名 /** * 静态方法引用 */ private static void testMRStatic(){ List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4); List&lt;Integer&gt; collect = list.stream() .map(TransferUtils::doubleValue) .collect(Collectors.toList()); println(collect); } 123456789### 实例的方法引用* 无入参的实例方法，格式同静态方法引用 String::length这种使用会有一个疑问：实例的方法引用为什么能用类名来引用？其实这里还是调用了实例的方法，上文的实例是字符串对象。 /** * 实例方法引用无参方法 */ private static void testMRObject(){ Arrays.asList(new Strawberry(21), new Strawberry(23)).forEach(Strawberry::displayWeight); } 1234 * 带入参的实例方法 类实例名::方法名 /** * 实例方法引用有参方法 */ private static void testMRObject2(){ TransferUtils transferUtils = new TransferUtils(); Arrays.asList(1, 2, 3, 4).forEach(transferUtils::tripleOver); } ` 练习题有一箱东港九九草莓，找到其中最大的一颗？（可模拟所需的所有数据） 小结lambda演化路径接口 –》匿名内部类–》Lambda表达式 问题回顾 从Java7到Java8，lambda表达式经历了怎样的逻辑演化？ lambda表达式能用在哪些场景？ lambda表达式和匿名内部类是什么关系？ 方法引用如何简化lambda表达式？ lambda表达式还可以复合使用，还可以在策略模式，模板方法，观察模式（接口回调）等设计模式中使用 相关的代码，已上传到Github 代码传送门 参阅的资料 简书：【译】Java 8的新特性—终极版 书籍：Java8实战 书籍：Java8函数式编程]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Functional Programming</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重识Java泛型]]></title>
    <url>%2F2018%2F01%2F05%2F2018%2F2018-01-05%2F</url>
    <content type="text"><![CDATA[泛型的前奏JDK1.4及之前的黑暗时期原生态类型，Object进行类型转化 比如往list中可以添加任何类型的对象，但是在从集合中获取对象时，无法确定获取到的对象是什么具体的类型 为什么要引入泛型 带来了类型安全性：在编译器发现类型异常，静态语言提高代码表达力：比如方法返回泛型类型，智能推断 能用Object的场景都可以用泛型替代，比如泛型T t，这个t能调用的都是Obejct里有的方法，默认看作是Obejct。 什么时候需要重新用回原生态类型 类class对象，比如 List.class 可以； List&lt;&gt;.class 错误 泛型的基础理论大部分编译器处理泛型的方式有方式一：Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要 针对string，integer，float产生三份目标代码。 方式二：Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。 Java编译器的处理方式Code specialization实现会导致代码膨胀（code bloat），在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针，没必要为每个类型都产生一份执行代码。 所以Java编译器采用了方式二Code sharing，通过类型擦除（type erasue）来实现，即类型擦除是编译器对Java泛型的处理过程 类型擦除历史包袱：因为泛型是在1.5引入的，为了向前兼容，所以sun工程师们考虑只在编译时处理，同时使用桥接方法 从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除的处理过程如下： 将所有的泛型参数用其最顶级的父类型替换（extends 的限定类型／Object） 移除所有的类型参数信息，即去掉&lt;&gt;里的内容 在必要的时候添加类型检查和类型转换的方法 生成一些桥接方法（bridge method） 桥接方法类型擦除会带来两个问题 类型擦除与多态的冲突 方法签名冲突 桥接方法就是为了解决上述问题 为什么要引入泛型通配符实现协变，List&lt;?&gt; 等效于 List&lt;? extends Object&gt; 举个例子 Set是参数化类型，表示可以包含任何对象类型的一个集合Set&lt;?&gt;表示只能包含某种未知对象类型的一个集合Set原生类型是类型不安全的 什么是协变，逆变和不变逆变与协变用来描述类型转换（type transformation）后的继承关系，f(⋅)f(⋅)表示类型转换，≤表示继承关系 f(⋅)f(⋅)是协变（covariant）的，当A≤BA≤B时有f(A)≤f(B)成立f(A)≤f(B)成立 f(⋅)f(⋅)是逆变（contravariant）的，当A≤BA≤B时有f(B)≤f(A)f(B)≤f(A)成立 f(⋅)f(⋅)是不变（invariant）的，当A≤BA≤B时上述两个式子均不成立，即f(A)f(A)与f(B)f(B)相互之间没有继承关系 Java数组支持协变，Java的泛型不支持协变，但是可以通过通配符进行模拟 泛型的上下边界&lt;? extends 限定类型&gt; 类型实参只准传入某种类型的子类 &lt;? super 限定类型&gt; 类型实参只准传入某种类型的父类 &lt;? extends 限定类型&gt;实现了泛型的协变 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); &lt;? super&gt;实现了泛型的逆变 1List&lt;? super Number&gt; list = new ArrayList&lt;Object&gt;(); 边界的副作用那就是容器的部分功能可能失效 PECS原则&amp;Get and Put Principleproducer extends, consumer super 泛型的使用场景数组数组是具体化的，即在运行时才知道并检查他们的元素类型；泛型是在编译器就检查他们的元素类型 为什么数组不支持泛型元素 数组是协变和可具体化，提供运行时类型安全，没有编译时类型安全 泛型不支持协变，类型擦除，提供编译时类型安全 上述1和2点逻辑是矛盾的，所以数组不支持泛型元素，当需要数组和泛型混合使用，使用列表来实现(Effective Java 第25条 列表优于数组) 泛型类,泛型接口在实例化类的时候指明泛型的具体类型 泛型方法是在调用方法的时候指明泛型的具体类型 泛型类里带泛型方法 泛型声明，泛型使用 泛型方法能使方法独立于类而产生变化 显式类型声明显示参数类型.&lt;&gt;举个例子，以下是RxLifecycle的一个使用 1234567891011121314Observable.interval(1, TimeUnit.SECONDS) .doOnDispose(new Action() &#123; @Override public void run() throws Exception &#123; Log.i(TAG, &quot;Unsubscribing subscription from onCreate()&quot;); &#125; &#125;) .compose(this.&lt;Long&gt;bindUntilEvent(ActivityEvent.PAUSE)) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long num) throws Exception &#123; Log.i(TAG, &quot;Started in onCreate(), running until onPause(): &quot; + num); &#125; &#125;); 其中 this.bindUntilEvent(ActivityEvent.PAUSE))就用到了泛型的显式转换 忽略类型不安全的警告@SuppressWarnings(“unchecked”)，有了这个注解编译的时候会忽略类型安全的异常警告，举个例子 @SuppressWarnings(&quot;unchecked&quot;) public &lt;T extends View&gt; T getView(@IdRes int viewId) { View view = views.get(viewId); if (view == null) { view = itemView.findViewById(viewId); views.put(viewId, view); } return (T) view; 与操作&amp;在泛型中的使用123public &lt;T extends Cloneable &amp; Comparable&gt; void setup(T t)&#123; System.out.println(&quot;setup&quot;);&#125; 泛型实现异构容器不像普通的map，它的所有健都是不同类型，每个健都可以有一个不同的参数化类型，比如Class, Class public class Favorites{ private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance){ if(type == null){ throw new NullPointerException(&quot;Type is null&quot;); } favorites.put(type, instance); } public &lt;T&gt; T getFavorites(Class&lt;T&gt; type){ return type.cast(favorites.get(type)); } } 泛型的使用思维 泛型是用来传递对象类型，像是从管道里滑一遍出来 在封装的时候，我们通常不知道泛型实参类型，因此无法使用对应的方法，如果要使用，有几种办法： 引入泛型上界，使用限定对象的能力 instanceof 泛型能规整参数的位置关系 是否需要给泛型类里的泛型方法增加协变的能力 ###泛型涉及到的Java概念汇总原生态类型，类型形参，类型实参 协变（kotlin语言文档翻译为型变） ，逆变，不变 通配符，泛型上边界，泛型下边界 类型安全: 在运行时不发生ClassCastException异常 可具体化类型(reifiable): 其运行时表示法包含的信息比编译时表示法包含更多的信息的类型 不可具体化的类型（non-reifiable）: 其运行时表示法包含的信息比它的编译时表示法包含更少的信息的类型 参阅文章 知乎：Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 Java泛型－类型擦除 第六节：协变和逆变 Java中的逆变与协变 Java系列：关于Java中的桥接方法 Java泛型2—泛型的本质]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Genericity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滨海图书馆半日游]]></title>
    <url>%2F2017%2F12%2F31%2F2017%2F2017-12-31%2F</url>
    <content type="text"><![CDATA[天津的东南之隅，是滨海新区，滨海新区里坐落着一座风格迥然的图书馆，它对望万达广场，侧卧中央大道，背靠紫云公园，因其独特的人眼设计，让我慕名而来。 正门进入是一个小广场，有一个图书馆模型，我去的时候，广场上有古琴和琵琶演奏，我听了一段时间，古琴弹了流水和琵琶弹的是琵琶语。 滨海图书馆分为三个部分，从左到右依次为： 美术馆 图书馆 探索馆 地下还有商业圈，有餐馆，饮料，服装店，甚至有自制泥巴陶瓷的体验店 美术馆一楼-书画展和泥人展进入一楼大厅，先来一张能量图： 有一个泥人张的展览，我喜欢这里的木椅，中国元素的欧式简约风 还有这个摄心常在的达摩泥人： 二楼-摄影展二楼是摄影展，大部分反映滨海新区建设场景和城市风光 三楼-油画展油画看不懂，印象最深的是这副名叫秋潮的油画： 以及这副–跑到油画里的设计师： 图书馆先来一张平面示意图： 排了老长老长的队伍，进入图书馆大厅 图片里感觉书架上的堆满了书，其实这些都是图片。 每一层的过道可坐可立，坐在高处视线很好，滨海之眼的眼珠就是眼前的巨大圆球，表面是显示屏，里面是报告厅。在这里举办婚礼和大型演讲效果应该会很好。 一层又一层的阶梯直通自习室，插排设计成折叠式的，在自习室的靠窗户一侧排放了一排的沙发，自习室同向的对侧也是自习室，两者的中间是电梯和休息室，电梯可以通道三楼和四楼，如果想要更安静的看书，三楼和四楼是更好的去处。 其他地儿出了图书馆大厅，兜兜转转，不经意间发现一处特别雅致的书房 在这里敲代码一定是一种特别好的体验。 结尾最后贴出滨海图书馆的开放时间：]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前车距离知多少]]></title>
    <url>%2F2017%2F12%2F29%2F2017%2F2017-12-29%2F</url>
    <content type="text"><![CDATA[驾校考试里的科目一有如下条约： 《实施条例》第八十条：机动车在高速公路上行驶，车速超过每小时100公里时，应当与同车道前车保持100米以上距离，车速低于每小时100公里时，与同车道前车距离可以适当缩短，但最小距离不得少于50米 提出问题我产生了几个疑问： 为什么车速超过100km/h时，距前车距离要100米以上？ 为什么车速低于100km/h时，距前车距离要50米以上？ 而不是150米？200米？或者300米呢？ 汽车的刹车距离是怎么计算的？受哪些因素影响呢？ 解决问题一次刹车的过程一辆在高速公路上行驶的小车，驾驶员从看到前方车辆骤停到下脚踩踏板，需要一个反应时间。踏板踩下去，到制动装置开始生效需要一个时间。车辆开始减速直到停止需要一个时间。这里涉及到三个时间段依次分别是：反应时间，制动器作用时间，持续制动时间。 制动分析在知乎上看到一张图，图片来源于大学教程，上面一张的是实测数据，下面一张图是简化后的曲线： 说明：t1为驾驶员反应时间，一般为0.3s~1.0s。 t2为制动器的作用时间。一般在0.2s~0.9s之间。 而从e到f为持续制动时间t3。到f点时驾驶员松开踏板，而制动力消除还需要一段时间，t4一般在0.2s~1.0s之间 影响刹车距离的因素除了上述所说的驾驶员反应时间，汽车的制动性能之外还有车速，轮胎与路面的摩擦力。 据此建立数学建模，b到f段（制动器的作用时间，持续制动时间下的）刹车距离的函数关系式如下：（来源于知乎） Ua0即是车速，Abmax是最大制动减速度（负向加速度） 关于最大制动减速度，受汽车的制动性能和路面摩擦力共同影响。 网上找到了一段对制动减速度的描述： 123从汽车应具有的制动能力来说，紧急制动时，汽车的最大减速度一般为7.5－8米/秒普通制动时，汽车的平均减速度应为3－4米/秒但在实际使用制动时，除紧急情况外，通常不应使制动减速度大于1.5－2.5米/秒，否则不仅会使乘客感到不舒服或发生危险或造成货物不安全，而且还会增加燃料的消耗和轮胎的磨损。 这里我们使用的乘客感到舒服下的最大制动减速度为2.5。 计算距离刹车距离 = 反应时间内行车距离 + 制动距离 当车速为100km/h时 反应时间下的行车距离1km/h = 1000m/3600s = 5/18 m/s = 0.2778 m/s所以，100km/h = 27.78m/s 最大反应时间t1=1s，车速为100km/h反应距离 = 27.78m/s * 1s= 27.78m 制动距离 t2分别取0.2s，0.8s；Ua0 = 100km/h = 27.8m/s; abmax = 2.5 制动距离 = 1/3.6 0.6 27.78 + 27.78 *27.78 / 25.92 / 2.5 = 4.63 + 11.91 = 16.54m 刹车距离刹车距离 = 反应时间内行车距离 + 制动距离 = 27.78 + 16.54 = 44.32m 同理，当车速为160km/h，则刹车距离 = 44.45 + 37.91 = 82.36m 同理，当车速为180km/h，则刹车距离 = 50.00 + 46.91 = 96.91m 同理，当车速为200km／h，则刹车距离 = 55.56 + 56.98 = 112.54m 小结当车速低于100公里每小时，按100公里每小时作为最大值，因此50米以上的前车距离才能有效保证安全；当车速高于100公里每小时，按180公里每小时作为最大值，100米以上前车距离才能有效保证安全。 《实施条例》第八十条给出的前车距离的数值是确切，合理的。 查阅资料知乎：汽车制动距离的影响因素有哪些？ 百度百科：制动距离 汽车的制动减速度一般是多少？ 延伸什么是手刹和脚刹？手刹原理：通过刹车盘与刹车片产生的摩擦力来压紧制动盘而控制停车，类似自行车刹车。 脚刹原理：将刹车踏板的机械力传递给液压，刹车油液的液压力再通过管路传递到制动盘控制停车。 两者的区别手刹：拉线传递，作用于后轮，制动力小，轮胎可抱死；脚刹：液压传递，作用于四轮，制动力大，串联ABS轮胎不可抱死因此，手刹是辅助制动器，由于不需要发动机就能工作，故障小作为脚刹失灵的备份。 电子手刹与传统手刹的区别上面提到的手刹实际指的是传统卡钳式手刹，电子手刹控制方式从之前的机械式手刹拉杆变成了电子按钮。常见的电子手刹有拉索式与卡钳式两种。]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThisIsUs美剧观后感 上]]></title>
    <url>%2F2017%2F12%2F25%2F2017%2F2017-12-25%2F</url>
    <content type="text"><![CDATA[有一天一位视觉设计师向我推荐一部美剧：This is us，中文译名，我们这一天。欣然观看了第一季第一集，有一些感触 出场的人物一对年轻白人夫妻，生了两个白人孩子，领养了一个黑人宝宝。 一对兄妹Kate凯特， Kevin凯文。 一对年轻黑人夫妻，四口之家，有两个女孩。 剧情的纹理故事分三条线展开 第一条线是一对年轻夫妇，妻子怀了三胞胎，在医院待产，因为胎位问题，脐带卡住了第三个孩子的脖子而夭折。正巧这一天一位消防员在消防局旁捡到黑人弃婴并送到医院来。 第二条线，一对黑人夫妇，一家四口，爸爸是金融高管，瞒着妻子找到自己的亲生父亲，并带到了家里，妻子措手不及，最终还是同意了丈夫的安排。 第三条线，是一对兄妹，姐姐Kate，弟弟Kevin。姐姐Kate是个重度肥胖患者，在参加减肥自助会上认识了喜欢自己的同样胖乎乎的白人，开启了一段恋情。Kevin是一名演员，出演一部二流的电视剧，扮演一名照顾宝宝的保姆，对于这个需要脱上衣秀身材的角色，Kevin表示特别困惑，在一次表演后愤然离场。 是不是觉得，第一条线的故事和第二条第三条人物上有关联？确实，有关联，第一条线故事里的夫妇就是第二条线的兄妹和第三条线黑人的爸爸的父母。 喜欢的句子This is a fact Wikipedia hasn’t discovered it for us yet. Spirit of my silence I can hear you. But I’m afraid to be near you and I don’t know where to begin. How you took the sourest lemon that life has to offer and turned it into something resembling lemonade. There’s no lemon so sour that you can’t make something resembling lemonade. 剧中的场景场景一医生安慰爸爸 图中是左侧的医生正在安慰痛失第三个孩子的爸爸 在这位有仁爱的医生身上，我感受到了安慰人的方法： 提出陪伴请求，让被安慰的人给出肯定答复。这是安慰第一步，被安慰人的肯定答复后，双方开启了沟通的氛围。 感同身受，以情共鸣。安慰一开始不要讲道理，被安慰人伤心痛苦的时候，理性思维已经弱化了，他们需要被理解。于是医生说了曾经自己遇到的痛苦注意，痛失第三个孩子的爸爸的眼神方向，他的注意力已经成功地被医生吸引住了 医生说道，去年刚失去了心爱的妻子，我之所以一把年纪继续卖力工作，就是为了消磨时间，减轻对妻子的思念（不管有意无意，医生在传递痛苦之下的积极生活给对方） 失去第一个孩子，我接生的工作干了50年，接生过的孩子多的数不过来。医生的伤心和痛苦和爸爸面临的痛苦是有联系的，自然的让痛苦的爸爸继续保持注意力。医生继续说，即使这样，我没有哪一天不想起我夭折的孩子。 用自己的经历和故事来传递：我非常理解你的心情，能真切的感受到你现在面临的痛苦和伤心的感觉。 被安慰人听了这故事，也感受到了医生曾经的痛苦经历和情绪，这时候情感在医生和爸爸之间有了共鸣。 这还不够，这段痛苦带给我了变化，坚定我接生的工作 故事的末尾，医生说出了自己对生活的感悟，同时把焦点转向这位爸爸身上。 最后，医生给了一些建议，让伤心的爸爸做了事情。这时候的失去第三个孩子的爸爸情绪得到了缓解，医生的安慰起作用了。 场景二黑人夫妇在场外照看参加运动比赛的两位女儿 国外中产阶级的父母会很重视和孩子互动的亲子时间，周末拿出一段时间和参加孩子的活动。 我们从孩童时代一路走来，途中经历的快乐，失意，烦恼，心伤，困扰，迷迷糊糊中成长。成为父母后，我们陪着自己的孩子重新来一遍这段路途，只是角色改变了，从运动员变成场外教练员。对我们来说，是生命的另一种体验。 小结This is us，真实而温馨，我想我会继续观看下去Merry Christmas 圣诞快乐～ 该剧点评 豆瓣：我们这一天 第一季 知乎：如何评价NBC美剧《我们这一天》（This Is Us） 简书：美剧《This is us》: 这就是我们追求的样子]]></content>
      <categories>
        <category>美剧</category>
      </categories>
      <tags>
        <tag>This is us</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射思考与代码小结]]></title>
    <url>%2F2017%2F12%2F21%2F2017%2F2017-12-21%2F</url>
    <content type="text"><![CDATA[Java反射相关内容，在看一些开源框架和自己动手封装逻辑时常要用到，以前陆陆续续地看到过一些文章，但是最终留下的是破碎的代码片段和类名，所以这次重新敲一遍反射的代码，作如下记录。 上游知识注：图片出自https://www.cnblogs.com/snake-hand/p/3151381.html 注：图片来自KevinJaz（https://www.zhihu.com/question/24304289） 在代码编译后，会生成JVM（Java虚拟机）能够识别的二进制字节流文件（*.class）。之后JVM把Class文件中的类描述数据从文件加载到内存，并对数据进行校验、转换解析、初始化，使这些数据最终成为可以被JVM直接使用的Java类型。 使用场景举例我们在写java代码时，对象的引用，类的结构、方法和属性等信息都要求编译时是确切的。有时候我们无法在编译期确认这些信息，比如有两个人同时开发，第一个人写的类需要调用第二个人写的类里的方法，不巧第二个人还没写好，这时候第一个人就没法调用了。但是第一个人知道调用的方法名和参数，这些能确定，那么这时候就可以用反射。 把代码结构的确定性从编译期延迟到运行时，性能受到损害，换来了灵活性的提高。 代码实现反射实例12345678910111213141516/** * 遍历实例 * @param clazz */private static void testInstances(Class&lt;Man&gt; clazz) &#123; Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); try &#123; Object o = constructors[0].newInstance(); Object jeff = constructors[1].newInstance(&quot;Jeff&quot;, 32); println(o.toString()); println(jeff.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 12345678910111213/** * 实例化带参数类 * @param clazz */ private static void testInstance(Class&lt;Man&gt; clazz) &#123; try &#123; Constructor&lt;Man&gt; clazzConstructor = clazz.getConstructor(String.class, int.class); Man ethan = clazzConstructor.newInstance(&quot;Ethan&quot;, 28); System.out.println(ethan.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 1234567891011121314/** * 实例化类 * @param className */private static void testClass(String className)&#123; ClassLoader classLoader = ReflectionClient.class.getClassLoader(); try &#123; Class&lt;?&gt; aClass = Class.forName(className, false, classLoader); Class&lt;?&gt; aClass2 = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 反射属性123456789101112131415/** * 获取特定属性的 * @param clazz */private static void testParticularField(Class&lt;Man&gt; clazz, String fieldName)&#123; try &#123; Constructor&lt;Man&gt; constructor = clazz.getConstructor(String.class, int.class, int.class, int.class); Man kotlin = constructor.newInstance(&quot;Kotlin&quot;, 7, 180, 1); Field clothes = clazz.getField(fieldName); int clothesInt = clothes.getInt(kotlin); println(&quot;kotlin clothes = &quot; + clothesInt); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 123456789101112131415161718/** * getFields() 该类和父类所有修饰符为public的属性 * @param clazz */private static void testFields(Class&lt;Man&gt; clazz)&#123; Field[] fields = clazz.getFields(); if(fields != null)&#123; for(Field f : fields)&#123; int modifiers = f.getModifiers(); String s = Modifier.toString(modifiers); Type genericType = f.getGenericType(); Class&lt;?&gt; type = f.getType(); String simpleName = type.getSimpleName(); String name = f.getName(); println(s + &quot; &quot; + simpleName + &quot; &quot; + name); &#125; &#125;&#125; 123456789101112131415161718/** * getDeclaredFields()表示该类任何修饰符的所有属性（不包括父类中属性） * @param clazz */private static void testDeclaredFields(Class&lt;Man&gt; clazz)&#123; Field[] fields = clazz.getDeclaredFields(); if(fields != null)&#123; for(Field f : fields)&#123; int modifiers = f.getModifiers(); String s = Modifier.toString(modifiers); Type genericType = f.getGenericType(); Class&lt;?&gt; type = f.getType(); String simpleName = type.getSimpleName(); String name = f.getName(); println(s + &quot; &quot; + simpleName + &quot; &quot; + name); &#125; &#125;&#125; 12345678910111213141516/** * 给属性赋值 * @param clazz */private static void testFieldAssignment(Class&lt;Man&gt; clazz)&#123; try &#123; Man man = clazz.newInstance(); Field gender = clazz.getDeclaredField(&quot;gender&quot;); gender.setAccessible(true); gender.set(man, &quot;男&quot;); Object o = gender.get(man); println(&quot;gender = &quot; + o.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 反射方法1234567891011121314/** * 调用实例方法 * @param clazz * @param a */private static void testMethod(Class&lt;Man&gt; clazz, int a) &#123; try &#123; Man man = clazz.newInstance(); Method method = clazz.getMethod(&quot;fun&quot;, int.class); method.invoke(man, a); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 12345678910111213/** * 调用静态方法 * @param clazz */private static void testStaticMethod(Class&lt;Man&gt; clazz)&#123; try &#123; Method compute = clazz.getMethod(&quot;compute&quot;, String.class); Object o = compute.invoke(null, &quot;测试内容&quot;); println(o.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 12345678910111213141516171819202122232425/** * getMethods() 该类和父类所有public方法 * @param clazz */private static void testMethods(Class&lt;Man&gt; clazz)&#123; Method[] methods = clazz.getMethods(); if(methods != null)&#123; for(Method m : methods)&#123; int modifiers = m.getModifiers(); String s = Modifier.toString(modifiers); String name = m.getName(); Class&lt;?&gt; returnType = m.getReturnType(); Class&lt;?&gt;[] parameterTypes = m.getParameterTypes(); StringBuilder parameterSB = new StringBuilder(); if(parameterTypes != null)&#123; for(Class parameter : parameterTypes)&#123; String simpleName = parameter.getSimpleName(); parameterSB.append(simpleName + &quot; &quot;); &#125; &#125; System.out.println(s + &quot; &quot; + returnType + &quot; &quot; + name + &quot; (&quot; + parameterSB.toString() + &quot;)&quot;); &#125; &#125;&#125; 12345678910111213141516171819202122232425/** * getDeclaredMethods（） 该类所有的方法（不包括父类的） * @param clazz */private static void testDeclaredMethods(Class&lt;Man&gt; clazz)&#123; Method[] methods = clazz.getDeclaredMethods(); if(methods != null)&#123; for(Method m : methods)&#123; int modifiers = m.getModifiers(); String s = Modifier.toString(modifiers); String name = m.getName(); Class&lt;?&gt; returnType = m.getReturnType(); Class&lt;?&gt;[] parameterTypes = m.getParameterTypes(); StringBuilder parameterSB = new StringBuilder(); if(parameterTypes != null)&#123; for(Class parameter : parameterTypes)&#123; String simpleName = parameter.getSimpleName(); parameterSB.append(simpleName + &quot; &quot;); &#125; &#125; System.out.println(s + &quot; &quot; + returnType + &quot; &quot; + name + &quot; (&quot; + parameterSB.toString() + &quot;)&quot;); &#125; &#125;&#125; 改变数组123456789101112131415161718/** * 改变数组，生成新的数组 * @param obj * @param len * @return */private static Object changeArraySize(Object obj, int len)&#123; Class&lt;?&gt; componentType = obj.getClass().getComponentType(); Array.setInt(obj,2, 99); int anInt = Array.getInt(obj, 2); int objSize = Array.getLength(obj); println(&quot;anInt = &quot; + anInt); Object newArray = Array.newInstance(componentType, len); System.arraycopy(obj,0, newArray,0,objSize); return newArray;&#125; 文末详细代码上传到github上了，点击阅读原文跳转（https://github.com/Sugarya/DesignPatternCollector） 查阅的资源 JVM类加载机制详解（一）JVM类加载过程 JVM类加载过程学习总结 Java反射最佳实践 java 反射 知乎：学习java应该如何理解反射？(推荐) 深入解析Java反射（1） - 基础]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌上海办公室参观实录]]></title>
    <url>%2F2017%2F12%2F15%2F2017%2F2017-12-15%2F</url>
    <content type="text"><![CDATA[正文2017GDD的第二天，听了几场session，分别是Android Oreo兼容性，Flutter框架，Instant App，TensorFlow Lite，安卓架构组件，感觉有一些可以细细展开。 在GDD第二天，偶然认识了一名在谷歌（上海）工作的工程师，有幸应邀到环球金融中心上海谷歌办公室参观。谷歌创造了Android，Chrome，TensorFlow，它的搜索让全世界信息获取变得如此快速和简单。 环球金融中心是这样滴： 谷歌（上海）广告公司在大厦的56层，60层，61层和62层，里面有健身房，午睡间，零食间，台球乒乓球室，甚至还有电子元件电烙房。会议室带有中国式设计元素，比如围棋，书法，田园竹林。办公桌可以上下升降，站式坐式敲代码轻松切换，周围可见小憩的座椅，换个地方就能换个心情写代码了。 再说说谷歌传说中的食堂，自助的，符合中国人的口味的饭菜，也有甜点，水果沙拉自助，味道很赞，尤其是这碗鲍鱼鱼肉粥 来的时候正好赶上下午举办的离职员工分享会，分享离开谷歌后自己做了什么，有了哪些成果，可见从谷歌离职的员工依然和谷歌保持紧密的联系。办公区域每一层有一个墙面，张贴各种布告和倡议书，也有技术分享通告。我看到一则海报，人工智能科学家李飞飞和李佳在GDD开幕式前一天到这里做了内部分享。所以也有人说，谷歌像校园。 在谷歌，支持员工拿出20%工作时间做自己感兴趣的项目和事情。每个月会有一个one to one 时间，和自己的boss一对一谈话，这时候说说自己的想法也可以询问boss对自己工作的期望等等。这些方面构成了谷歌独特的文化，也是有工程师文化公司的真切的体现。 话说内部办公场景是不让拍照的，结束之前就拍几张前台的：]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Google Office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌2017GDD见闻录]]></title>
    <url>%2F2017%2F12%2F14%2F2017%2F2017-12-14%2F</url>
    <content type="text"><![CDATA[今年的谷歌开发者大会，还是盛况空前，热闹非凡。大会简单的说分为两大部分：技术分享，谷歌技术体验。 在一个小时的开幕式里，讲述了谷歌去年一年以来的发展和变化，涉及Android，Android Wear，Firebase，ARCore，Tensorflow。尤其，开幕式上谷歌Cloud人工智能和机器学习首席科学家李飞飞宣布了一个重磅消息：谷歌AI中国中心在北京成立，充分表露了谷歌对中国市场的重视。今年Tensorflow相关内容的会场异常火爆，有开发者甚至提前听上一场的分享，就是为了把座位确定下来。 不得不说，谷歌的开发者活动搞得非常酷和良心，提供免费的自助午餐还有狂欢晚宴Party，更是赠送给开发者一大波礼物 DIY音响 笔记本包 贴纸 嘉宾工牌 谷歌腾出了一块场地用以展示其新技术和酷炫的产品。今年这次体验了一遍，重点感受了Android Wear，ARCore。这两个领域都是对Android手机平台的拓展和强化，相信之后尤其是ARCore会有一轮应用的小爆发。还有个很有趣的小应用girogio cam，会识别手机拍的照片内容，然后根据这个内容创作一首音乐，交互做的特别赞。 我在玩Map Line游戏 有一个谷歌开发技术创新英雄榜，展示了国内开发者使用谷歌新技术的案例。 下午有一场半个kotlin分享，我想说：我看好kotlin的发展，这门语言对Java程序员尤其有意义，kotlin比Java 8更好的函数式支持，更具动态语言的特性，对Java程序员有更好的更平滑的思维训练和跟进。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>GDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对一路走来的学习路径的感想]]></title>
    <url>%2F2017%2F11%2F20%2F2017%2F2017-11-20%2F</url>
    <content type="text"><![CDATA[学习策略毕业多年，通信人在程序员圈混迹了4年之久。记得初入职场，技术老大和我两次的长聊中，谈话内容至今印象深刻的有两点： 一门成熟的语言一定有自举能力，即自身语言实现的编译器能解析自己 业务代码要尽快做完，业余时间里要拿80%放在计算机基础知识的学习上 当时感觉，我是一名Android 工程师，我要打造好我的产品和用户体验，要把界面做到极致。在这之前，我是80%的下班时间继续优化和提高App的用户体验上的，当下我表示赞同，但是其实并没有足够重视，这两年多来一直并没有贯彻这个学习策略 计算机的基础能力有哪些呢？ 计算机结构，操作系统，算法和数据结构，网络通信协议，设计模式，编程语言 针对特定领域的工程师，还有该领域的基础知识。比如安卓工程师的安卓基础能力：对framework的熟知，包括自定义控件所需的所有能力等等 从容与持续忘记看的哪篇文章说过，做事不可用力过猛，期望越多则失望也越多，情绪的波峰和波谷反差也会越大。学习不可用力过猛，否则容易产生焦虑，焦虑是情绪弹簧的刚度值，焦虑让情绪偏向负面的势能增大。学习亦不可过于激动兴奋，否则容易在情绪低谷时对正向情感产生更多依赖。 学习贵乎平和从容 平和从容的源泉是深信持续的力量，相信持续是走向非常的桥梁 平和从容的就近法门是？ 走路要慢，回答要慢，冥想也算吧 每天重复做一件事，有一以贯之的生活 零和，无谓的接受损失 快乐求诸己 凝思远望，从容平和]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矢量图和矢量动画]]></title>
    <url>%2F2017%2F11%2F18%2F2017%2F2017-11-18%2F</url>
    <content type="text"><![CDATA[Android 5.0（API 级别 21）及以上版本支持矢量图， 如果要在Android2.1（API 7）到Android 4.4（API 20）版本使用矢量图，需要： Gradle 的 Android 插件 2.0 或更高版本 使用support 23.2或更高版本支持 Gradle配置 123defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125; 1appcompat-v7 使用AppCompatImageView, 使用app:srcCompat 如果你的Activity直接或间接继承自AppCompatActivity，当前视图中的ImageView在编译过程中会被自动转为AppCompatImageView（support包中所有含有AppCompat前缀的控件均受相同处理），因而在Activity中通过findViewById()的实例用ImageView或AppCompatActivity接收是没有区别的。 涉及到的类：VectorDrawableVectorDrawableCompatAnimatedVectorDrawableCompat Vector Asset Studio 支持必要的标准，但并非支持所有 SVG 和 PSD 功能，如果您收到错误，应验证矢量图是否像预期一样显示 矢量图适用于简单的图标，与对应的png图像相比，矢量图首次加载时可能消耗更多的 CPU 资源，所以推荐将矢量图像限制为最大 200 x 200 dp 在很多情况下，最好将图标设置为黑色 (android:fillColor=”#FF000000”)。通过此方法，您可以为布局中放置的矢量图添加 tint 属性，图标颜色将随之变为 tint 颜色。如果图标颜色不是黑色，图标颜色可能反而与 tint 颜色较为搭配。 如果最低 API 级别为 Android 4.4（API 级别 20）及更低版本，且您未启用支持库技术，则 Vector Asset Studio 将生成 PNG 文件 适合icon图标的应用场景，不适用于频繁切换回收的应用场景，会造成卡顿，因为矢量图是不被硬件加速支持的 注意点对PathData做缩放，旋转，位移时，name名称对应矢量图标签 &lt; group &gt; 来实现的 的 android:viewportWidth 和 android:viewportHeight 就是设置画布的大小 PathData内容说明： 如果同一个命令连续用多次，那么后面命令的字母是可以省略的，例如 M 25,25 L 50,25 L 50,50，第二个 L 是可以省略的，可以写成 M 25,25 L 50,25 50,50 大写字母代表绝对路径，小写的字母代表相对路径 参考资料： Android使用矢量图（SVG, VectorDrawable）实践篇 Android矢量动画实践 SVG 的 PathData 在 Android 中的使用 Android 矢量图动画（完结篇）]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参加Hackthon是一种什么样的体验]]></title>
    <url>%2F2017%2F11%2F07%2F2017%2F2017-11-07%2F</url>
    <content type="text"><![CDATA[我和我的队友们参加了为期两天的创新马拉松比赛。我们从无到有，目标是构建一个智能穿搭的AI虚拟衣橱，产品通过App来呈现。 项目介绍 项目名称：另衣伴 我们为美代言，为爱美的你推荐穿搭。我们目标实现： 自家衣橱随手带。逛商场，遇到喜欢的衣服，拍一张，我们在衣橱里找到搭配的衣服。 线上爱衣随意试。线上要是有你喜欢的衣服，我们告诉你同款衣服最近的店铺，试穿说走就走。 衣海淘金随心荐。在京东服饰里，找到匹配虚拟衣橱里的衣服。你的选择，我都懂。 衣服在前，我们要做的就是为你节省纠结与选择的烦恼。我们负责搭配，你负责美。 最后我们做出的产品，只实现了目标（1） 数据是本地模拟的，效果图如下： 该App已开源到Github上， 召唤传送门，欢迎star 附上产品另衣伴Android App下载二维码： 整个比赛过程中，有收获更有许多感触如何快速开发一款App？一个App有几个部分组成： 第三方类库 页面基类 网络请求 项目目录和Gradle配置 页面跳转和动画 快速开发一款App，就需要对上面这五个方面有自己熟悉的解决方案和套路，同时还需要： 封装App高频的交互逻辑，抽取特定场景为组件。当App的其他页面需要使用时，用组合的方式低耦合的快速引入。 选择合适的项目组织方式，现在安卓项目架构组织方式有MVC，MVP，MVVM；小型App和小团队使用MVC即可；中大型，多人开发App项目，考虑使用MVP或MVVM。 从开源世界里找到合适的第三方类库。在实现特殊的交互时，还需要快速的理顺开源框架代码组织关系，修改部分代码来满足自己的业务需要。 这时候开发一款App，就变成了拼图游戏，把一个个App的模块（图片）／轮子拼起来即可。在拼的时候，考虑怎么拼的无缝（高性能，内存不泄漏），怎么拼的快（敏捷开发） 重复的轮子要不要再造？我的思考结果是，只要项目时间允许，就得争取造轮子，哪怕是重复的轮子，或者已经有很优秀的轮子。只有自己造过轮子，看别人家的轮子（类库）才能做到驾轻就熟，举重若轻。 RxBus／EventBus如何理解？RxBus／EventBus是事件总线，提供全局消息通信，能实现类与类的通信。 使用时要注意： 监听的生命周期，做到生命周期最小。 发送的消息专项专用。只用一个类表示一个消息，一个消息实现一个功能。 消息总线只能用于组件的间的解耦。这意味着，它适用于页面间的通信，不适合一页面内，不同成员内部的通信。比如Adapter和Fragment之间的通信就完全不必使用事件总线的方式，通过方法来通信就可以了，从整个项目组织和可维护性上看，此处使用接口通信最适宜。 技术之外比赛开始之前，有10天左右的准备时间，这期间团队内部对比赛方向产生了分歧。队伍内算法工程师认为，我们要先有个全局的把握，像写论文一样去思考，优先把产品方案和框架定出来，时间不够可以不必落地产品；而我则主张以落地产品做出App为基本前提，最后的讨论的结果是两条线并行。 现在复盘，其实这样是不好的。在只有半个月的时间，资源是相当有限的，当时就应该统一思想，以产品落地为优先。发散讨论的过程是必要的，最后队长要有意识地把讨论集中起来，这个引导和集中是队长的工作内容和职责。 在进行团队讨论时，一定要有文字记录，讨论的后期全程录音了。这个会议文档必须由队长或者是项目进度推动人或者项目全局思考人来担任。 一次讨论整理出的结论，达成的共识要作为下一次讨论的起点，上一次讨论分配出去的任务，要作为下一次讨论的基础和输入。所以，会后的任务需要完成，大家任务的完成情况会很大影响整个项目的质量。 过程中，我既要完成另衣伴App研发，也要扮演队长（项目经理）的角色，明显感觉到了自己的精力不够用，不同工作内容和性质的切换会大大增加精力的损耗。 一线研发兼职不了项目经理，但是一线技术人员可以兼职产品经理的活。我感觉，好的团队有很多种，其中有一种可以是这样的：技术人员都是极客，同时又充当半个产品经理，主动的发挥各自的创造力和主观能动性。 智能推荐穿搭，很大的难点是搭配逻辑的建立和实施，这块难度大，准备前期，队长未能果断坚定的确立并执行以寻找并借助第三方类库为方向，项目完成度被大大折扣了。只有细化的分配任务到队员身上，才是推进项目的前提。如果分配的任务做到细致和明确责任人了，遇到未完成的，为了保证项目进度和质量，队长需要顶上和有效跟进。 队伍里大家对比赛的诉求和出发点会不一致，那么这期间面对同一件事就会有不同程度的发力。理想状态是：大家的出发点和发力程度是相近的。 小结和计划感谢队伍小伙伴们的努力和付出，我们经历了一个产品从0到1的质变，在半个月内从产品方案到想法最终落地。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Hackthon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件随想录--给软件项目打个比方]]></title>
    <url>%2F2017%2F10%2F10%2F2017%2F2017-10-10%2F</url>
    <content type="text"><![CDATA[一个软件项目就像一部电影如果把Java项目工程比做一部电影，那么出品人是公司，制片人是程序员，导演和演员是项目里的所有类。 因此对类产生了一种划分方式：导演类（Director Class），角色类（Role Class）。对类里的方法产生了同样的划分：导演方法（Director Method）和角色方法（Role Method）。导演负责调用角色,角色做具体的事。 对应在方法里，导演方法里的实现即是调用角色方法或角色类，角色方法里是具体某个功能或行为的实现过程。在现实世界，存在纯粹的导演。导演方法里没有自己的逻辑实现就是纯粹的导演方法。也有自导自演的导演–导演方法里不仅有调用角色还附加有某些功能的实现过程。 对应在类里，项目中的Manager类就是导演类，工厂模式里的Factory类也是导演类，角色类就是那些被调用的类。大多数类是自导自演，对上是角色类，对下导演类。上下带来了层次性，存在顶级导演（最初的第一个导演类），高级导演（处在调用层次前列的） 我们是有好奇心的程序猿，某个恍然的时刻问自己：如果对自导自演的类不断向上追溯，最初调用在哪里发生呢？ 这真是有意思的思考。最初的调用就是Main方法，就是程序的主入口。如果我们把一段可运行的软件比做密西西比河，那么干流是导演类，支流是角色类。我们知道，主干和分支都是相对的，这个干流的分支是这个分支下的分支的干流。当我们想知道密西西比河最终流向哪里时，想要对密西西比河有一个主要的认识时，我们只要沿着密西西比河主干向前走就能找到河的出口和终点。软件项目里，找到那个主入口，沿着主入口的逻辑往下阅读。当我们想要了解某个细节时，找到主干下的对应的分支，从这个分支阅读代码。 一个软件项目代表一个二维的世界代码所在的世界是二维的世界，有横轴和纵轴。调用一个高级导演类的导演方法，形成了一个纵向世界；一个方法调用，当这个方法对类的成员变量做了修改，那么其他方法使用了这个成员变量；此时这个过程就形成了一个横向世界。 小结软件是程序员固化的思维，代码也是有味道的，当代码存在异味的时候，也即意味着重构要来临。做一个嗅觉敏感的程序猿，软件项目就会具有可读性和可维护性。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidThings之我见]]></title>
    <url>%2F2017%2F09%2F25%2F2017%2F2017-09-25%2F</url>
    <content type="text"><![CDATA[在传感器里集成Android Thing 加云处理，来收集商品数据 特性 Android things越少交互越好，只能开启&amp;安装唯一一个App，不涉及多进程，不支持动态权限申请 支持谷歌市场（play Service框架），支持firebase，采用Weave协议 支持RxJava和Kotlin编写 Android Things和Android在SDK上的区别？ 没有通知，ContentProvider 提供Android Things Console Android Things对安卓开发者的开发场景？ 硬件I／O支持：GPIO，PWM，I2C， SPI， UART，I2S。也就是说可以支持任何无线协议 上述是我参加谷歌社区Android Things分享所得。 个人的看法Android Things其实是嵌入式开发，在微型的硬件上做缩小版的Android开发，用熟悉的Android Studio，JDK，SDK。只是超瘦客户端的方式，嵌入式的设备每个都比较小，但是数量众多，为的是收集数据，上传到云服务，然后分析。大数据时代，数据都哪里来？这是未来来的数据来源之一，这个过程重点是收集到数据之后的处理，云存储，然后在服务器上的对数据加工处理，作为AI分析的前提。 小结因此，我的结论是：作为安卓程序猿，从技术成长和技能栈升级角度看，Android Things这个方向不适合。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Json序列化与反序列遇到Map时]]></title>
    <url>%2F2017%2F06%2F22%2F2017%2F2017-06-22%2F</url>
    <content type="text"><![CDATA[背景软件开发从数据的角度会经历三个阶段：获取数据，处理数据，展示数据 获取数据有如下方式： 从数据库获取， 从网络请求获取， 从本地生成业务逻辑的数据。 App客户端上，数据最初来源于后台接口，http请求获取到json字符串，json反序列化生成实体类；在这个反序列化过程中可以生成基本数据类型，JavaBean，数组，集合。集合里有List和Map，平时我们遇到反序列化情况是Map&lt;String,Object&gt;，如果需要序列化成Map&lt;Object,Object&gt;，要怎么处理呢？ Json格式的表达，是以Key：Value的形式，Key只能是字符串，Value可以是对象或者数据，Map\&lt;Object,Object&gt;中Map的键是对象，这要怎么用json表现？ 常用的Json解析库有Gson，Jackson, Fastjson。阿里的Fastjson号称解析速度最快，Jackson解析速度比Gson快，常用在服务器端。谷歌的Gson解析稳定，常在App端使用，在中小数据量解析上和Jackson性能相近。我们来看看这三个库解析的结果 正文Gson与Map\&lt;Object,Object&gt;数据准备，生成Map集合 private LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; createMap() { LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; categoryMap = new LinkedHashMap&lt;&gt;(); List&lt;CategoryEntity&gt; firstCategoryList = new ArrayList&lt;&gt;(); firstCategoryList.add(new CategoryEntity(&quot;201&quot;, &quot;全部分类&quot;, true)); categoryMap.put(new CategoryEntity(&quot;101&quot;, &quot;全部分类&quot;, true), firstCategoryList); List&lt;CategoryEntity&gt; secondCategoryList = new ArrayList&lt;&gt;(); secondCategoryList.add(new CategoryEntity(&quot;211&quot;, &quot;遥控赛车&quot;, false)); secondCategoryList.add(new CategoryEntity(&quot;212&quot;, &quot;乐高积木&quot;, false)); secondCategoryList.add(new CategoryEntity(&quot;213&quot;, &quot;泰迪小熊&quot;, false)); categoryMap.put(new CategoryEntity(&quot;111&quot;, &quot;儿童玩具&quot;, false), secondCategoryList); List&lt;CategoryEntity&gt; thirdCategoryList = new ArrayList&lt;&gt;(); thirdCategoryList.add(new CategoryEntity(&quot;221&quot;, &quot;电磁炉&quot;, false)); thirdCategoryList.add(new CategoryEntity(&quot;222&quot;, &quot;电饭煲&quot;, false)); categoryMap.put(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false), thirdCategoryList); List&lt;CategoryEntity&gt; fourthCategoryList = new ArrayList&lt;&gt;(); fourthCategoryList.add(new CategoryEntity(&quot;231&quot;, &quot;Java8函数式编程&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;美的历程&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;黑客与画家&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;代码的未来&quot;, false)); categoryMap.put(new CategoryEntity(&quot;131&quot;, &quot;自营书籍&quot;, false), fourthCategoryList); return categoryMap; } Gson的序列化和反序列示例代码： private void gsonTest() { LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String toJson = GsonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;toJson = &quot; + toJson); LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; parserMap = GsonUtil.getInstance().fromJson( toJson, new TypeToken&lt;LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt;&gt;() { }.getType()); LOG.D(TAG, &quot;fromJson = &quot; + parserMap.toString()); List&lt;CategoryEntity&gt; parseCategoryList = parserMap.get(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false)); LOG.D(TAG, &quot;parseCategoryList = &quot; + parseCategoryList.toString()); } 几点说明： 选用LinkedHashMap()，可以确保按位置顺序反序列化 GsonUtil单例模式，反序列化类型通过TypeToken来指定 序列化结果如下： [ [ { &quot;id&quot;: &quot;101&quot;, &quot;isSelected&quot;: true, &quot;name&quot;: &quot;全部分类&quot; }, [ { &quot;id&quot;: &quot;201&quot;, &quot;isSelected&quot;: true, &quot;name&quot;: &quot;全部分类&quot; } ] ], [ { &quot;id&quot;: &quot;111&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;儿童玩具&quot; }, [ { &quot;id&quot;: &quot;211&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;遥控赛车&quot; }, { &quot;id&quot;: &quot;212&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;乐高积木&quot; }, { &quot;id&quot;: &quot;213&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;泰迪小熊&quot; } ] ], [ { &quot;id&quot;: &quot;121&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;厨房用品&quot; }, [ { &quot;id&quot;: &quot;221&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;电磁炉&quot; }, { &quot;id&quot;: &quot;222&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;电饭煲&quot; } ] ], [ { &quot;id&quot;: &quot;131&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;自营书籍&quot; }, [ { &quot;id&quot;: &quot;231&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;Java8函数式编程&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;美的历程&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;黑客与画家&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;代码的未来&quot; } ] ] ] 小结： Gson序列化LinkedHashMap, 它会把Map的Key部分和Value部分放在同一层级，作为数组的元素。 Jackson与Map\&lt;Object,Object&gt;使用jackson序列化／反序列化代码： private void jackJsonTest(){ LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String json = JacksonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;jackJson = &quot; + json); LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; parseMap = JacksonUtil.getInstance().fromJson( json, new com.fasterxml.jackson.core.type.TypeReference&lt;LinkedHashMap&lt;CategoryEntity,List&lt;CategoryEntity&gt;&gt;&gt;() {}); LOG.D(TAG, &quot;parse map = &quot; + parseMap.toString()); List&lt;CategoryEntity&gt; categoryEntityList = parseMap.get(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false)); LOG.D(TAG, &quot;jackson list = &quot; + categoryEntityList.toString()); } 说明： JacksonUtil使用单例，通过TypeReference指定jackson反序列的类型 Jackson解析结果如下： { &quot;CategoryEntity{id=&apos;101&apos;, name=&apos;全部分类&apos;, isSelected=true}&quot;: [ { &quot;id&quot;: &quot;201&quot;, &quot;name&quot;: &quot;全部分类&quot;, &quot;selected&quot;: true } ], &quot;CategoryEntity{id=&apos;111&apos;, name=&apos;儿童玩具&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;211&quot;, &quot;name&quot;: &quot;遥控赛车&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;212&quot;, &quot;name&quot;: &quot;乐高积木&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;213&quot;, &quot;name&quot;: &quot;泰迪小熊&quot;, &quot;selected&quot;: false } ], &quot;CategoryEntity{id=&apos;121&apos;, name=&apos;厨房用品&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;221&quot;, &quot;name&quot;: &quot;电磁炉&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;222&quot;, &quot;name&quot;: &quot;电饭煲&quot;, &quot;selected&quot;: false } ], &quot;CategoryEntity{id=&apos;131&apos;, name=&apos;自营书籍&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;231&quot;, &quot;name&quot;: &quot;Java8函数式编程&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;美的历程&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;黑客与画家&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;代码的未来&quot;, &quot;selected&quot;: false } ] } 小结：Jackson在序列化Map时，会把Map的Key对应的对象默认解析成字符串；但是这个字符串格式不是Json的格式，通过添加自定义Map的键的序列化解析类和反序列化解析类，可以实现对CategoryEntity对象Json序列化／反序列化 public JacksonParser() { mObjectMapper = new ObjectMapper(); SimpleModule simpleModule = new SimpleModule(); simpleModule.addKeyDeserializer(CategoryEntity.class, new MapKeyDeserializer()); simpleModule.addKeySerializer(CategoryEntity.class, new MapKeySerializer(CategoryEntity.class)); mObjectMapper.registerModule(simpleModule); } Fastjson与Map\&lt;Object,Object&gt;Fastjson序列化和反序列示例 12345private void fastJsonTest() &#123; LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String s = FastJsonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;fastJson = &quot; + s);&#125; 说明： 单例FastJsonUtil，通过TypeReference来指定反序列化类型 解析结果 { {&quot;id&quot;:&quot;101&quot;,&quot;name&quot;:&quot;全部分类&quot;,&quot;selected&quot;:true} :[{&quot;id&quot;:&quot;201&quot;,&quot;name&quot;:&quot;全部分类&quot;,&quot;selected&quot;:true}], {&quot;id&quot;:&quot;111&quot;,&quot;name&quot;:&quot;儿童玩具&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;211&quot;,&quot;name&quot;:&quot;遥控赛车&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;212&quot;,&quot;name&quot;:&quot;乐高积木&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;213&quot;,&quot;name&quot;:&quot;泰迪小熊&quot;,&quot;selected&quot;:false}], {&quot;id&quot;:&quot;121&quot;,&quot;name&quot;:&quot;厨房用品&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;221&quot;,&quot;name&quot;:&quot;电磁炉&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;222&quot;,&quot;name&quot;:&quot;电饭煲&quot;,&quot;selected&quot;:false}], {&quot;id&quot;:&quot;131&quot;,&quot;name&quot;:&quot;自营书籍&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;231&quot;,&quot;name&quot;:&quot;Java8函数式编程&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;美的历程&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;黑客与画家&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;代码的未来&quot;,&quot;selected&quot;:false}] } 小结：fastjson序列化Map，生成的字符串不是json格式，Key部分直接序列化成对象。通过{}:[]这种格式来表现Map\&lt;CategoryEntity,List\&gt;的key和value。 小结开发中，较少会遇到需要序列化Map\&lt;Object,Object&gt;，即使遇到了也可以通过改变实体类的数据结构来规避这种解析，把Key的Object对象放入到Value的对象里，组成新的实体类，而Map的Key用String来表示。因此，本例的Map\&lt;CategoryEntity,List\&gt;,可以把Map的Key部分的对象Category放入到List集合的里。这样，在某些场景，把二维层面的数据，降为一维数据，通过链式的调用来获取原来二维的数据，把数据维度转化成了链式调用的深度。 示例代码上传到Github上了，欢迎Star，传送门]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8函数式编程--编程范式的趋势]]></title>
    <url>%2F2017%2F06%2F16%2F2017%2F2017-06-16%2F</url>
    <content type="text"><![CDATA[让我们来说说函数式编程–Lambda表达式 上周开始，看了这本书–Java 8 函数式编程，以下是我的读书摘抄。 背景知识：函数接口：只有一个抽象方法的接口 方法签名：由方法名+形参列表构成+返回值类型。JVM是并没有特别明确的将数据类型写出来，而是提供了特殊的表示法。 惰性求值方法： 只描述Stream，不产生实际执行的方法 及早求值： 立刻执行 函数的副作用：当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响（例如修改全局变量或修改参数） 纯函数：输入输出数据流全是显式的（显式的含义是：函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部） 非纯函数：与纯函数相反，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如，读取全局变量，修改全局变量。 阿姆达尔定律：对于固定负载情况下描述并行处理效果的加速比s，S=1/(1-a+a/n)，其中a为并行计算部分所占比例，n为并行处理结点个数 正文Lambda表达式在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值 Lambda表达式 传入一段代码块 不需要显式声明／指定参数类型（编译器可以通过方法签名来推断类型） Lambda表达式引用的局部变量必须是final或既成事实上的final变量（基本类型只能赋值一次，对象的引用不能改变） Stream API意义和创新：遍历从外部迭代变成了内部迭代。把程序扮演Director导演类的部分逻辑和操作提取、转移到了类库中 实现机制Stream操作分为惰性求值和及早求值；形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。 整个过程被分解为多个惰性求值操作和一个单个及早求值操作，而这些多个操作只需要遍历一次。整个过程和建造者模式有共同之处。建造者模式使用一系列操作来设置属性并配置，最后调用build方法，这时，对象才被真正创建。 常用的流操作collect：流生成集合 map：改变流中元素的类型 flatMap：把最初流中的一个元素转成一个流 filter：过滤流中的元素 Max/Min：求极值，返回 Optional （涉及比较器类Comparator，因为比较意味着排序，排序意味着需要一个排序的指标） reduce Lambda表达式正确使用姿势1）明确要达成什么转化，而不是说明如何转化2）写出的函数尽量没有副作用纯函数的优点 无状态，线程安全。不需要线程同步。 纯函数相互调用组装起来的函数，还是纯函数。 可缓存结果，原生支持并行（不懂） I/O API可以看作是一种特殊的全局变量。文件、屏幕、数据库等输入输出结构可以看作是独立于运行环境之外的系统外全局变量，而不是应用程序自己定义的全局变量。 类库装箱类型在Lambda表达式上的体现 int整型在内存中占用4个字节，Integer在内存中占用16字节； 基本类型和装箱类型相互转化需要额外的计算开销 在Java中想要一个包含整型值的列表List,实际上得到的却是一个包含整型对象的列表List； 对于需要大量数值运算的算法来说，由于上述的原因，减缓了程序的运行速度 因此，Stream类的某些方法对基本类型和装箱类型做了区分；Java 8对整型，长整型和双浮点型做了特殊处理；方法有：mapToLong(),MapToInt(); Lambda表达式的重载Lambda表达式的类型就是对应的函数接口类型。遇到重载时调用准则： 优先执行最具体的类型 如果最具体的类型有多个，则需要认为指定类型 默认方法Java 8新增一个关键词default，在接口中，可以存在由default修饰的默认方法（也就是说，Java 8接口里，不再只能是抽象方法，具体的方法也可以存在即默认方法；同时，也允许存在静态方法），当子类不实现这个接口的某个抽象方法时，子类就是使用该默认方法。 还要注意一点：一个类要实现的接口里，存在默认方法和它父类的方法相同，则优先选择父类定义的方法。 归纳出两条简单的定律： 类胜于接口。如果在继承链中有方法或抽象方法声明，那么久可以忽略接口中定义的方法 子类胜过父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认的方法，那么子类中定义的方法胜出。 Optional该新的数据类型，用来替换null。Optional对象相当于值的容器，类似ThreadLocal用法 创建Optional对象：Optional.of() 获取值：get(); 获取可能存在的空值：empty(). 判断Optional对象理是否有值：isPresent(); orElse(T t),当Optional对象为空时，提供一个备选值t orElseGet(Supplier supplier):当Optional对象为空时，调用这个函数接口 特殊的修饰@FunctionalInterface该注释会强制javac检查一个接口是否符合函数接口的标准（一个接口，只有一个抽象方法），如果该注释添加给一个枚举类型，类或另一个注释，或者接口含不止一个抽象方法，javac就会报错（编译的时候）。重构代码时，使用它能很容易发现问题。 高级集合类方法引用本小节摘自【译】Java 8的新特性—终极版 方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 西门的例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。 public static class Car { public static Car create( final Supplier&lt; Car &gt; supplier ) { return supplier.get(); } public static void collide( final Car car ) { System.out.println( &quot;Collided &quot; + car.toString() ); } public void follow( final Car another ) { System.out.println( &quot;Following the &quot; + another.toString() ); } public void repair() { System.out.println( &quot;Repaired &quot; + this.toString() ); } } 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。 final Car car = Car.create( Car::new ); final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create( Car::new ); cars.forEach( police::follow ); 数据并行化并发，并行；数据并行化；任务并行化 调用parallelstream()／parallel(),生成一个并行化流 收集器Collectors.toList()，Collectors.toSet,Collectors.to 调试Lambda表达式对于业务稳定，生命周期较长的产品，可以引入单元测试。 程序员写出的程序bug，有两种： 实现业务逻辑的思路错误 实现业务逻辑的思路对了，但是在实现过程中出了问题，开发者设想的过程和真实的情况不同。 软件产品种，大部分bug来源于第二种。我们对单元测试，下一个定义：单元测试是测试一段代码的行为是否符合预期的方式。我们对每一个方法输出结果都存在一个预期，这个预期是我们在实现业务过程中的一个环节，这些环节全部累加起来，每个环节的结果都是我们想要的，那么这个业务我们就能正确的实现了。因此，单元测试，能检测出第二种bug； 对重构Lamdba表达式的思考如果存在多个方法，每个方法的处理过程相同，输入输出类型相同，不同的是操作的具体逻辑，则可以把相同的操作提取成新的方法，不同的操作通过方法入参来体现。比如下面两个方法： 计算音乐家数量 public long countMusicians(){ return albums.stream() .mapToLong(albu -&gt;.getMusicians().count) .sum() } 计算单曲数量 public long countTracks(){ return albums.stream() .mapToLong(albu -&gt;.getTracks().count) .sum() } 要怎么重构呢？ 首先我们定义一个函数接口，输入Album类，输出一个long型, 引入泛型（Java 8其实已经定义了这种输入输出的接口了） public interface ToLongFunction&lt;T&gt;{ long applyAsLong(T value); } 我们知道，Lambda表达式返回类型是函数接口，因此上述的两个方法就可以重构成下面的样子 public long countMusicians(){ return countFeature(ablum -&gt; album.getMusicians().count()) } public long countTracks(){ return countFeature(ablum -&gt; ablum.getTracks().count()) } private long countFeature(ToLongFuction&lt;Album&gt; function){ return albums.stream() .mapToLong(function) .sum(); } 整个思考过程，和非函数式编程是类似的。 对惰性求值方法的调试Java 8 提供了一个方法peek()，举个例子 Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .peek(e -&gt; System.out.println(&quot;Peeked value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList()); 这样就能对流的每一个元素处理的先后值的变化进行观察了]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浪潮之巅--站在时代的潮前企业]]></title>
    <url>%2F2017%2F06%2F05%2F2017%2F2017-06-05%2F</url>
    <content type="text"><![CDATA[前段时间看了吴军老师的浪潮之巅，做些简单的笔记摘抄，记录如下 前言比尔盖茨语录： 我们总是高估未来两年的变化，却低估未来十年的变化。不要让自己无所作为。 任何在商业世界应用的技术，首要准则即是，自动化只有应用在一项有效率的业务上面时才会把效率放大。第二点准则，自动化应用在一项低效的业务上时只会让效率更低。 在IT领域，当你意识到自己有麻烦的时候一切已经太晚了，想救自己已经来不及了。除非你整日在恐慌中忙碌，否则就会被淘汰。 IT产业三大定律摩尔定律（反摩尔定律），安迪-比尔定律，诺威格定理 摩尔定律晶体管的数量每18个月翻番,芯片的性能每隔18个月翻番一次. 有趣的是，还有一个叫反摩尔定律。该定律由Google的前CEO埃里克·施密特提出，即：一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。这要求硬件公司的产品需要快速迭代，电子产品的迭代周期至多是一年半。比如手机领域，华为，小米，锤子，三星等厂商每年都必须发布至少一款新机的。 安迪-比尔定律安迪指英特尔前CEO安迪·格鲁夫，比尔指微软前任CEO比尔·盖茨 定律内容：Andy gives, Bill takes away（安迪提供什么，比尔拿走什么）。 言外之意是硬件提高的性能，很快被软件消耗掉了。这也解释了人们为什么要不断地更新自己的硬件 诺威格定理当公司的市场占有率&gt;50% ，市场占有率无法再翻番了。这句话很直白的话道出许多大公司兴衰的根源：在一个市场占主导地位的公司必须不断开拓新财源，才能长盛不衰。 为什么一家公司转型就那么难呢？一个在某个领域特别成功的大公司已经被优化得非常适应这个市场，它的文化，做事方式，商业模式，市场定位已经甚至过分适应传统的市场。这些使得该公司获得成功的内在因素会渐渐地，深深地植入该公司。就好比一个已经开始养尊处优的40岁的人重新走入课堂，去和一群20岁的年轻人在一起从头开始读书，学习起来比没有负担的年轻人要难得多。更何况，年轻的公司没有退路只有向前进，而成熟的公司总有它传统的业务可以依赖，一旦遇到问题就可能退缩 书中举了例子：以大型机、系统和服务为核心的IBM公司很难在PC市场上成功；微软MSN部门十几年了还不能盈利。 科技公司的上市过程科技公司的经营业务是科技产品和服务，而不是证券，所以它不能自己到证券交易所去兜售自己的股票，要交给承包商。承包商（比如高盛，摩根斯坦利这样的公司）从被承包的公司收购特定数量的股票，并且以同样的价格分配给它们的客户，能获得两笔收入：1.佣金 2.融资7%的股票金额 科技公司找到一家合适的承包商，弄清三件事 上市时市值多少 上市时融资多少 确定给承包商的佣金和今后的期权多少]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一分钟带你了解2017 Google I/O大会内容]]></title>
    <url>%2F2017%2F05%2F18%2F2017%2F2017-05-18%2F</url>
    <content type="text"><![CDATA[北京时间2017年5曰18日凌晨01点钟，2017年Google I/O大会如期举行（ Google I／O大会的IO的含义：Input/Output &amp; Innovation in the open），第一场keynote大体分为如下三个部分： Google Home &amp; Google LensGoogle Home在去年谷歌大会上会首次展示，今年新增了语音电话（ Hands Free Calling）等更新 对Google Photos和Youtube这两个App加入了AI功能，新增不同情景下的预测和回应，而且能文字搜索出对应的图片。有一个比较大的点是对IOS系统开放了google Assistance. 人工智能集中体现在Google Lens，它基于视图形识别技术，能根据相机取景进行智能识别，然后分辨出图像里的信息内容，还能和Google Assistant联动。 Android部分Android O Developer Preview（预览版），本次大会并没有像往常那样公布最终的版本号，预测的奥利奥的缩写暂时还没有答案。 本次android新版本，加强了权限和电池使用，系统层面支持画中画（Picture-in-Picture），还有一些零散的体验优化，比如：对通知栏也做了一些更新；简化对文本选择操作；2倍的开机速度 谷歌官方支持了Kotlin开发Android App，这对App开发将带来很大的影响,kotlin能带给开发者更高效的开发效率。早在两三年前，安卓届的大神Jake Wharton就开始涉及Kotlin编程，并开源了好几个kotlin写的类库。作为Android开发者，是时候考虑如何学习kotlin了。 VR/AR 听这部分内容时，人已犯困，只记得个大概。 Daydream ，vive, coming in late 2017 Tango; visual positioning service; Expeditions; 小结不难发现，尽管Android仍然是I／O大会的主角，但已不再成为唯一的主角，人工智能和虚拟现实被谈及得越来越多，相信未来相关的硬件就会大范围的出现在我们生活中，比如虚拟眼镜，各种可穿戴的智能硬件。 最后，借用Google CEO Sundar Pichai一句话：Mobile first to AI first，AI First将会成为未来google的基调。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[松本行弘眼里的代码未来]]></title>
    <url>%2F2017%2F04%2F21%2F2017%2F2017-04-21%2F</url>
    <content type="text"><![CDATA[代码的未来，松本行弘在2013年所著，该书对云计算、大数据时代下的各种编程语言以及相关技术进行了剖析，并对编程语言的未来发展趋势做出预测。 以下是我阅读这本书的笔记摘抄，这本书能提高程序员的素养。 第一章对摩尔定路的局限的思考在不远的将来，会出现一些因素，对摩尔定律的继续生效构成障碍 最近的LSI（大规模集成电路）的宽度已经缩小到只有数十纳米，只能排列几个原子，这样在原子尺度上来制造电路是相当困难的 LSI中的电路是采用一种印刷技术印上去的，光的波长成了问题，如果图像的尺寸比光的波长还小，就无法清晰地转印。可见光的波长范围约为400-800nm，因此最近45nm制造的LSI是无法用可见光制造的，而是使用X光代替 在这种原子尺寸的电路中，保持绝缘也是相当困难的。电流通过了原本不该通过的地方，这种漏电流还会引发发热，LSI越来约精密，其密度也越来越高，热密度也随之提高，如果没有充分的散热措施，连LSI本身都会溶化 漏电流和热密度等问题，CPU的性能提高遇到了瓶颈。多CPU化，内存容量增大，SSD硬盘会成为主流，真正的并发编程也会成为主流 算命先生预言的原理1.2节 巴纳姆效应（福勒效应）每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人 冷读术（cold reading）：通过观察对方的言行举止中的一些细微之处来进行揣测，了解到他人的心理活动。像福尔摩斯对他的委托人所运用的那种技巧差不多。 热读术（hot reading）：通过事先对对方进行详细的调查，藉时机说出对方的情况，此时就会显得神奇无比。 IT未来之预测未来应该是位于过去到现在这个方向的延长线上 从价格看未来 普通人所能拥有的计算机性能将比现在大大提高 现在还没使用计算机的地方，以后都会安装上计算机 从性能看未来看看现在的超级计算机，再过20年，就是现在的一般般的配置了，比如数万CPU，数十万核心配置会成为普遍 基于这样的环境，编程又回编程什么样子呢？为了充分利用这么多的CPU，软件开发又会如何进化呢？未来的编程语言应该在如何利用CPU资源这个方面进行争夺，并行处理的功能。 从容量看未来在不久的将来，由超高速低容量的核心内置缓存，高速但断电会丢失数据的主内存（RAM），以及低速但可永久保存数据的外部存储器（HDD）所构成的结构将会消失，取而代之的可能将是由大规模的缓存，以及高速且能永久保存数据的内存所构成的新层次结构。相应的依赖过去存储结构的数据库系统将产生大规模的结构改革。 从带宽看未来1G bit／s的上网服务已面向某些国家的家庭推出了 在性能和带宽寻求平衡的过程中，网络彼此两端的系统构成也会像钟摆一样摇格不停，随着每次钟摆的来回，系统的规模，拓展性和自由度都能够得到提高。 第二章 编程语言的世界世界上第一位程序员实际上是一位女性 机器语言就是一串数字，将计算机的步骤从指令表中查出对应的机器语言编码，再人工写成数列。（机器语言和CPU执行之间至少还有一层：指通过指令表找到并输入对应的机器语言，机器就能执行一条条指令，指令让机器产生计算和处理） 查表这种工作本来应该是计算机最擅长的，人们用更加容易记忆的指令（助记符）来代替数值，并开发了一种能够自动生成机器的语言程序，这就是汇编器。汇编器用来解释汇编语言的程序，汇编语言中所使用的助记符和计算机指令是一一对应的关系。 也就是说汇编语言是由编程者自己的需要发明出来的 编程语言的进化进程看，一个显著的关键词就是“抽象化”。随着抽象化的不断深入，程序员即便不去关心内部的详细情况，也可以编写出程序。人类一次所能掌握的概念的数量，有说法称，大部分人一次只能驾驭5到9个左右的概念。抽象化程序高的编程语言不必描述详细过程，从而可以用简短的代码达到目的。 我的思考： 语言的发展：机器语言－－》汇编语言－－－》高级语言（比如Java，Python），现在几乎程序员都处在使用高级语言上；高级语言经过编译器执行编译处理转化成汇编语言，再经过汇编器和链接器进行汇编和链接处理转化成机器语言，被计算机执行。而现在，编译器和汇编器和链接器都已经很成熟了，程序员在高级语言阶段写代码就可以了 一方面，汇编语言虽然速度快，但是在工业化领域，一个系统用汇编语言，代码量将是极为庞大的，我推测有百万行的代码了。而高级语言，可能只有不到一万行。另一方面，编译器和汇编器非常完善了，引入了很多机制，保证最好的还原。同时，在现在CPU 达到2GB的能力下，高级语言编写的代码带来的损耗完全可以被忽略 未来编程语言格雷厄姆主张，100年后的编程语言的进化主线应该是以最少量公理为基础的“拥有最小最简洁核心的语言”，在现有编程语言中，最具有这一特征的莫过于他最喜欢的Lisp了，Lisp是100年后编程语言的进化方向。 松本行弘认为，编程语言的进化动机，不是工具和语言本身的简化，而是将通过这些工具和语言所得到的结果更简洁地表达出来。抽象化的趋势会一直持续下去 100年后的编程语言有这三种可能： 可能性1：变化不大 可能性2: 使用编程语言来编程这个行为本身不存在了，通过人机对话等方式 可能性3: 发明了更高抽象度的编程语言。是比现在更加强调what，而对如何解决问题的how部分的细节，则不需要人们去过问。 20年后的编程语言： 编程语言本身不会发生多大的变化，实际上现在使用的很多语言，在20年前就已经存在了。 20年后的语言，应该是在分布处理和并行处理功能上进行强化，使得开发者不需要特别心思就能使用这些功能。 线程，RPC（远程过程调用）等显式地使用分布处理和并行处理的形式，早晚会遇到瓶颈，当核心数超过数千个的时候，显式地指定就变得毫无意义了。未来的编程无需显式操作就能实现分布处理和并行处理。 DSL（特定领域语言）所谓DSL（Domain Specific Language），是指利用为特定领域所专门设计的词汇和语法，简化程序设计过程，提高生产效率的技术。是对特定目的的小规模语言的称呼。 DSL的优势：拥有为特定领域所设计的词汇，可以在高级层面上编写代码，节约程序开发的时间。即，不涉及对象领域的内部详细，而是在高级层面上进行描述。 外部DSL由专用语言引擎来实现的DSL，称为外部DSL。比如，数据库访问使用的SQL就是一种典型的外部DSL。正则表达式用来描述字符串模版，也是一种外部DSL。 外部DSL的优点：它独立于编程开发所使用的语言之外，在不同语言中都可以使用。实际上是全新设计的语言和语言引擎，不必被特定的执行模块和现有语言的语法所左右。 内部DSL不是创造一种新的语言，而是在现有语言中实现DSL，而作为DSL基础的这种现有语言称为宿主语言。Lisp，Smalltalk，Ruby这些语言适合作为DSL的宿主语言。 内部DSL的优点：内部DSL借用宿主语言的语法，在理解内部DSL含义时，宿主语言的常识依然有效，可以使用宿主语言所具备的全部功能。 元编程程序在运行过程中，本身的信息可以被访问和操作，就是元编程。程序由数据结构和算法构成，如果环境允许程序本身作为数据结构来操作的话，那么元编程也就和面向一般数据结构的一般操作没什么两样了。 内存管理与GC根判断对象是否可被引用的起始点 GC算法标记清除（Mark and Sweep）从根开始将可能被引用的对象用递归的方式进行标记（通过对象内部的标志来实现），将没有标记的对象视为垃圾进行回收。标记清除原理详细介绍 缺陷： 每次清除都需要全局扫描一次，当在分配大量对象时，只有一小部分存活的情况下，所消耗的时间会大大超过必要的值。 垃圾收集后有可能会造成大量的内存碎片 标记压缩将没有标记的垃圾对象不断压缩 优点：能够有效的缓解标记清除算法回收对象造成的内存碎片问题 缺陷：它引入了额外的开销，比如说额外的空间来保存迁移地址，需要遍历多次堆内存等 复制收集将从根开始被引用的对象复制到另外的空间中，然后再将复制的对象所能够引用的对象用递归的方式不断复制下去。如果旧空间里都是垃圾对象，能一次性回收该旧空间 优点：和标记压缩相比，它不需要遍历堆内存那么多次，节约了时间缺陷：可用堆内存减少了一半 引用计数方式在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减一般发生在变量赋值，对象内容更新，函数结束（局部变量不再被引用）等时间点。当一个对象引用计数为0时，则说明它将来不会再被应用。 优点： 对象不再被引用的瞬间就会被释放 释放操作是针对每个对象个别执行，GC产生的中段时间比较短 缺点： 无法释放循环引用的对象 必须在引用发生增减时对引用计数作出正确的增减，如果漏掉了某个增减，就会引发很难找到原因的内存错误。 引用计数管理不适合并行处理 分代回收（Generational GC）对分配不久，诞生时间较短的年轻对象进行重点扫描，可以更有效地回收大部分垃圾。对所有涉及修改对象内容的地方进行保护，称为写屏障。 刚刚生成不久的年轻对象划为新生代，存活时间较长的对象划为老生代。 全部区域对象GC操作称为完全回收；只扫描新生代对象的回收操作，称为小回收（Minor GC）；将从老生代对新生代的引用记录在一个叫做记录集的表中，在执行小回收的过程中，这个记录集也作为根对待。 缺点： 最大中断时间没有得到改善 增量回收对实时性要求很高的程序中，比起缩短GC的平均中断时间，往往更看重GC的最大中断时间。GC操作细分成多个逐一执行。 写屏障：已经完成扫描和标记的对象被修改，对新的对象产生了引用，这个新对象就不会被标记，明明存活的对象却被回收掉。 并行回收原有的程序运行的同时进行GC操作，用写屏障对当前的状态信息保持更新。不过，让GC操作完全并行，而一点都不影响原有程序的运行，是做不到的，在GC操作的某些特定阶段，仍然需要暂停原有程序运行 任何一种GC算法，都是跟踪和引用计数回收两种思路的组合。 为什么需要引入异常处理 C语言，if-else方式，通过返回整数，实现繁琐 有多处同样的错误，则要重复实现 闭包函数对象：将函数作为值来利用的方法 闭包：在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。被封闭起来的变量的生命周期与封闭它的函数对象生命周期相同 对象是在数据中以方法的形式内含了过程，而闭包则是在过程中以环境的形式内含了数据 动态与静态改善JavaScript性能的技术： JIT（Just In Time） 特殊化；对高频的特殊条件下，运行高速版本的代码 JavaScript是目前最快的动态语言 无论任何程序，或多或少都包含了动态的特性。 动态的编程语言，动态部分主要指运行模式和类型；动态运行模式就是运行中的程序能够识别自身，并对自身进行操作。动态类型有且只有数据拥有类型，静态类型是数据拥有类型，存放数据的变量，表达式也拥有类型，且类型在编译时固定。 动态类型优点： 1.简洁；即少了类型描述的代码和减少与算法本质无关的代码分量2.灵活性高；少了类型带来的制约 静态类型优点： 1.程序中对类型的描述，可以帮助对程序的阅读和理解 2.编译时确定类型，比较容易发现bug，对于这一点，程序中的bug大多数其实是与逻辑有关的，单纯类型错误而导致的bug是少数的。 Duck TypingIf it walks like a duck and quacks like a duck, it must be a duck. 隆重推出鸭子类型，如果某个对象的行为和鸭子一模一样，那无论它真正的实体是什么，我们都可以将它看做一只鸭子。不考虑某个对象到底是哪一个类的实例，只关心其拥有怎样的行为。 小结松本行弘的代码的未来一书还有其他有趣的内容，我想每个程序员都需要知道未来编程是什么样子，知道如今的编程语言正在朝哪些什么方向发展，Go，Lua，Dart这些语言有哪些设计差异。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊安卓App里的搜索]]></title>
    <url>%2F2017%2F03%2F26%2F2017%2F2017-03-26%2F</url>
    <content type="text"><![CDATA[安卓App里，搜索是一个常用功能，是开发中高频需求。借着在公司技术分享的契机，我们一起聊聊那些年我们开发过的搜索栏。 本文分为两大部分：1. 搜索栏的产品逻辑 2. 搜索交互的代码实现。（如果对搜索栏产品逻辑不感兴趣，可以直接跳到第二部分阅读） 产品经理篇没有系统的论述搜索栏的交互体系和生命周期，而是尝试通过回答以下三个问题来表达我对搜索栏的理解 什么时候需要搜索栏对于用户来说，用户喜欢点击、长按、滑动、拖拽，而不喜欢输入；搜索需要用户打字输入。另一方面，并不是任何阶段的App都需要搜索栏 当列表不够用时搜索是为了提供用户快速获得他们最想要的数据内容，当总的数据量很少时，直接列表展示所有数据即可。 比如一款旅行类的App，提供各个城市的景点，美食，商城的攻略和介绍。最初，这家初创的互联网公司只提供国内城市， 用户想要查看的各个城市的景点，直接通过滑动城市列表找寻 如果列表展示不够了，考虑在App里增加搜索栏。 当一种元素分类不够用时随着这家旅游公司的成长，它能提供的国内城市由最初的十个不到，增多到的几十个，列表展示这几十个城市已经不合适了，这时候需要对城市进行分类。比如按城市名首字的字母表排序分类，比如按城市所在区域分类。通过分类，每个类别下只有若干个城市名，用户就能快速找到想要的数据。 如果一种分类展示不够用了，考虑在App里增加搜索栏 多种维度分类不够用时这家旅游公司发展迅速，不仅能提供国内的城市，还提供国外城市，比如美国，欧洲等旅游城市，城市名增加到了上千个，这时候需要从之前的一种分类变成多种维度分类。按区域划分变成按五大洲分类，每个州按国家二级分类，每个国家按城市首字字母表三级分类。 如果多级分类不够用了，考虑在App里增加搜索栏 用户搜索时都在想什么搜索速度用户输入关键词查询，能接受的等待时间是有一个范围的，当超过这个范围，用户就会明显感受到等待，这个时间大体为一秒。另一方面，在搜索的时候吸引用户注意力能让用户的时间感知降低，比如引入加载的动画，立刻展示预置的通用图案和内容等 查看关心的信息用户之所以搜索，就是想找到自己想要的搜索内容。这个搜索结果的构成，可以根据App的特性和下一个交互流程来决定。 还是以上文提到的旅游App为例，用户搜索城市，想要知道这个城市好玩的景点，好吃的美食，搜索的结果就需要体现这个城市的景点和美食。这家旅行App的的盈利方式之一是提供车票预订服务，那么搜索结果可以提供跳转到去往该城市的机票或火车票的下单页面。 搜索结束，用户接下来要做什么一旦搜索结束，就意味着下一个交互流程的开始。给用户什么新的交互流程，根据两个方面吧： 延续搜索交互分析App运营数据，分析用户高频的行为，用户搜索的心理活动，对于搜索结果，用户希望获得什么内容。通常是支持用户点击进入详情。比如城市名搜索完，点击进入城市详情页，详细展示该城市的景点和美食 提供新的流程这部分需要结合App的产品定位和业务需求。 依然拿上文那家旅游公司为例，该公司后期提供了车票下单服务，提供用户和当地城市导游一对一聊天提问的服务。在App里，底栏Tab有四个：“城市”，“车票”，“聊天”，“我的” 这时候搜索到的城市结果展示，就需要提供点击跳转到该城市的车票下单页面，以及点击进入和当地导游聊天的页面 参考资料 搜索产品功能浅谈 设计搜索栏，你遵守这五条原则了吗？ 程序员篇有了搜索栏产品经理篇所述的认识，开发搜索栏的意义和方向和产品经理感同身受，对UI交互要求有了共鸣 Gmail搜索交互效果 上面是谷歌邮箱App搜索的交互效果，如何实现这个UI效果？ 实现这个效果，有三个步骤 有两层标题栏，前层是一个toolbar，背后的自己写的布局 当点击前层搜索，让后层的布局显示，前层的布局不显示 实施搜索动画，让背后的布局淡入显示出来，返回时则是上述的逆过程 步骤一toolbar的使用有规范，自制的布局这里也不详诉了 步骤二如果两个布局，一个显示，一个隐藏，通常会想到setVisible()方法来控制，这里提供另一种思路:View对象里，有一个方法bringToFront()，能改变子View在父容器位置顺序，改变了位置，就能改变前景的显示了。API文档对bringToFront的介绍如下： bringToFront() Change the view&apos;s z order in the tree, so it&apos;s on top of other sibling views. 步骤三上图看到，点击搜索图标后，标题栏和状态栏从红色变成了白色，这里涉及到如何代码改变状态栏，淡入和后退键标题栏谈出用到了属性动画 核心代码如下： private void reactionToClickSearchAction() { View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); getWindow().setStatusBarColor(getResources().getColor(R.color.status_bar_gray)); } ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mLlSearchBar, &quot;alpha&quot;, 0, 1); objectAnimator.setDuration(300).setInterpolator(new FastOutSlowInInterpolator()); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); mIsShowSearch = true; mEdSearch.requestFocus(); KeyboardUtils.showSoftInput(mEdSearch, GMailMainActivity.this); } }); objectAnimator.start(); } @Override public void onBackPressed() { if (mIsShowSearch) { mEdSearch.clearFocus(); KeyboardUtils.hideSoftInput(mEdSearch, this); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mLlSearchBar, &quot;alpha&quot;, 1, 0); objectAnimator.setDuration(200).setInterpolator(new FastOutSlowInInterpolator()); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); } }); objectAnimator.start(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); getWindow().setStatusBarColor(getResources().getColor(R.color.colorPrimaryDark)); } mIsShowSearch = false; return; } super.onBackPressed(); } Google Play搜索交互效果 上面是Google Play子目录页搜索的交互效果，这个交互效果怎么实现呢？ 会发现它和Gmail的交互很像，不同的之处有两点： 点击搜索的动画不同，Google Play的动画不是淡入而是像水波纹一样展开的 状态栏颜色不改变 如何让一个布局水波纹似地展开呢？从API 21 android5.0 棒棒糖版本开始，安卓提供了一个方法ViewAnimationUtils.createCircularReveal() static Animator createCircularReveal(View view, int centerX, int centerY, float startRadius, float endRadius) Returns an Animator which can animate a clipping circle. 那么在5.0以下的版本怎么办，除了自己实现这种效果外，github上已经有人开源了ozodrukh/CircularReveal 核心代码如下： /** * 点击搜索 */ private void reactionToClickSearchAction() { mShowSearchToolbar = true; View childView = mRevealFrameLayout.getChildAt(0); childView.setVisibility(View.VISIBLE); childView.bringToFront(); int centerX = childView.getRight(); int centerY = childView.getBottom() / 2; Animator circularReveal = ViewAnimationUtils.createCircularReveal(childView, centerX, centerY, 0, childView.getWidth()); circularReveal.setDuration(300).setInterpolator(new LinearInterpolator()); circularReveal.start(); circularReveal.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); reactionToCover(true); mEdSearch.requestFocus(); KeyboardUtils.showSoftInput(mEdSearch, GplayMainActivity.this); } }); } private boolean reactionToBackPressed() { if (mShowSearchToolbar) { KeyboardUtils.hideSoftInput(mEdSearch, this); View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); int centerX = childView.getLeft(); int centerY = childView.getBottom() / 2; Animator circularReveal = ViewAnimationUtils.createCircularReveal(childView, centerX, centerY, 0, childView.getWidth()); circularReveal.setDuration(300).setInterpolator(new DecelerateInterpolator()); circularReveal.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); reactionToCover(false); } }); circularReveal.start(); mShowSearchToolbar = false; return true; } return false; } public void reactionToCover(boolean isDark){ if(isDark) { mFrameBodyCover.setVisibility(View.VISIBLE); }else{ mFrameBodyCover.setVisibility(View.GONE); } } 小结上述代码已提交到Github:SearchBarDemo，欢迎star。 参考资料 深入浅出搜索系列之（一）- 初识搜索&amp;version=11020201&amp;pass_ticket=yWwF3qj71PEzLDT%2F02c0%2FFTzD6F%2BT41pTSgxYv5QasYtOCUo42uJXEMTPrVjbiiz) Material Design中全新的动画 深入理解Android L新特性之 页面内容&amp;共享元素过渡动画 Github:ozodrukh/CircularReveal]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异类：一万小时练习的力量]]></title>
    <url>%2F2017%2F03%2F12%2F2017%2F2017-03-12%2F</url>
    <content type="text"><![CDATA[异类 一书由马尔科姆（Malcolm Gladwell）所著。它刷新了我对能力超群之人的认识。两周看完这本书，现做些读书摘抄，并分享下我的读后感 积累成功是天赋加上后天努力，但是天赋的作用其实很小，而后天努力的作用其实很大。一个人在学习的过程中，要完美掌握某项复杂技能，就要一遍又一遍艰苦练习，而练习时长必须达到一个最小临界量：一万小时。任何一个领域的世界级水平都需要起码10000小时的训练。人的大脑必需花费那么长的时间消化理解，才能达到极其精通的水平。 练习并不是为了让你一次就能把事情做好，而是为了帮助你越做越好 一万小时的确很难依靠自己达到这一要求，小时候需要获得父母的鼓励与支持，依靠参加某些特定形式的训练课程，或者获得某些特定机遇得以进行训练。 我们如何到持续的练习呢？我的答案是，认识自己，找到自己想要的生活方式和节奏，找寻自己的特质和兴奋点，做什么能带给你快乐，什么事是别人不逼你，你也愿意甚至兴高采烈地做着，一旦开始了，慢慢地你变得擅长做这件事，你发现你比别人做得更好，有了快感，有了正想的情感体验，你会继续做这件事，进入良性循环。 机遇除了能力，机遇和其他完全随机的优势也在帮助特定领域的异类走向成功之巅。异类是那些获得特殊机遇之人，是那些耐心等待，当机遇到来就当仁不让把握住机遇的人们。 机遇并非偶然而是存在规律，马尔科姆在书里就详细分析了冰球运动员，甲壳虫乐队，比尔盖茨，比尔乔伊，弗洛姆，律师行的创始人，这些异类们的机遇规律。 对于加拿大的冰球运动员来说，生于1月就是他们进入全明星队的机遇；对于甲壳虫乐队，汉堡之旅就是机遇；对于比尔盖茨，特殊机遇就是生于正确的年代，并在初中时代就获得电脑终端；对于弗洛姆和我切尔.利普顿.罗森.卡茨律师行的创始人,机遇是多重的，他们生于正确的年代，有着能给他们最勤勉激励的父母，他们拥有少数族裔身份，这种身份帮助他们在纽约其它传统律师事务所拥有少数族裔身份，这种身份帮助他们在纽约其它传统事务所涉足公司并购官司以前，就已在这个领域事件了20年。 个性作用并非个人成功的决定因素。成功人士并非白手起家，他们以某种形式获得家族的隐蔽和支持，看似完全依靠个人奋斗，其实不是。他们一直得益于某些隐蔽的先天优势，或非凡的机缘，抑或某一个文化的特殊优势；这使得他们学得快，干得多，以普通人难以企及的方式认知世界。出生的时代与地域对个体的影响巨大。而我们所处的文化背景，以及我们的祖先留传下来的东西，在我们无意识的情况下，就已限定了我们获得成功的方式。 任何意义上的超常之辈，都是历史与环境的产物，是机遇与积累的结晶。 机遇和积累的关系上述机遇有着什么样的共同点？这些机遇都给了“异类”们更多的练习时间，直至达到一万小时。有句成语，时势造英雄，按照马尔科姆的逻辑，那便是因为局势给那些英雄们提供了成为英雄所需要的练习，当积累至少超过一万小时后，英雄出现了。 小结行走在完成一万小时的路上]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造安卓App丝滑的操作体验－－Fragment深入使用和封装之道]]></title>
    <url>%2F2017%2F03%2F10%2F2017%2F2017-03-10%2F</url>
    <content type="text"><![CDATA[简介想让App有丝滑般的切换速度和顺畅的体验么？那就放开Activity，使用Fragment来展示UI页面吧 Github futurice/android-best-practices上列举了一些列安卓开发最佳实践建议，其中对Fragment使用做了一些陈述（传送门），我表示赞同。 最近项目需要新增了一个功能模块，我引入了一个Activity，多个fragment的方式来组织UI，这个过程有了一些收获。 对fragment的操作，我使用support v4包下的，FragmentManager和FragmentTransaction这两个类。 正文如何启动一个Fragmentreplace方式这里我没有用Activity下的getSupportFragmentManager得到了FragmentManager来替换Fragment，而是选择使用fragment下的getChildFragmentManager（）获取FragmentManager。 放在基类BasicActivity里， /** * 替换当前Fragment里的某个FrameLayout布局 * @param resId 被替换的布局ID * @param fragmentTab 新的Fragment名 * @param arguments 传入新的Fragment的Bundle * @param isAddToBack 是否加入回退栈 */ private void replaceOneFragment(@IdRes int resId, String fragmentTab, Bundle arguments, boolean isAddToBack) { int childrenFragmentContainerResID = ((BasicFragment) mCurrentFragment).getChildrenFragmentContainerResID(); int layoutId = resId &lt;= 0 ? childrenFragmentContainerResID : resId; if (layoutId == -1) { throw new IllegalStateException(&quot;You should overwrite getChildrenFragmentContainerResID from BasicFragment&quot;); } FragmentManager manager = mCurrentFragment.getChildFragmentManager(); if (manager != null) { FragmentTransaction transaction = manager.beginTransaction(); transaction .setCustomAnimations(R.anim.right_enter, R.anim.left_exit, R.anim.left_enter, R.anim.right_exit) .replace(layoutId, fragmentProvider(fragmentTab, arguments), fragmentTab); if (isAddToBack) { transaction.addToBackStack(fragmentTab); } transaction.commitAllowingStateLoss(); } } 说明： getChildrenFragmentContainerResID(),该方法在BasicFragment里，用来获取要替换的布局ID BasicActivity里，fragmentProvider()，Fragment提供者 add/show/hide显示Fragment（支持SingleTask启动Fragment） /** * 显示特定Tag的Fragment,如果是第一次显示,则新建并添加该Fragment * * @param fragmentTab Fragment标签名 * @param arguments 传入Fragment的参数 * @param isAddBackStack 是否加入FragmentManager回退栈 * @param launchMode 启动模式 分为： STANDARD，SINGLE，SINGLE_ENHANCEMENT */ private void showOneFragment(String fragmentTab, Bundle arguments, boolean isAddBackStack, LaunchMode launchMode) { FragmentManager manager = getSupportFragmentManager(); if (manager == null) { return; } Fragment fragmentByTag = manager.findFragmentByTag(fragmentTab); if (fragmentByTag != null &amp;&amp; launchMode == LaunchMode.SINGLE_ENHANCEMENT) { popMultipleBackStack(fragmentTab, arguments); return; } FragmentTransaction transaction = manager.beginTransaction(); //设置过渡动画 transaction.setCustomAnimations(R.anim.right_enter, R.anim.left_exit, 0, 0); //隐藏当前所有fragment List&lt;Fragment&gt; fragments = manager.getFragments(); if (fragments != null &amp;&amp; fragments.size() &gt; 0) { for (Fragment f : fragments) { if (f != null) { transaction.hide(f); } } } //第一次添加该Fragment if (fragmentByTag == null) { mCurrentFragment = fragmentProvider(fragmentTab, arguments); mFragmentBackDeque.push(fragmentTab); transaction.add(getFragmentContainerResID(), mCurrentFragment, fragmentTab); if (isAddBackStack) { transaction.addToBackStack(fragmentTab); } transaction.commitAllowingStateLoss(); return; } if (!(fragmentByTag instanceof BasicFragment)) { throw new ClassCastException(&quot;fragment must extends BasicFragment&quot;); } //更新Arguments，按后退键时Fragment里的后退方法里使用 if (arguments != null) { setSupportBackStackArguments(arguments); } //根据启动模式类型，采取不同的方式维护后退栈 switch (launchMode) { case STANDARD: mFragmentBackDeque.push(fragmentTab); break; case SINGLE: synchronizeFragmentBackDequeWhenSingleLaunchMode(fragmentTab); break; } BasicFragment basicFragment = (BasicFragment) fragmentByTag; mCurrentFragment = fragmentByTag; basicFragment.setSupportArguments(arguments); transaction.show(fragmentByTag); transaction.commitAllowingStateLoss(); } /** * fragment 启动模式 */ public enum LaunchMode { /** * 标准模式 */ STANDARD, /** * 单例模式，其他Fragment从自维护的mFragmentBackDeque栈里退出 */ SINGLE, /** * 强化版单例模式，其他Fragment从FragmentManager栈和自维护的mFragmentBackDeque栈里退出 */ SINGLE_ENHANCEMENT, } 说明： popMultipleBackStack（）实现一次弹出多个Fragment 在隐藏当前所有fragment操作，特别需要在遍历时，做个非空判断， for (Fragment f : fragments) { if (f != null) { transaction.hide(f); } } 这样做，是因为Fragment出栈后，会出现栈内顺序不正确的bug，详看Fragment全解析系列（一）：那些年踩过的坑，一文中关于多个Fragment同时出栈的深坑BUG这一部分的内容。 synchronizeFragmentBackDequeWhenSingleLaunchMode（）单例模式下，管理自维护的Fragment后退栈 mFragmentBackDeque是自维护回退管理队列 后退键监听管理使用Fragment组织UI后，返回上一个页面的逻辑有了变化。如果遇到之前replace替换了，则先从该fragment的FragmentManager里恢复原来的被替换的fragment，没有，则把之前hide状态的Fragment重新show显示出来，这个过程需要用了队列自己来维护回退 @Override public void onBackPressed() { if (mFragmentBackDeque == null || mCurrentFragment == null) { return; } //检查当前Fragment的ChildFragmentManager回退栈是否需要回退 int childStackEntryCount = mCurrentFragment.getChildFragmentManager().getBackStackEntryCount(); if (childStackEntryCount &gt; 0) { mCurrentFragment.getChildFragmentManager().popBackStackImmediate(); return; } //检查当前Fragment的自维护的回退栈是否需要回退 if (mFragmentBackDeque.size() &gt;= 2) { showOneFragmentOnBackPressed(); return; } finish(); } showOneFragmentOnBackPressed()实现返回键显示特定Tag的Fragment 同时，如果需要，我们可以给FragmentManager添加OnBackStackChangedListener，监听FragmentManager回退栈成员数量的变化，具体使用见文末的代码 还有一种思路，View提供了setOnKeyListener（OnKeyListener onKeyListener），用OnKeyListener来监听后退健。 Fragment入参管理第一次启动Fragment，走的是fragment生命周期方法，之后启动fragment从hide状态重新show时，不走Fragment生命周期方法，而是调用onHiddenChanged(boolean hidden)方法。因此，在这两种场景下支持给fragment传入参数，并且做到每次显示fragment，都能拿到最新的入参bundle。 我在BasicFragment设计如下： /** * Fragment Argument解析 * @param arguments */ protected void parseArguments(Bundle arguments){ } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); parseArguments(getArguments()); } @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if(!hidden){ parseArguments(getSupportArguments()); } } 这样，新的Fragmnet在继承BasicFragment时，只需要重新parseArguments（）即可 Toolbar管理项目中使用Toolbar，用BasicFragmentWithToolbar来负责Toolbar的设置逻辑 BasicFragmentWithToolbar类里的核心代码 @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if (!hidden) { configureToolbar(); } } @Override protected void configureToolbar() { super.configureToolbar(); int stackEntryCount = getChildFragmentManager().getBackStackEntryCount(); if (stackEntryCount &gt; 0) { FragmentManager.BackStackEntry stackEntry = getChildFragmentManager().getBackStackEntryAt(stackEntryCount - 1); //Get the name that was supplied to FragmentTransaction.addToBackStack(String) when creating this entry String fragmentTab = stackEntry.getName(); BasicFragmentWithToolbar fragmentByTag = (BasicFragmentWithToolbar) getChildFragmentManager().findFragmentByTag(fragmentTab); if (fragmentByTag != null) { fragmentByTag.setupToolbar(); } } else { setupToolbar(); } } /** * 设置Toolbar的显示内容 */ protected void setupToolbar() { mToolbar.setNavigationIcon(R.drawable.icon_header_left); mToolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getAttachActivity().onBackPressed(); } }); } 如何使用上述的Fragment封装我举个例子，我建一个BillContainerActivity，来作为Bill相关的Fragment容器，代码如下 public class BillContainerActivity extends BasicActivity { private static final String TAG = &quot;BillContainerActivity&quot;; @Bind(R.id.frame_activity_order_body) FrameLayout mOrderBody; public static Intent getCallingIntent(Activity activity){ Intent intent = new Intent(activity,BillContainerActivity.class); return intent; } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); initializeShow(); } private void initializeShow() { showOneFragment(BillHomeFragment.class.getSimpleName(),true); } @Override protected BasicFragment fragmentProvider(String fragmentTab, Bundle arguments) { BasicFragment currentFragment; if(BillHomeFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillHomeFragment.newInstance(); } else if(BillProcessFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillProcessFragment.newInstance(arguments); } else if(BillStructureFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillStructureFragment.newInstance(arguments); } else if(AdjustBillDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = AdjustBillDetailFragment.newInstance(arguments); } else if(BrokerageDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BrokerageDetailFragment.newInstance(arguments); } else if(InvoiceDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = InvoiceDetailFragment.newInstance(arguments); } else if(InvoiceListFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = InvoiceListFragment.newInstance(arguments); } else{ currentFragment = BillHomeFragment.newInstance(); } return currentFragment; } @Override protected int getFragmentContainerResID() { return R.id.frame_activity_order_body; } @Override protected int getLayoutResID() { return R.layout.activity_bill_home; } } 说明: 会发现作为Fragment容器的BillContainerActivity，代码量很少，主要做两件事 初始化显示Fragment 实现fragmentProvider方法，该方法把这个容器所需的Fragment构造出来 小结完整封装Fragment的代码随着项目需求在进化和改动，还是决定放到Github上完整代码传送门，欢迎star 相关阅读资料特别鸣谢：YoKey系列 Fragment全解析系列（一）：那些年踩过的坑 Fragment全解析系列（二）：正确的使用姿势 Fragment之我的解决方案：Fragmentation Android开发之Fragment最佳实践 What the Fragment?-Google I/O 2016(需自备梯子) 知乎：关于 Android，用多个 activity，还是单 activity 配合 fragment？ Android multiple fragment transaction ordering]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓EditText－实现输入小数点后几位的逻辑演变]]></title>
    <url>%2F2017%2F02%2F26%2F2017%2F2017-02-26%2F</url>
    <content type="text"><![CDATA[简介在Android开发中，时不时需要用户输入一些数据，有输入就有格式上的要求。比如EditText输入金额时，通常要保留小数点后两位，这个如何实现呢？ 首先在布局文件里，通过android:inputType限定EditText输入的内容，numberDecimal表示只能输入带小数点的浮点格式 &lt;EditText android:id=&quot;@+id/tiet_invoice_free_tax_amount&quot; style=&quot;@style/InvoiceDetailEditTextStyle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/item_invoice_detail_height&quot; android:hint=&quot;发票金额(¥)：&quot; android:inputType=&quot;numberDecimal&quot; /&gt; EditText inputType属性详解 传送门 方法一，普通实现给EditText添加TextChangedListener监听，重写onTextChanged方法，输入小数点后两位的逻辑 @Override public void onTextChanged(CharSequence s, int start, int before, int count) { if (s.toString().contains(&quot;.&quot;)) { if (s.length() - 1 - s.toString().indexOf(&quot;.&quot;) &gt; 2) { s = s.toString().subSequence(0, s.toString().indexOf(&quot;.&quot;) + 3); editText.setText(s); editText.setSelection(s.length()); } } if (s.toString().trim().substring(0).equals(&quot;.&quot;)) { s = &quot;0&quot; + s; editText.setText(s); editText.setSelection(2); } if (s.toString().startsWith(&quot;0&quot;) &amp;&amp; s.toString().trim().length() &gt; 1) { if (!s.toString().substring(1, 2).equals(&quot;.&quot;)) { editText.setText(s.subSequence(0, 1)); editText.setSelection(1); return; } } } 这种方法实现复杂，有没有更简单的？ 方法二，简洁实现在重写onTextChanged方法里，一旦输入的内容里包含了“.”，则限定输入的文本长度为小数点所在长度加上后两位的长度。把问题转为如何限定EditText输入的内容长度呢？EditText提供了setFilter()方法，InputFilter.LengthFilter类，实现代码如下： private static final int DEFAULT_MAX_INTEGER_LENGTH = 10; private static final int DEFAULT_DECIMAL_NUMBER = 2; private static final InputFilter[] INPUT_FILTER_ARRAY = new InputFilter[1]; /** * 保留小数点后多少位 */ private int mDecimalNumber = DEFAULT_DECIMAL_NUMBER; /** * 允许最大的整数多少位 */ private int mMaxIntegralLength = DEFAULT_MAX_INTEGER_LENGTH; @Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) { super.onTextChanged(text, start, lengthBefore, lengthAfter); if(text.length() &gt; 0) { String inputContent = text.toString(); if (inputContent.contains(&quot;.&quot;)) { int maxLength = inputContent.indexOf(&quot;.&quot;) + mDecimalNumber + 1; INPUT_FILTER_ARRAY[0] = new InputFilter.LengthFilter(maxLength); } else { INPUT_FILTER_ARRAY[0] = new InputFilter.LengthFilter(mMaxIntegralLength); } setFilters(INPUT_FILTER_ARRAY); } } 与方法一相比，方法二执行效率得到了提高，不必截取字符串长度subString，同时逻辑上也简化了 方法三，优雅实现查阅InputFilter,对该类的描述： InputFilters can be attached to Editables to constrain the changes that can be made to them InputFilter能过滤EditText的输入内容，如此就不必监听OnTextChangeListener，而是设置过滤器的过滤逻辑，优雅得实现显示小数点后几位，核心代码如下： setFilters(new InputFilter[]{new InputFilter() { @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String lastInputContent = dest.toString(); if (lastInputContent.contains(&quot;.&quot;)) { int index = lastInputContent.indexOf(&quot;.&quot;); if(dend - index &gt;= mDecimalNumber + 1){ return &quot;&quot;; } } return null; } }}); filter方法用到的入参说明： source 单次输入的字符内容 dest上次输入的内容 到此，一个输入小数点后几位的自定义控件雏形已经显现了。 二 简单的自定义控件DecimalEditText，实现输入小数点后若干位所有代码如下： public class DecimalEditText extends EditText { private static final int DEFAULT_DECIMAL_NUMBER = 2; /** * 保留小数点后多少位 */ private int mDecimalNumber = DEFAULT_DECIMAL_NUMBER; public DecimalEditText(Context context) { this(context,null,R.attr.editTextStyle); } public DecimalEditText(Context context, AttributeSet attrs) { this(context,attrs, R.attr.editTextStyle); } public DecimalEditText(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DecimalEditText); mDecimalNumber = typedArray.getInt(R.styleable.DecimalEditText_decimalNumber,DEFAULT_DECIMAL_NUMBER); typedArray.recycle(); init(); } private void init(){ setFilters(new InputFilter[]{new InputFilter() { @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String lastInputContent = dest.toString(); if (source.equals(&quot;.&quot;) &amp;&amp; lastInputContent.length() == 0) { return &quot;0.&quot;; } if (lastInputContent.contains(&quot;.&quot;)) { int index = lastInputContent.indexOf(&quot;.&quot;); if(dend - index &gt;= mDecimalNumber + 1){ return &quot;&quot;; } } return null; } }}); } public int getDecimalNumber() { return mDecimalNumber; } public void setDecimalNumber(int decimalNumber) { mDecimalNumber = decimalNumber; } } attr文件 &lt;declare-styleable name=&quot;DecimalEditText&quot;&gt; &lt;attr name=&quot;decimalNumber&quot; format=&quot;integer&quot;/&gt; &lt;/declare-styleable&gt; 小结方法一的实现思路和网络上搜到的实现差不多，从方法一到方法三，是一个解决问题的逻辑演变的过程。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是时候自己来造个轮子了－－增强型RecyclerView]]></title>
    <url>%2F2017%2F01%2F23%2F2017%2F2017-01-23%2F</url>
    <content type="text"><![CDATA[简述该增强型RecyclerView，增加了以下特性： 上拉滑动到底部，加载更多 支持添加Header头视图 支持加载数据为空时，显示特定视图 支持拖拽，侧滑删除 下拉刷新实现通过给RecyclerView包一层SwipRefreshLayout来实现。 本文重点分享上拉加载更多的实现，同时实现添加头部视图，侧滑，拖拽功能实现，该实现存在以下注意点： 如何判断RecyclerView滑动到了底部 通常RecyclerView显示的item布局相同，怎么做到上拉加载更多时出现一个底栏视图 滑动到底栏出现加载更多动画，这个动画什么时候结束？动画生命周期是？ ReclcerViewyou多种布局，如果是网格布局（有多列），怎么做到让上拉加载更多的动画视图和头部视图占用一整行？ 自定义了RecyclerView，如何做到像使用标准RecyclerView那样使用？ 如何实现item的拖拽和侧滑删除？ 实现的注意点解析如何判断RecyclerView滑动到了底部关于布局的逻辑设置，就找LayoutManager。的确，通过查阅官方API手册，有findLastVisibleItemPosition()/findLastCompletelyVisibleItePosition()，在滑动监听里，使用这两个方法就能实现判断 怎么做到上拉加载更多时出现一个底栏视图这里涉及到RecyclerView如何实现多布局显示的知识，通过getItemViewType()，底部上拉加载更多视图设定一种ItemViewType值，对应新建一个ViewHolder. 滑动到底栏出现加载更多动画这个动画什么时候结束？动画生命周期是？ 动画的开始时刻是列表滑倒底部，当滑倒底部时，在客户类（Fragment／Activity）里接口回调，开始网络请求数据，动画的结束时刻是网络加载完成，刷新列表时 ReclcerViewyou多种布局，如果是网格布局（有多列），怎么做到让上拉加载更多的动画视图和头部视图占用一整行？ 和布局相关的，找LayoutManager，这里要找GridLayoutManager，它提供了setSpanSizeLookup（GridLayoutManager.SpanSizeLookup），通过这个方法，可以根据位置来设置item占用一整行还是正常显示 自定义了RecyclerView，如何做到像使用标准RecyclerView那样使用？使用装饰器设计模式，能很好的实现对用户透明使用效果 如何实现item的拖拽和侧滑删除？使用android提供的ItemTouchHelper工具类，能快速的实现 核心代码EnhanceRecyclerViewpublic class EnhanceRecyclerView extends RecyclerView { private static final String TAG = &quot;EnhanceRecyclerView&quot;; private OnLoadMoreListener mOnLoadMoreListener; private InternalAdapter mInternalAdapter; private View mEmptyView; private @LayoutRes int mHeaderResId; private AdapterDataObserver mAdapterDataObserver = new EnhanceAdapterDataObserver(); /** * 滚动方向 */ private int mScrollDy = 0; public EnhanceRecyclerView(Context context) { super(context); } public EnhanceRecyclerView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public EnhanceRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } @Override public void onScrolled(int dx, int dy) { super.onScrolled(dx, dy); mScrollDy = dy; } @Override public void onScrollStateChanged(int state) { super.onScrollStateChanged(state); switch (state) { case SCROLL_STATE_IDLE: LayoutManager layoutManager = getLayoutManager(); int itemCount = getAdapter().getItemCount(); int lastVisibleItemPosition = 0; if (layoutManager instanceof GridLayoutManager) { GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; lastVisibleItemPosition = gridLayoutManager.findLastVisibleItemPosition(); } else if (layoutManager instanceof LinearLayoutManager) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager) layoutManager; lastVisibleItemPosition = linearLayoutManager.findLastVisibleItemPosition(); } if (lastVisibleItemPosition &gt;= itemCount - 1) { if (getParent() instanceof SwipeRefreshLayout) { SwipeRefreshLayout swipeRefreshLayout = (SwipeRefreshLayout) getParent(); if (swipeRefreshLayout.isRefreshing()) { break; } } if (mOnLoadMoreListener != null &amp;&amp; mScrollDy &gt; 0) { mInternalAdapter.setLoadingIndicatorViewVisible(VISIBLE); mOnLoadMoreListener.onLoadMore(); } } break; } } /** * 重写此方法，设置GridLayout的上拉加载更多视图的位置 * * @param layout */ @Override public void setLayoutManager(LayoutManager layout) { if (layout instanceof GridLayoutManager) { final GridLayoutManager externalGridLayoutManager = (GridLayoutManager) layout; final int spanCount = externalGridLayoutManager.getSpanCount(); int orientation = externalGridLayoutManager.getOrientation(); final GridLayoutManager innerGridLayoutManager = new GridLayoutManager(getContext(), spanCount, orientation, false); innerGridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { int headerViewCount = mInternalAdapter.getHeaderViewCount(); int footViewCount = mInternalAdapter.getFootViewCount(); if (position &lt; headerViewCount) { return spanCount; } int totalItemCount = innerGridLayoutManager.getItemCount(); if (position &gt;= totalItemCount - footViewCount) { return spanCount; } return externalGridLayoutManager.getSpanSizeLookup().getSpanSize(position - headerViewCount); } }); super.setLayoutManager(innerGridLayoutManager); } else { super.setLayoutManager(layout); } } public View getEmptyView() { return mEmptyView; } public final void setEmptyView(View emptyView) { mEmptyView = emptyView; setupEmptyViewHierarchy(emptyView); } protected void setupEmptyViewHierarchy(View emptyView) { ((ViewGroup) getParent().getParent()).addView(emptyView,0); } public void addHeaderResId(@LayoutRes int resId) { mHeaderResId = resId; if (mInternalAdapter != null) { mInternalAdapter.setExternalHeaderResId(resId); } } @Override public void setAdapter(Adapter adapter) { mInternalAdapter = new InternalAdapter(adapter); super.setAdapter(mInternalAdapter); //addHeaderView方法依赖于setAdapter方法 if (mHeaderResId &gt; 0) { addHeaderResId(mHeaderResId); } mInternalAdapter.registerAdapterDataObserver(mAdapterDataObserver); mAdapterDataObserver.onChanged(); } public void setOnLoadMoreListener(OnLoadMoreListener onLoadMoreListener) { mOnLoadMoreListener = onLoadMoreListener; } public void loadMoreOnSuccess() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnSuccess(); } } public void loadMoreOnError() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnError(); } } public void loadMoreOnComplete() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnComplete(); } } public final void notifyDataSetChanged() { mInternalAdapter.notifyDataSetChanged(); } public final void notifyItemChanged(int position) { mInternalAdapter.notifyItemChanged(position); } public final void notifyItemChanged(int position, Object payload) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemChanged(position, payload); } public final void notifyItemRangeChanged(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeChanged(positionStart, itemCount); } public final void notifyItemRangeChanged(int positionStart, int itemCount, Object payload) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeChanged(positionStart, itemCount, payload); } public final void notifyItemInserted(int position) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemInserted(position); } public final void notifyItemMoved(int fromPosition, int toPosition) { fromPosition = fromPosition + mInternalAdapter.getHeaderViewCount(); toPosition = toPosition + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemMoved(fromPosition, toPosition); } public final void notifyItemRangeInserted(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeInserted(positionStart, itemCount); } public final void notifyItemRemoved(int position) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRemoved(position); } public final void notifyItemRangeRemoved(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeRemoved(positionStart, itemCount); } public InternalAdapter getInternalAdapter() { return mInternalAdapter; } /** * 上拉加载更多回调 */ public interface OnLoadMoreListener { void onLoadMore(); } private class EnhanceAdapterDataObserver extends AdapterDataObserver { @Override public void onChanged() { super.onChanged(); if (getEmptyView() != null &amp;&amp; getAdapter() != null) { int itemCount = getAdapter().getItemCount(); if (itemCount == 0) { getEmptyView().setVisibility(VISIBLE); setVisibility(GONE); } else { getEmptyView().setVisibility(GONE); setVisibility(VISIBLE); } } } @Override public void onItemRangeChanged(int positionStart, int itemCount) { super.onItemRangeChanged(positionStart, itemCount); onChanged(); } @Override public void onItemRangeChanged(int positionStart, int itemCount, Object payload) { super.onItemRangeChanged(positionStart, itemCount, payload); onChanged(); } @Override public void onItemRangeInserted(int positionStart, int itemCount) { super.onItemRangeInserted(positionStart, itemCount); onChanged(); } @Override public void onItemRangeRemoved(int positionStart, int itemCount) { super.onItemRangeRemoved(positionStart, itemCount); onChanged(); } @Override public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) { super.onItemRangeMoved(fromPosition, toPosition, itemCount); onChanged(); } } } InternalAdapterpublic class InternalAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final String TAG = &quot;InternalAdapter&quot;; private static final int HEADER_ITEM_TYPE = 170118; private static final int FOOTER_ITEM_TYPE = 170116; private RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; mExternalAdapter; private int mBodyItemCount; private FooterView mFooterView; private @LayoutRes int mExternalHeaderResId; public InternalAdapter(RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; externalAdapter) { mExternalAdapter = externalAdapter; mBodyItemCount = externalAdapter.getItemCount(); } @Override public int getItemViewType(int position) { if(isHeaderView(position)){ return HEADER_ITEM_TYPE; } else if (isFootView(position)) { return FOOTER_ITEM_TYPE; } return mExternalAdapter.getItemViewType(position); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { switch (viewType) { case HEADER_ITEM_TYPE: View headerView = LayoutInflater.from(parent.getContext()).inflate(mExternalHeaderResId, parent, false); return new HeaderView(headerView); case FOOTER_ITEM_TYPE: View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_footer_indicator, parent, false); mFooterView = new FooterView(view); return mFooterView; default: return mExternalAdapter.onCreateViewHolder(parent, viewType); } } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if(isHeaderView(position)){ return; } if (isFootView(position)) { return; } if(mExternalHeaderResId &gt; 0){ position = position - getHeaderViewCount(); } mExternalAdapter.onBindViewHolder(holder, position); } @Override public int getItemCount() { mBodyItemCount = mExternalAdapter.getItemCount(); if(mBodyItemCount == 0){ return 0; } else{ return getHeaderViewCount() + mBodyItemCount + getFootViewCount(); } } private boolean isHeaderView(int position){ return mExternalHeaderResId &gt; 0 &amp;&amp; position == 0; } private boolean isFootView(int position) { return (position &gt;= mBodyItemCount + getHeaderViewCount()); } public int getFootViewCount() { return 1; } public int getHeaderViewCount(){ return mExternalHeaderResId &gt; 0 ? 1 : 0; } public void setLoadingIndicatorViewVisible(int visible){ if(mFooterView != null){ mFooterView.setLoadingIndicatorViewVisible(visible); } } public void setExternalHeaderResId(int externalHeaderResId) { mExternalHeaderResId = externalHeaderResId; } public void loadMoreOnSuccess(){ setLoadingIndicatorViewVisible(View.GONE); } public void loadMoreOnError(){ setLoadingIndicatorViewVisible(View.GONE); } public void loadMoreOnComplete(){ setLoadingIndicatorViewVisible(View.GONE); } static class HeaderView extends RecyclerView.ViewHolder{ HeaderView(View itemView) { super(itemView); } } static class FooterView extends RecyclerView.ViewHolder { @Bind(R.id.item_footer_indicator) LoadingIndicatorView mLoadingIndicatorView; FooterView(View itemView) { super(itemView); ButterKnife.bind(this, itemView); mLoadingIndicatorView.setVisibility(View.GONE); } void setLoadingIndicatorViewVisible(int visible){ mLoadingIndicatorView.setVisibility(visible); } } } 底部FooterView的布局item_footer_indicator.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@android:color/transparent&quot; &gt; &lt;com.sugary.refreshrecyclerview.enhancerecycler.indicator.LoadingIndicatorView android:id=&quot;@+id/item_footer_indicator&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; app:indicator_color=&quot;@color/indicator_loading_more_orange&quot; /&gt; &lt;/RelativeLayout&gt; LoadingIndicatorViewpublic class LoadingIndicatorView extends View { //Sizes (with defaults in DP) public static final int DEFAULT_SIZE = 50; private Paint mPaint; private BaseIndicatorController mIndicatorController; private boolean mHasAnimation; public LoadingIndicatorView(Context context) { this(context, null); } public LoadingIndicatorView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public LoadingIndicatorView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(attrs); } private void init(AttributeSet attrs) { TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.LoadingIndicatorView); int indicatorColor = a.getColor(R.styleable.LoadingIndicatorView_indicator_color, Color.GRAY); a.recycle(); mPaint = new Paint(); mPaint.setColor(indicatorColor); mPaint.setStyle(Paint.Style.FILL); mPaint.setAntiAlias(true); mIndicatorController = new BallPulseIndicator(); mIndicatorController.setTarget(this); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int width = measureDimension(dp2px(DEFAULT_SIZE), widthMeasureSpec); int height = measureDimension(dp2px(DEFAULT_SIZE), heightMeasureSpec); setMeasuredDimension(width, height); } private int measureDimension(int defaultSize, int measureSpec) { int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) { result = specSize; } else if (specMode == MeasureSpec.AT_MOST) { result = Math.min(defaultSize, specSize); } else { result = defaultSize; } return result; } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); if (!mHasAnimation) { mHasAnimation = true; mIndicatorController.initAnimation(); } } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); drawIndicator(canvas); } void drawIndicator(Canvas canvas) { mIndicatorController.draw(canvas, mPaint); } private int dp2px(int dpValue) { return (int) getContext().getResources().getDisplayMetrics().density * dpValue; } @Override public void setVisibility(int v) { if (getVisibility() != v) { super.setVisibility(v); if (v == GONE || v == INVISIBLE) { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.END); } else { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.START); } } } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); if (mHasAnimation) { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.START); } } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.CANCEL); } } 小结：列表数据刷新，改成了调用EnhanceRecylerView方法，用自己建的Adapter刷新数据无效（这是这个轮子的缺陷，有待改进）。 底部滑动动画使用了他人的开源动画 在自制增强型RecyclerView过程中，也刷了一些资料，推荐阅读。 参考资料 RecyclerView必知必会（五星推荐） Github:RecyclerView优秀文集 Github:BeautifulRefreshLayout Github:BaseRecyclerViewAdapterHelper *Github:XRecyclerView]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对2016年的年度小结]]></title>
    <url>%2F2017%2F01%2F03%2F2017%2F2017-01-03%2F</url>
    <content type="text"><![CDATA[尽管这篇年度小结有点迟，但是却是非常必要的。 和去年相似，在写这篇小结之前，刚看完李笑来老师的书《把时间当作朋友》，书本里很多观点发人深省，醍醐灌顶，茅塞顿开。就我最后看的部分，做个简单的摘抄： 从整体上看，人脉当然重要。不过针对个体来说，比人脉更重要的是他所拥有的资源。 翻看2015年年度小结，顺利完成了《Android开发艺术探索》一书的阅读，加深了对Gradle的使用和认知。 2016年安卓方面，有了如下更新： 进一步理解了MVC，MPV和MVVM的区别和使用，在android App中使用Clean－Architecture项目架构，在项目里使用RxJava（RxBus），Retrofit2.0， Dagger2.0。 在Google发布App，Material Design在App中的使用。 加入了一家一线互联网公司 2016年阅读了如下书籍： 操作系统－精髓与设计原理 第七版（半本） 黑客与画家（五星推荐） Android开发艺术探索 安卓设计模式－源码解析与实战（抽章节着看，目测不到半本） Gradle For Android 中文版 把时间当作朋友（李笑来著） 2016年上半年最大的收获是对当下热门的开源库的实践，下半年最大的变化就是加入了一家愿景远大的一线互联网公司，非常期待在这个广阔的平台上发挥自己的技术能力。 基于思考，接下来2017年的安卓学习重点和主题是：提高计算机基础素养。为此，计划阅读和学习的书籍（按时间顺序）如下： 深入理解计算机系统 &amp; 操作系统－精髓与设计原理 算法 第四版 Java编程思想 &amp; Effective Java 一本关于函数式 Java8学习的书 鸟哥的Linux私房菜基础学习篇 因此我把2017年度的学习分成三个阶段： 前四月学习计算机基础 5月到8月学习Java 后四月学习Linux 注：如果时间不够，就依次顺延到2018年上半年 2017年将是为以后进一步成长打好基础的一年，非常重要。2017年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用数组和链表实现自制的栈和队列]]></title>
    <url>%2F2016%2F12%2F22%2F2016%2F2016-12-22%2F</url>
    <content type="text"><![CDATA[数组和链表是常用的两种数据结构，在翻看了Stack类，Iterable接口，Iterator接口，Queue的Java源码后，尝试用数组和链表来自己实现一下栈和队列。 自己造过轮子后，实实在在的理解了轮子，才能真正深入的使用轮子。代码如下： 说明：Stackable是我自己写的接口 数组实现栈public class SugarArrayStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private static final int DEFAULT_CAPACITY = 2; private int N = 0; private E[] a; public SugarArrayStack() { resize(DEFAULT_CAPACITY); } public SugarArrayStack(int size){ resize(size); } private void resize(int size){ E[] temp = (E[])new Object[size]; for(int i = 0; i &lt; N; i++){ temp[i] = a[i]; } a = temp; } @Override public void push(E e){ if(N &gt;= a.length - 1){ resize(a.length * 2); } a[N++] = e; } @Override public E pop(){ E temp = peek(); a[--N] = null; if(N &gt;= 0 &amp;&amp; N == a.length / 4){ resize(a.length / 2); } return temp; } @Override public E peek(){ int index = N - 1; return a[index]; } @Override public int size(){ return N; } @Override public boolean isEmpty(){ return N == 0; } @Override public Iterator&lt;E&gt; iterator() { return new ArrayIterator(N); } private class ArrayIterator implements Iterator&lt;E&gt;{ private int currentIndex; public ArrayIterator(int currentIndex) { this.currentIndex = currentIndex; } @Override public boolean hasNext() { return currentIndex &gt; 0; } @Override public E next() { currentIndex--; return a[currentIndex]; } } } 链表实现栈队列public class SugarLinkedQueue&lt;E&gt; implements Iterable&lt;E&gt;{ private Node&lt;E&gt; mHeadNode; private Node&lt;E&gt; mTailNode; private int mCount = 0; public void enqueue(E e){ Node&lt;E&gt; newTailNode = new Node&lt;&gt;(e,null); if(mCount == 0){ mTailNode = newTailNode; mHeadNode = newTailNode; }else{ Node&lt;E&gt; oldTailNode = mTailNode; mTailNode = newTailNode; oldTailNode.nextNode = newTailNode; } mCount ++; } public E dequeue(){ if(isEmpty()){ throw new IllegalStateException(&quot;Please enqueue an element firstly&quot;); } mCount --; E tempE = mHeadNode.e; mHeadNode = mHeadNode.nextNode; return tempE; } public int size(){ return mCount; } public boolean isEmpty(){ return mCount == 0; } @Override public Iterator&lt;E&gt; iterator() { return new QueueIterator(mHeadNode); } private class QueueIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public QueueIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E currentE = currentNode.e; currentNode = currentNode.nextNode; return currentE; } } private class Node&lt;E&gt;{ private E e; private Node&lt;E&gt; nextNode; public Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 链表实现栈public class SugarLinkedStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private Node&lt;E&gt; headNode; private int count = 0; @Override public boolean isEmpty() { return count == 0; } @Override public int size() { return count; } @Override public void push(E e) { count++; headNode = new Node&lt;&gt;(e, headNode); } @Override public E pop() { if(count &lt;= 0){ throw new IllegalStateException(&quot;please push an element firstly&quot;); } count --; E e = headNode.e; headNode = headNode.nextNode; return e; } @Override public E peek() { return headNode.e; } @Override public Iterator&lt;E&gt; iterator() { return new LinkedIterator(headNode); } private class LinkedIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public LinkedIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E tempE = currentNode.e; currentNode = currentNode.nextNode; return tempE; } } private class Node&lt;E&gt; { private E e; private Node&lt;E&gt; nextNode; private Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 小结在实现过程中，产生了一些心得和感受，如下： 新建一个Java类，顺序是：先初始化成员变量，然后再调用它的构造方法。因此，某些场景上，一些操作是放在成员变量上还是放在构造方法里是有选择和考量的 链表这种数据结构天生包含迭代的编程思想，用递归来解决遇到的问题 数组这种数据结构使用索引访问元素（指针的使用感），操作数组序号来解决遇到的问题 用链表的实现，插入和删除元素的操作和元素数量多少没有关系。 深刻理解Iterator遍历原理，这个接口提供了集合遍历的逻辑封装，逻辑分为两个部分：hasNext方法和next方法。这两个方法合在一起产生出递归的效果，从而实现集合遍历 自制栈实践是时候使用自己造的轮子了 问题表述：给出一个字符串的算术表达式，求其值。比如“((( 10 + (34 - 24))*5)-(200/11))” 思路分析：用两个栈，一个保存运算符，一个保存操作数。将操作数压入操作数栈，将运算符压入运算符栈，忽略左括号，每遇到右括号，弹出一个运算符，弹出所需数量的操作数，计算后所得结果再压入操作数栈。 代码如下： public static void main(String[] args) { String expression = &quot;((( 10 + (34 - 24))*5)-(200/11))&quot;; float result = calculate(expression); System.out.println(&quot;result = &quot;+result); } private static float calculate(String expression) { if (expression != null &amp;&amp; expression.length() &gt; 0) { Stackable&lt;Character&gt; operatorsStack = new SugarArrayStack&lt;&gt;(); Stackable&lt;Float&gt; valueStack = new SugarLinkedStack&lt;&gt;(); StringBuilder sb = new StringBuilder(); char[] charArray = expression.toCharArray(); for (char c : charArray) { switch (c) { case &apos;(&apos;: case &apos; &apos;: break; case &apos;+&apos;: case &apos;-&apos;: case &apos;*&apos;: case &apos;/&apos;: pushNumberValue(valueStack, sb); operatorsStack.push(c); break; case &apos;)&apos;: pushNumberValue(valueStack, sb); Float firstPop = valueStack.pop(); Character operation = operatorsStack.pop(); float f; switch (operation) { case &apos;+&apos;: f = valueStack.pop() + firstPop; break; case &apos;-&apos;: f = valueStack.pop() - firstPop; break; case &apos;*&apos;: f = valueStack.pop() * firstPop; break; case &apos;/&apos;: f = valueStack.pop() / firstPop; break; default: throw new IllegalArgumentException(&quot;this operator haven&apos;t been supported now&quot;); } valueStack.push(f); break; default: sb.append(c); } } return valueStack.peek(); } return -1; } private static void pushNumberValue(Stackable&lt;Float&gt; valueStack, StringBuilder sb) { int length = sb.toString().length(); if(length &gt; 0){ float value = Float.parseFloat(sb.toString()); valueStack.push(value); sb.delete(0, length); } } 如上例子，最终输出的结果是： result = 81.818184 这种计算存在一些缺陷： 需要左右括号包装算术表达式 在一个括号里，只能进行两个操作数的计算 小结到此，我们用自己造的栈，实现了任意长度下的四则算术运算，今天的天气也比昨天格外得好了。 参考资料 算法 Algorithms Fourth Edition By Robert Sedgewick &amp; Kevin Wayne]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓下的刮刮卡摸奖的另一种实现]]></title>
    <url>%2F2016%2F12%2F16%2F2016%2F2016-12-16%2F</url>
    <content type="text"><![CDATA[实现思路网上有使用Xfermode来实现刮刮卡，这里提供另一种思路简洁的实现 一张呱呱卡有三层，最底层我用一个TextView控件显示中奖内容，中间层是刮完之后的显示图样，最上面一层是刮刮卡的封面。手指刮除封面的过程就是把刮刮卡最上面一层裁剪的过程。 涉及的知识点 canvas.clipPath(),Path类，Region.Op类 onDraw方法和onTouchEvent方法的配合 核心代码如下： public class LotteryView extends View { public static final int STROKE_WIDTH = 15; private float mEventX; private float mEventY; /** * 呱呱卡封面 画笔 */ private Paint mOverlayPaint; private RectF mRectBorder; /** * 呱呱卡边缘 画笔 */ private Paint mStrokePaint; private RectF mRectFill; private Path mClipPath; public LotteryView(Context context) { this(context,null,0); } public LotteryView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public LotteryView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { Bitmap lotteryOverlay = BitmapFactory.decodeResource(getResources(), R.drawable.icon_lottery_overlay); mOverlayPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mOverlayPaint.setShader(new BitmapShader(lotteryOverlay, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); mStrokePaint = new Paint(); mStrokePaint.setAntiAlias(true); mStrokePaint.setStyle(Paint.Style.STROKE); mStrokePaint.setColor(Color.BLACK); mStrokePaint.setStrokeWidth(STROKE_WIDTH); mClipPath = new Path(); } @Override protected void onDraw(Canvas canvas) { if (mRectBorder == null) { mRectBorder = new RectF(0, 0, getWidth(), getHeight()); } if (mRectFill == null) { mRectFill = new RectF(0, 0, getWidth(), getHeight()); } canvas.drawRoundRect(mRectBorder, 10, 10, mStrokePaint); if (mEventX != 0 || mEventY != 0) { mClipPath.addCircle(mEventX, mEventY, 50, Path.Direction.CW); canvas.clipPath(mClipPath, Region.Op.DIFFERENCE); } canvas.drawRect(mRectFill, mOverlayPaint); } @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getAction(); switch (action) { case MotionEvent.ACTION_MOVE: mEventX = event.getX(); mEventY = event.getY(); invalidate(); break; } return true; } } 布局里的使用 &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; &gt; &lt;TextView android:id=&quot;@+id/tv_lottery_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerInParent=&quot;true&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@android:color/darker_gray&quot; android:text=&quot;恭喜您，荣获2016年年度最佳程序员&quot; /&gt; &lt;com.sugary.roundimageview.LotteryView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; /&gt; &lt;/RelativeLayout&gt; 小结 刮刮卡的中奖内容是放在TextView控件，作为最底层显示。 如果项目里需要有刮卡完成后回调，可以计算刮除的面积与刮刮卡总面积的比例，超过一定值，即认为呱卡完成。 后续的优化方向可以是，把底层的TextView放到LotteryView自定义控件里]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的Gradle打包安全么]]></title>
    <url>%2F2016%2F12%2F11%2F2016%2F2016-12-11%2F</url>
    <content type="text"><![CDATA[现在Android项目的构建几乎都使用Gradle，Gradle提供了命令行打包，通过执行任务的方式，操作起来很方便。 通常Gradle打包的方式 比如通常我们会如下这般处理： signingConfigs{ release{ storeFile file(&quot;/xxx.jks&quot;) storePassword &quot;111&quot; keyAlias &quot;demo&quot; keyPassword &quot;222&quot; } } productFlavors { yingyongbao { //根据渠道需要配置参数 } } 这里我假设需要打应用宝的渠道包，在命令行窗口，或者直接在AS的Terminal窗口，进入到项目根目录，使用Gradle命令行打包： ./gradlew assembleYingyongbaoRelease 如果团队里有人用了Window系统提交，第一次使用Mac系统提交，很可能会遇到Permission Denied问题，解决办法：我的上一篇博文当Window遇到Mac OS出现Permission Denied／Could not expand时 更安全Gradle打包的方式上述方式打包是成功的，但是这里存在安全性问题： 安全隐患一：签名文件jks默认放在模块目录里，连同代码一起提交到服务器上，如果团队使用第三方的提交后台，安全隐患明显 安全隐患二:签名的密码，别名等内容直接暴露在build.gradle文件里 基于上述的考虑，下面是更安全的打包签名配置： signingConfigs { release { storeFile file(RELEASE_SIGNING_FILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD } } 在项目根目录gradle.properties文件里，存放签名信息 RELEASE_SIGNING_FILE = ../../xxx.jks RELEASE_STORE_PASSWORD = 111 RELEASE_KEY_ALIAS = demo RELEASE_KEY_PASSWORD = 222 然后在.gitignore文件里添加一条语句（不提交gradle.properties文件到服务器） gradle.properties 安全分析通过相对路径，我们把签名文件放在模块目录上二级，即和项目目同级，解决了安全隐患一 利用了gradle.properties文件里的键值对信息能直接在build.gradle中引用的方式，解决了安全隐患二 其他团队成员第一次使用这种配置打包的时候，需要本地更新自己的gradle.properties内容。 小结上述安全的Gradle打包，有一个前提是允许项目里的gradle.properties文件不上传到服务器。有的团队，安卓项目因为一些特殊原因非得需要上传gradle.properties文件呢？那就只有自己新建一个.gradle文件存储签名信息了，详见kevin_nazgul的android签名文件存放的另一种方式 参考资料： Gradle for Android By Kevin Pelgrims stackoverflow：How to create a release signed apk file using Gradle?]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌2016年GDD记录]]></title>
    <url>%2F2016%2F12%2F09%2F2016%2F2016-12-09%2F</url>
    <content type="text"><![CDATA[12月8日，在北京国家会议中心（奥林匹克公园），一场谷歌技术狂欢，刚参加完，感觉很赞，简短纪录下。 本次大会活动有三个部分： 开幕式和七个分会场的技术演讲。内容包含Android，Daydream，Tango，Firebase，Angular，TensorFlow等等。同一个时间段不小心出现了多个都想听的演讲主题，那就只好取舍了一番（会后看录像视频） 谷歌新技术体验馆。现在总结，感觉听演讲的时间没必要那么多，可以抽更多的时间在体验馆上感受谷歌产品和技术。 休息区，散落的小游戏小抽奖，免费自助午餐，下午茶，Party晚宴。这部分真心赞，明年继续参加。 开幕式之后，关注和听了如下专题： Android Studio2.0/2.1/2.2的新功能。会上我问了一个问题,Android应用开发，一直以来都用Java，谷歌会打算变动语言或者有这样的安排么？演讲嘉宾叫胡坤，他回答谷歌没有这样的安排。不过我想，即使有，这样的高层决定，估计也不是中国片区的人能最早知道的，即使知道了，也不会在不合适的时间点对外公布。 Android support library最新变化。讲的很快，更多是知道有什么变化，也漏说了一些，实际开发需要的很多细节，需要自己动手。还有，新版的Support Library拆成多个独立的模块板，开发者可以根据需要单独引用依赖。 Android电池和内存优化。这部分演讲嘉宾从Android 6.0/7.0电池和系统特性，给出了开发建议，具体的代码的实现和tips建议说得很快，但还是有干货。 Daydream介绍，入门说明和讲解。直接体验感觉更深刻 Tango简介，我的理解是谷歌开发的一套算法并提供了调用的API接口，提供给开发者增强现实技术所需的计算和分析结果。如何动手开发一款Tango应用，在谷歌开发文档上有仔细的讲解，文末给出链接了。当然前提是需要有一款支持Tango的手机。 WebApp的未来 在优酷谷歌开发频道和其微博能看到这次大会的视频，视频内容相当详尽了。 google／Android官方网站和资源：（推荐） Google Developers中国网站 优酷Google开发频道视频 谷歌中国的官方微博（新浪微博） 另外谷歌也开通了微信公众号，这个也是很好的渠道了解谷歌（尤其是在中国的）最新动态]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>GDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Window遇到Mac OS出现Permission Denied／Could not expand时]]></title>
    <url>%2F2016%2F11%2F30%2F2016%2F2016-11-30%2F</url>
    <content type="text"><![CDATA[最近用gradle打包安卓新项目时 ./gradlew assembleRelease 出现Permission Denied提示 错误场景在检查gradle配置信息无误后，使用管理员权限打包 sudo ./gradlew assembleRelease 这样能顺利打包，不过使用debug调试模式编译项目时，依然报错：Could not expand…我遇到的错误忘记记录了，大概类似如下的错误： Execution failed for task &apos;:app:prepareComAndroidSupportAppcompatV71901Library&apos;. Could not expand ZIP &apos;/opt/android-sdk/extras/android/m2repository/com/android/support/appcompat-v7/19.0.1/appcompat-v7-19.0.1.aar&apos;. 错误分析遇到这样的情况，十有八九因为团队成员用了不同的操作系统开发，特别是，有人用Window开发，有人用Mac开发，git版本管理下，这两个操作系统对文件权限的管理方式是不同。 解决该错误，涉及到的操作有： 查看项目目录权限ls -l yourFilePath 我对一个安卓项目的根目录查看了权限，显示结果如下： drwxr-xr-x 24 sugarya staff 816 11 3 16:12 Ferrari 这里第一个字母d表示文件类型，r表示可读，w表示可写，x表示可执行 修改项目目录权限Mac上鼠标操作右键要修改的目录，点击显示简介，底部有一栏共享与权限，列出了该目录的权限情况，手动修改之。 用文字设定法chmod [who] [+ | - | =] [mode] 文件名? ，详细情况可阅读参考资料 用数字设定法假定要修改的目录为当前路径下名为myDirectory的文件夹 sudo chmod -R 777 myDirectory 如此myDirectory目录的权限就改为drwxrwxrwx，即该用户，同组用户以及其他用户都具有写、读、执行的权限 小结权限修改完成后，再次使用gradle打包，一切变得顺利了 参考资料： mac os x 文件权限管理 如何设置文件夹权限为777 mac os x系统下 chmod +x comdfile StackOverFlow：gradlew:Permission Denied]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓App项目开发的几点认识]]></title>
    <url>%2F2016%2F11%2F22%2F2016%2F2016-11-22%2F</url>
    <content type="text"><![CDATA[团队多人开发下项目第一级目录按功能模块划分，二级分类按控件划分。这个原则对res目录下的values目录同样适用。也即：colors，strings，dimens，atrr，style文件要创建多个，用功能模块分类，这样提交代码时，方便审核，较少提交冲突。对需要相互依赖的文件，统一放在一个目录下集中体现 跳转逻辑一部分放在Navigator静态类里，一部分逻辑封装到BaseActivity的Protect方法（如果所有逻辑都封装在父类，增加了父类负担，代码可读性降低） 约定思维接口定义，泛型的使用位置，方法入参，返回数据这些都体现着约定思想，谁调用我，就要按我的约定规则来。约定规则怎么写才能表示约定人的意图呢？这要用到约定规则的规则Java语法和使用。学好Java才能让程序员充分表达自己的逻辑和意图。 RxJava操作符：创建型： create,just,from, range,interval combineLatest concat(多个流按顺序串行发射),merge（多个流交叉合并成一个流发射）,zip（多个流合并成一个流后统一发射） 处理型： map,flatMap(交叉发射),concatMap（串行发射） repeat，take，takeLast first（只发射满足条件的第一个），single（只发射顺序为第一个的数据源） debounce(发射最后一次) concatWith skip（N） 抑制Observable发射的前N项数据 merge(count,skip)每接收到count个数据后，将该count的个数据打包，并跳过第skip个数据，发送给订阅者 RxLifecycle使用Github主页 RxJava 中 merge, contact,compose 区别 RxJava操作符之takeUntil 带你学开源项目：RxLifecycle-当Activity被destory时自动暂停网络请求 Java中，父类和子类如何配合，以实现一个完整逻辑父类盛放共有的，具体的，稳定的的变量和方法，子类相对于父类具有拓展能力和行为，不同子类有不同方法 明确谁是导演类（Director Class，顶层的导演类也称为客户端类，用这样的方式划分体现类与类的调用关系） 如果是父类是子类的导演，父类调用子类，则子类实现父类的抽象方法或者重写Protected方法。此时，站在父类角度看：模块逻辑的执行顺序在父类里规划，站在子类的角度看：子类是具体逻辑的战场，父类是援军，父类在调用是，把自己的变量（援军）通过方法参数传给子类，具体逻辑的实施（战场）在子类方法里。 如果子类是父类的导演，子类新的方法里调用父类的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 下]]></title>
    <url>%2F2016%2F10%2F30%2F2016%2F2016-10-30%2F</url>
    <content type="text"><![CDATA[现状无法马上摆脱人们往往低估环境的巨大能量。尽管天赋确实很重要，但一个人能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间，只要足够认真，努力，他的能力就会不停地积累。每一时刻的现状都是过去某一或者某些时刻的结果。而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。 对现状的不满，急于摆脱现状，是人们常常不知不觉落入的陷阱（尽管偶尔这也是少数人真正的动力）。接受现状才是最优策略：有什么做什么，有什么用什么；做什么都做好，用什么都用好。不要常常觉得苦（这会让人顾影自怜，浪费精力和时间），而要想办法在任何情况下找到情趣，快乐是一种本事。 优秀的年轻人几乎都有这样的特征：很少对现状不满，热爱自己的生活，相对更不在意外界的影响，更专注于做事而心无旁贷，身处良性循环之中。 怎样判断所做的事情是否正确？核心只有一个：看它是否现实。 把时间当作朋友 第三章传送门 侯世达定律：完成一个任务实际花费的时间总会超过计划花费的时间，就算制定计划的时候考虑到本法则。 要提高估算时间的能力，就要从现在开始养成习惯：做任何事情之前先判断其熟悉程度（或陌生程度），再据此判断估算完成任务所需要的时间。 及时行动所谓做事拖延，不是拖延着做事，而是拖延着不开始做事。 拖延的人为什么迟迟不开始行动？错误的估算所需的时间来自内部的恐惧只要开始做事，一个人就要面临做错，做不好的风险。拖延症患上一个简单的认知错误：认为哪些能够做对做好的人都是直接做对，做好的。很多人做事拖延不过是“不求有功，但求无过”的心态在作祟。而现实是：只要做事，就一定会出问题。 做事情的时候，肯定会遇到困难，事情越有价值，困难就越具规模。遇到困难的时候，心平气和地面对就好，因为这只不过是生活常态。 有时我们花费了很多时间和精力依然没能解决问题，却眼见别人轻松过关，这确实令人气馁。不过这也是生活常态：在任何一个特定领域，总会有一些人比另一些人表现更好，费力更少。 接受现实，勤能补拙。 来自外部的恐惧这段的描述太好了，忍不住要站立鼓掌。 过分在意外界的评价。人是一种很有趣的动物，在自己作对，做好之前，通常已经了解作对，做好是什么样子。于是，无论能否作对，做好，人都觉得自己有能力判断别人是否作对做好。所以，尽管自己不怎么样，却可以振振有词、理直气壮地评价别人做得对不对、好不好。因此，可以得出一个推论：一个人一旦开始认真做事，被嘲弄、被耻笑的几率将远远高于被夸奖、被鼓励的几率。 那些真正能够作对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走来，心理非常清楚作对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。 如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会像那些极少数已经做对、做好的人一样，给予别人真诚而非嘲弄。也有时候，那些能真正做对、做好的人也会给出负面评价，但那通常都是“建设性的负面评价”，并不是为了获得优越感而发出的嘲弄。 没有谁一开始就能做对、做好。所有做对，做好的人都是一路磕磕绊绊走过来的，这就是生活的常态 动辄给出非建设性负面评价的人，往往不是正经做事的人，他们和那些正经做事的人身处不一样的世界，这也是生活的常态。 为什么随着年龄的增加每个人都会觉得时间过得越来越快？对一个5岁的孩子来讲，未来的1年相当于他已经度过的人生的¹⁄₅，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的¹⁄₅₀，即2%。所以，随着年龄的增加，人们会觉得时间运动得越来越快。 小结几乎一切愚蠢的行为都来自否定现实，逃避现实。时间是现实的人的朋友，是不现实的人的敌人。 最后期限不是固定在将来某一个点，而是朝着你加速扑来。如果在起步晚了的情况下，问题不是“到时候能不能做好”，而是“到时候能做多好就做多好，总好过什么都不做”。所以，不管遇到什么任务，最好的开始时间就是：现在]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 上]]></title>
    <url>%2F2016%2F10%2F28%2F2016%2F2016-10-28%2F</url>
    <content type="text"><![CDATA[近来休息了一段时间，期间也看了几本闲书。比如魔天记，真灵九变这类网络小说；比如杨冰阳女士（ayawawavip）的完美关系的秘密，讲述两性关系的相处。原本希望通过这本书让自己不仅是能深耕的好码农，还能是把妹届的老司机。 最近在看的是，笑来老师的把时间当作朋友，大赞，是价值观的更新，我做了读书摘要和思考。 技术的速成是不可能的时间不可管理，为什么大家都想要速成呢？ 这是人们追求收获的欲望当达不到不劳而获的时候，少劳多获也是可以接受的。如果收获的可能性很大，我们就会想尽快看到结果；如果收获的可能性很小，我们就会想尽快知道结果。 很多时候我们不清楚某些“阶段”不可省略事物的成长需要时间，成驻败空，缘起性空，因缘和合，这些阶段是客观存在。怀胎十月，才有健康的宝宝诞生人间。接受这个客观的过程，技术的进步也是。 基于对“现状”的不满意有时候，我们意识里知道上诉两个道理，但是为什么还会想要尝试速成，去抓住那个万一成功了呢。源于对当下现状的不满意，想要去改变。 笑来老师书里引用了一位老外的的统计分析研究，对人一生各个阶段满意感的分布。发现，从15岁左右开始，人的满意感一直在下降，直到50，60岁后开始上升。这个挺有趣的想象，也可以用来解释某些人产生“中年危机”感的心里诱因。 完美永不存在。笑来老师如是说： 没有什么事情是一下子就能做好的。我们至多能做到接近完美，或者更接近完美。所以，不管做什么事情，都需要时刻忍耐各种的不完美，否则事情根本无法完成。最终完成的事情，结果也常常是不完美的。缺陷必然存在。再往大一点说，生活本省就不完美。谁的生活不是磕磕绊绊？谁死去的时候没有一丝遗憾？现实如此，只能接受。* 这段话的意思，我可以概括为：因上精进，果上随缘。没有结果是完美的，但是不妨碍我们在追求的路上努力做到最好。 未知永远存在笑来老师如是说： 我们害怕未知，害怕不确定的东西。我们希望一切都在自己的掌握之中，只是我们永远做不到。随着未知因素数量的增加，有序排列可知，这些因素所引发的结果的数量将以几何级数的方式飞速增加。* 在自学一项技能的时候，存在一种“牛角尖陷阱”，为此，我们必须忍受一定的未知。承认自己不可能全知全晓，因为客观存在一些情况，如：有些时候有些问题没有答案（先有鸡还是先有蛋），即便有些问题有了答案，其原因也不见得我们能够搞懂（顺序，分支，循环就能够完成任何流程控制）在这种情况下，暂时不去问为什么，可能更划算* 学习一门新课程，会发现，第一章的内容需要在掌握后面某一章知识之后才能深入了解。在学习第一章的时候，我们会有无数疑问以当时的知识是无法全部解答的，需要我们继续学习，用接下来的知识解答现在的疑问。* 我可以类比，推而广之。比如父母老师教导的行为，小时候不以为然，觉得枯燥，无聊无用，长大后，才恍然醒悟。因此，对于经典的，历来传颂的事物和行为，与其现阶段搞不明白的情况下非要弄明白好坏益处，还不如先行动起来。 焦虑的产生笑来老师如是说： 接受未知永远存在，不断尝试适应：在未知中不断前行。如果不接受这个现实，无法忍受未知的存在，会平添无数的焦虑。关于这一点，本人有过好多次体验。* 焦虑导致时间浪费，效率低下。处于焦虑状态下时，甚至可能出现一切理智都被清空的情况，会让人觉得“必须要做点什么”，但是，在这种缺乏理智状态下的任何决定和行为都可能带来灾难性的后果，陷入恶性循环。如何解决？一个有效的方法就是把问题先记录下来。* 小结上述仅仅是第一章的部分内容，把时间当做朋友一书和稻盛和夫先生活法里的观点（人生和工作的结果=思维方式(-100～+100)×热情(0～+100)×能力(0～+100)）不冲突，能感受到是另一种方式的阐述，有继续读下去的冲动。 时间不可管理，我们先学会接受：完美永不存在，未知永远存在。基于这样的接受去认识时间，把时间做为朋友相处。 传送门： 把时间当作朋友]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBus学习之旅－从入门到提高]]></title>
    <url>%2F2016%2F08%2F13%2F2016%2F2016-08-13%2F</url>
    <content type="text"><![CDATA[在公司的技术分享会上，做了关于RxBus的学习分享，记录如下： 一.RxBus与RxJava一次RxJava调用过程可以划分为以下环节： 创建观察内容 （片段1） 数据处理／映射（片段2） 选择线程（片段3） 订阅（片段4，片段5） 完成／错误处理（片段6） 示例代码： Observable // 片段1 .create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String trim = mainEd.getText().toString().trim(); subscriber.onNext(trim); subscriber.onError(new Throwable()); subscriber.onCompleted(); } }) // 片段2 .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s + &quot; sugarya&quot;; } }) // 片段3 .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) // 片段4 .subscribe( // 片段5 new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } //片段6 @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv2.setText(s); } }); 二.RxBus与接口回调一次完整的接口回调，包括四个步骤： 接口定义 接口调用 接口实现 接口注入 RxBus的使用过程，就是一个接口回调的过程。 接口定义，在RxJava定义好了。 上面示例代码片段1里的suscriber.onNext(),onStart(),onError(),onComplete()对应接口调用。 代码片段5，片段6这些是接口实现 注入的过程是调用suscribe()方法订阅的过程 三.RxBus源码分析RxBus的代码实现如下： public class RxBus { private static volatile RxBus instance; private final Subject&lt;Object, Object&gt; _bus; private RxBus() { _bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); } public static RxBus getInstance() { if (null == instance) { synchronized (RxBus.class) { if (null == instance) { instance = new RxBus(); } } } return instance; } public void send(Object object) { try{ _bus.onNext(object); }catch (Exception e){ e.printStackTrace(); } } public boolean hasObservers() { return _bus.hasObservers(); } private &lt;T&gt; Observable&lt;T&gt; toObservable(final Class&lt;T&gt; type) { return _bus.ofType(type);//filter + cast } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Observer&lt;T&gt; observer) { return toObservable(type).subscribe(observer); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1) { return toObservable(type).subscribe(action1); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1, Action1&lt;Throwable&gt; errorAction1) { return toObservable(type).subscribe(action1,errorAction1); } } 接下来对上述代码做些简要分析： volatile 保证instance可见性 禁止指令重排 这里涉及到Java内存模型，相关资料： 传送门 SerializedSubject SerializedSubject extends Subject extends Observable implements Observer，既是观察内容，又是观察者，起到桥梁／数据转发的作用 保证多线程安全，Subject 当作一个 Subscriber 使用，从多个线程中调用它的onNext方法（包括其它的on系列方法） PublishSubject主题，RxJava里有四种主题 PublishSubject BehaviorSubject ReplaySubject AsyncSubject PublishSubject的含义是：在订阅者订阅的时间点之后的数据发送给观察者 ofType操作符 = filter操作符 + cast操作符 filter只有符合过滤条件的数据才会被“发射” cast将一个Observable转换成指定类型的Observable CompositeSubscription该对象作为subscription的容器，方便统一取消订阅 四.RxBus异常处理当RxBus在执行过程中，任意环节发生了错误异常，订阅关系就会被取消。之后再次发送，将无法执行订阅后的回调。 做了一个数组越界的错误来演示 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); onRxBus(); } private void onRxBus() { int[] array = new int[2]; RxBus.getInstance().toSubscription(Integer.class, new Subscriber&lt;Integer&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { //onRxBus(); Log.e(TAG, &quot;mSubscriber17 onError: &quot; + e.toString()); } @Override public void onNext(Integer integer) { array[integer] = integer; Log.e(TAG, &quot;mSubscriber17 onNext:&quot; + integer); } }); } @OnClick(R.id.btn_main17) void onClick17() { RxBus.getInstance().send(2); } 这时候点击button按钮，数组越界异常，第二次再点击Button发送消息，没有响应了。这里，RxBus，确切的说是RxJava捕获到错误异常，就会取消订阅关系。 E/MainActivity: mSubscriber17 onError: java.lang.ArrayIndexOutOfBoundsException: length=2; index=2 解决的思路： 使用try－catch捕获异常，不让异常被RxJava捕获 在onError里重新订阅。 接下来说说第二种方法，具体怎么操作，其实就是在onError方法里，重新执行一遍订阅，执行上述注释掉的代码onRxBus,就解决问题了。 五.小结上述其实是这次技术分享大纲，技术分享准备功课前，刷了下面的文章，要对RxBus有更细致的学习和了解，可以阅读：（推荐） 谢三弟系列RxBus简单实现 RxBus深入源码解析 RxJava里onError异常处理 Yokey系列RxJava实现事件总线 RxBus异常处理 RxBus实现Sticky事件（粘性订阅） 其他RxBus从基础实现到升级——打造属于自己的RxBus EventBus和RxBus实现和性能比较]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》之如何创造财富]]></title>
    <url>%2F2016%2F08%2F08%2F2016%2F2016-08-08%2F</url>
    <content type="text"><![CDATA[这本书有很多特别有趣，以前从来没有思考过的观点，在读第6章如何创造财富的时候，这种震撼非常强烈。记录如下： 创业就是一个压缩过程你所有的工作年限被压缩成了短短几年,不再是低强度地工作四十年，而是以极限强度工作四年。伴随而来的是工作压力也压缩到三四年，承受如此大的压力，带给你额外的报酬。 金钱不等于财富，创造有价值的东西就是创造财富财富和金钱不是同义词。我们需要的东西就是财富，食品，服装，住房，汽车，生活用品，外出旅行等都是财富，即使你没有钱，你也能拥有财富。 要是你身处南极洲内陆，再多的钱对你也是无用的，因为没有东西可买，你真正需要的是财富。 如果财富这么重要，为什么大家都却把赚钱挂在嘴边而不是财富呢？因为金钱是财富的一种简便的表达方式，是专业化的副产品。 比如你本人能制作小提琴，而你需要土豆，附近的农民对小提琴不感兴趣，那么你怎么能交换到土豆呢？ 当社会分工越来越精细后，人们把贸易分为两步：不是直接用小提琴交换土豆，而是先用小提琴交换金钱，然后再用金钱交换需要的东西。所以让自己变的富有，就是制造出人需要的商品，让别人用金钱交换商品，你拿到金钱，你就可以拿着赚来的金钱向任何人交换自己需要的其他商品。 交换媒介的优点是，它使得交易可以进行下去，缺点是，它模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介（一般等价物），做生意直接原因是为了获取中介，出发点应该是创造供他人需求的商品，让大家可以获得自己想要的东西。大多数生意的目的是为了做出人们真正需要的东西，创造财富。 如果我们要大量获取一般等价物，就应该抱着特别怀疑的态度，去思考那些着眼于你自己感兴趣的东西的商业计划。对于自己感兴趣的东西，你会聚的它们很有价值，但是它们恰恰最不可能与他人眼中的有价值的东西发生重合。 世界上的财富总额不是固定不变的，财富一值在不停地增长比如，一台坏机器因为一个零部件松了而不能正常运转，你把零件拧紧，机器重新运转，那么你便创造了财富。 程序员是手工艺人，创造着大量的财富我们这个世界，向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。许许多多不创造财富的人，听到最富有的5%人口占有社会一半以上财富，往往认定这事不公平的，就像最顶级的程序员写出了全世界99%的优秀软件。 创造出来的财富不一定非要通过出售实现价值，人们需要的东西就是财富，极客经常开发开源软件让所有人免费试用，把自己的工作捐献给社会。 工作是什么财富就意味着人们需要的东西。公司的存在目的就是满足人们的某种需要。作为公司的一分子与许多人一起合作完成，感觉自己是为了公司的需要而工作，其实是为了满足顾客的某种需求而工作。一分子的贡献也许不是直接性的，但是公司作为一个整体必须提供某种人们需要的东西，否则不可能盈利。 当初刚毕业，我对自己说，我需要进入一家公司工作，好像成为某个组织成员是一件多么重要的事情。然而更确切的表达是：我需要去做一些人们需要的东西。即使不加入公司，我也能做到，公司不过是一群人在一起工作，共同作出某种人们需要的东西。 真正重要的是做出人们需要的东西，而不是加入某个公司]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《途客圈创业记》有感]]></title>
    <url>%2F2016%2F07%2F31%2F2016%2F2016-07-31%2F</url>
    <content type="text"><![CDATA[不知道去年因为什么缘故，阅读了MacTalk原编程一书，关注了池老师的公众号，于是连带的关注了小道消息，嘀嘀嗒嗒，程序人生等公众号，这本书的作者就是程序人生的Tyr Chen 上周周二到手，工作日读了一半，今天傍晚一口气读完剩下的一半。心中有沉沉的思绪，做个读书小结，整理记录下。 技术人员从公司组织架构上是不是不适合作为第一大股东呢？Tyr散发的气息真得就是大多数有追求的程序员共有的特质，大凡热带代码，热带技术的人都会相似的逻辑思维。即使我也创业，我想我的遭遇和因对和情绪表达也是差不多的，CTO对于公司的角色定位，在技术和管理上，要被赋予更多管理的职责。 因此，如果醉心于技术成长，醉心于成为一名酷范十足的极客，CTO不是极客状态下的程序员的职业追求，技术级别悠长的技术性导向的盈利公司会是个好选择之一，成长为技术合伙人。 技术合伙人是高级段位的职业，再上一层，我觉得，也有，但是已经不再是仅仅磨练技术就能达到的了。这是极客下一个阶段或者状态的事吧。而我要向通往极客道路上前进。 感谢途客圈创业记一书，让我知道创业的过程和注意事项，这些过程和事项是认真的，是真实的，是鲜活的。 本周六有Try Chen关于本书的读者见面会，充满期待。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用小结之入门篇]]></title>
    <url>%2F2016%2F07%2F21%2F2016%2F2016-07-21%2F</url>
    <content type="text"><![CDATA[在Java的世界里，接口是Java最强大的设计之一。笔者对接口的认识和理解包括： 实现一个接口需要四个步骤 接口定义：使用interface，可以外部定义，也可以在类中定义，根据实际需求来。 接口调用：接口定义好了，需要调用接口方法 接口实现：接口里的方法是抽象方法，需要开发人员具体的逻辑实现 接口注入：把接口实现的引用传给接口调用方。 接口的作用和意义： 通过入参，确定了一种数据流的流动方向，从接口调用方流向接口实现方。也即提供了一种代码执行的先后顺序。 降低代码的耦合。实现接口是java类与类之间的一种关系，比继承这样的强依赖的耦合度低。接口涉及Java六大设计原则里的依赖倒置原则和接口隔离原则，面向抽象编程，对调用者来说执行相同的行为（代码），却可以组织不同的逻辑。 作为静态常量的容器。可以在接口里定义各种常量。 在Android里的基本使用Rxjava每一次observable发出事件，让订阅者执行，都是一次使用接口的过程，满足上述分析的四个步骤。 Observable.create()使用EditText里输入内容，TextView显示 （1）Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String s = mainEd.getText().toString().trim(); subscriber.onNext(s); subscriber.onCompleted(); } }); （2）Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv.setText(s); } }; （3）observable.subscribe(subscriber); 分析： 代码段（1）Observable.create()方法里，new Observable.OnSubscribe(),完成了subscriber接口的调用。代码段（2）使用匿名内部类，完成了接口定义和接口实现。代码段（3）完成了接口注入。 因此说，一次Rxjava的操作，就是一次使用接口的过程。明白了这点，如果以后引入Lambda表达式，也就不再容易感到困惑和不解了。 Observable.Just()使用上述代码可以简化写成下面的样子 String trim = mainEd.getText().toString().trim(); Observable.just(trim).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { mainTv2.setText(s); } }); Just和Create生成Observable的关联和区别： just生成的Observable只调用了接口subscriber的onNext()和onComplited()。 just代码执行是在订阅subscribe()方法调用之前，通过create生成的observable在订阅subscribe()方法调用的时候执行 Observable.from()使用入参可以是集合或者数组，该集合或数组有多少个元素就会发送多少次事件。 StringBuilder sb = new StringBuilder(); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;step1&quot;); list.add(&quot;step2&quot;); list.add(&quot;step3&quot;); list.add(&quot;step4&quot;); Observable.from(list).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { sb.append(s+&quot; &quot;); } }); mainTv3.setText(sb.toString()); 上述代码返回的结果是：step1 step2 step3 step4 小结有了上述的认识和练习，相信对Rxjava有了一个入门的学习和使用了。 参考资料 深入浅出RxJava（一：基础篇） Github:RxJava]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当RecyclerView遇到Inconsistency detected崩溃时]]></title>
    <url>%2F2016%2F07%2F20%2F2016%2F2016-07-20%2F</url>
    <content type="text"><![CDATA[近来项目里，RecyclerView更新数据偶尔出现crash，错误日志如下： java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder{2064e5c6 position=2 id=-1, oldPos=2, pLpos:-1 scrap [attachedScrap] tmpDetached no parent} at android.support.v7.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition(RecyclerView.java:4505) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4636) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4617) at android.support.v7.widget.LinearLayoutManager$LayoutState.next(LinearLayoutManager.java:1994) at android.support.v7.widget.LinearLayoutManager.layoutChunk(LinearLayoutManager.java:1390) at android.support.v7.widget.LinearLayoutManager.fill(LinearLayoutManager.java:1353) at android.support.v7.widget.LinearLayoutManager.onLayoutChildren(LinearLayoutManager.java:574) at android.support.v7.widget.RecyclerView.dispatchLayoutStep1(RecyclerView.java:2979) at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:2904) at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3283) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutHorizontal(LinearLayout.java:1948) at android.widget.LinearLayout.onLayout(LinearLayout.java:1724) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.Line 遇到这类错误java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder，通过查阅Stackoverflow和资料，总结了如下情况和解决方法： 方法一自己写一个继承LinearLayoutManager的包装类，在onLayoutChildren()方法里try-catch捕获该异常。 @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { try { super.onLayoutChildren(recycler, state); } catch (IndexOutOfBoundsException e) { e.printStackTrace(); } } 方法二在进行数据移除和数据增加时，务必要保证RecyclerView的Adapter中的数据集和移除／添加等操作后的数据集保持一致！ 这里，前者是在该Adapter内部，不妨叫做内部数据集，后者是开发人员传过给Adapter的，不妨叫外部数据集。更新RecyclerView数据时，需要保证外部数据集和内部数据集实时保持一致。 外部数据集同步到内部数据集，使用如下的方法： notifyItemRangeRemoved(); notifyItemRangeInserted(); notifyItemRangeChanged(); notifyDataSetChanged(); 这里对notifyDataSetChange()做些说明： 使用该方法的更新内部数据集，没有默认的动画效果，同时更新数据的效率页不如上面的方法，官方不推荐使用这种方式更新数据集。 Don’t call notifyDataSetChanged if you don’t have to. RecyclerView的Adapter里，发生异常的错误代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null ) { mPoiItems.clear(); mPoiItems.addAll(poiItemList); notifyItemRangeChanged(0, poiItemList.size()); } } 错误分析： mPoiItems是外部数据集，对该外部数据集做了两个操作：先移除数据，然后添加数据，之后notify数据集。这里，添加数数据时（Adapter的内部数据集内容还处在外部数据集移除数据之前），造成了内部和外部数据集不一致。 这是一方面，另一方面，我使用了notifyItemRangeChanged()来更新数据，如果poiItemList传过来的新数据和原来mPoiItems的数据数量不一致，就会出现内部数据集和外部数据在同步后不一致，从而报错。 修复后，运行正常的代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null) { int previousSize = mPoiItems.size(); mPoiItems.clear(); notifyItemRangeRemoved(0, previousSize); mPoiItems.addAll(poiItemList); notifyItemRangeInserted(0, poiItemList.size()); } } 修复分析： 每一次对外部数据集做改动时，都需要紧接着主动对外部数据集和内部数据集做一次同步操作，动画效果也得到了保持（使用方法三，动画效果缺失） 方法三：使用notifyDataSetChanged同步外部数据集和内部数据集。该方法简单，但是失去了动画效果，并且更新数据的性能低。 use notifyDataSetChanged() will avoid this crash, but it will kill Animation and Performance. 另外，如果对外部数据集做了二次以上的操作，却只调用notifyDataSetChanged同步一次，也很有可能会报上文所示的错误。 ###参考文章: stackoverflow 1 RecyclerView Bug：IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter的解决方案 使用RecyclerView遇到的一些问题 Inconsistency detected]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 下]]></title>
    <url>%2F2016%2F07%2F10%2F2016%2F2016-07-10%2F</url>
    <content type="text"><![CDATA[最近看到一个专题讲解Java内存模型的，感觉干货满满，现记录如下： 深入理解Java内存模型（一）——顺序 深入理解Java内存模型（二）——重排序 深入理解Java内存模型（三）——顺序一致性 深入理解Java内存模型（四）——volatile 深入理解Java内存模型（五）——锁 深入理解Java内存模型（六）——final 深入理解Java内存模型（七）——总结 在我之前的一篇博客Java内存模型 上一文里，对Java的内存做了一番简单的梳理。通过上述专题的阅读和学习，又有了新的认识和思考。 关于Java的锁当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。这一操作和volatile变量的写操作相同功效 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，这一操作和volatile变量的读操作相同共享 也即是文中总结的：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 由此也自然联想到，Java锁的内部实现，其实就是通过volatile来实现的。 这里还涉及到公平锁，和非公平锁，这两者的区别是： 公平的锁上，线程按照他们发出请求的顺序获取锁.当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。 关于Java的final对于final域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。 重排序重排序分为两大类： 编译器重排序 处理器重排序，该排序可细化为指令级并行的重排序和内存系统的重排序 内存屏障：对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止） 内存模型越是追求性能的处理器，内存模型设计的会越弱,模型由强变弱依次为： 顺序一致性内存模型 JMM 处理器内存模型 happens-before:如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间. 参考资料Java 理论与实践: JDK 5.0 中更灵活、更具可伸缩性的锁定机制]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动读取短信验证码LoaderManager／CursorLoader的使用]]></title>
    <url>%2F2016%2F07%2F06%2F2016%2F2016-07-06%2F</url>
    <content type="text"><![CDATA[Cursor用来直接读取安卓手机里的数据库记录，如何获取到Cursor？ 可以通过SQLiteOpenHelper，打开SQLiteDatabase 通过ContentProvider/ContentResolver获取 自动读取验证码实现思路： 当验证码的短信到来，能有个监听回调或者广播之类，告知开发人员 读取短信是危险权限，android6.0权限适配 获取验证码的短信内容 从短信内容里刷选出验证码 显示验证码 接下来针对每一个步骤，做些分析和代码分享 监听接收到新短信使用ContentResolver，引入内容观察者，监听短信内容的变化，代码如下： public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public void initReadSmsLoader(){ LoaderManager loaderManager = getLoaderManager(); if(loaderManager != null){ loaderManager.initLoader(0, null, new ReadSmsLoaderListener()); } } class ReadSmsContentObserver extends ContentObserver{ public ReadSmsContentObserver(Handler handler) { super(handler); } @Override public void onChange(boolean selfChange, Uri uri) { super.onChange(selfChange, uri); LOG.e(TAG,&quot;selfChange = &quot; + selfChange+&quot; uri = &quot; + uri); if(PermissionHelper.checkReadSmsPermission(mContext)){ initReadSmsLoader(); }else{ takeReadSmsPermission(); } } } 短信验证码，权限适配PermissionHelper是自己封装的工具类 PermissionHelper.takeReadSmsPermission(this,PermissionHelper.REQUEST_CODE_READ_SMS); 获取验证码的短信内容这里有多个方案，网上相当多技术文章使用contentResolver.query()方法。我认为这个方法不够好。 该方法在UI线程里操作的，当查询的数据库的记录很多时，会出现卡顿现象。 需要手动关闭Cursor，Cursor维护操作交给开发人员。 好在，安卓已经提供了异步的（子线程）数据库查询方式，使用LoaderManager和CursorLoader这两个类，不存在上述两个问题。代码如下更详细的LoaderManager.LoaderCallbacks各个回调方法的使用，可以参考android CursorLoader用法介绍 /** * 注册内容观察者 */ public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public class ReadSmsLoaderListener implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;{ private static Uri URI_SMS_INBOX = Uri.parse(&quot;content://sms/inbox&quot;); // &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;date&quot;, &quot;type&quot; private static final String[] READ_SMS_PROJECTION = new String[]{&quot;body&quot;}; private static final String READ_SMS_SORT_ORDER = &quot;date desc&quot;; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { //两分钟内，收到的短信，date降序排列 String readSmsWhere = &quot;date &gt;&quot; + (System.currentTimeMillis() - 2*60*1000); return new CursorLoader(mContext,URI_SMS_INBOX,READ_SMS_PROJECTION,readSmsWhere,null,READ_SMS_SORT_ORDER); } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { fetchSmsCodeFromCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } } /** * 从数据库获取短信并过滤出验证码 */ private void fetchSmsCodeFromCursor(Cursor cursor) { if(cursor != null) { while (cursor.moveToNext()) { String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;)); if (!TextUtils.isEmpty(body)) { //判断该短信是否是该App发送的 if (body.contains(&quot;走么&quot;)) { String verifyCode = getSmsCode(body); displayVerifyCode(verifyCode); break; } } } } } 从短信内容里刷选出验证码使用正则表达式筛选，按正则的使用套路走起 /** * 从短信中获取验证码 * @param smsContent 短信内容 * @return */ private String getSmsCode(String smsContent){ Pattern pattern = Pattern.compile(&quot;[0-9]{4,}&quot;); Matcher m = pattern.matcher(smsContent); while (m.find()) { String group = m.group(); if(group != null &amp;&amp; group.length() &gt;= VERIFY_CODE_LENGTH){ return group; } } return &quot;&quot;; } 显示验证码 /** * 显示验证码 * @param verifyCode 验证码 */ private void displayVerifyCode(String verifyCode) { mSmsCodeEt.setText(verifyCode); //获取焦点 mSmsCodeEt.setFocusable(true); mSmsCodeEt.setFocusableInTouchMode(true); mSmsCodeEt.requestFocus(); //设置光标位置 mSmsCodeEt.setSelection(verifyCode.length()); } ##总结至此，成功实现读取短信验证码。近来主流的App，并没有实现自动读取短信验证码，比如滴滴出行，钉钉。 ##参考资料 android CursorLoader用法介绍 CursorLoader LoaderManager]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CursorLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 上]]></title>
    <url>%2F2016%2F07%2F03%2F2016%2F2016-07-03%2F</url>
    <content type="text"><![CDATA[Java内存模型（Java Memory Model，JMM） 内存模型规定： 所有的变量都是存在主存当中（类似于物理内存） 每个线程都有自己的工作内存（类似于高速缓存） 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。 每个线程不能访问其他线程的工作内存。 缓存一致性（Cache coherence）问题当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中 在一个系统中，当许多不同的设备共享一个共同存储器资源，在高速缓存中的数据不一致，就会产生问题。也就是说如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 缓存一致性可以分为三个层级： 在进行每个写入运算时都立刻采取措施保证数据一致性 每个独立的运算，假如它造成数据值的改变，所有进程都可以看到一致的改变结果 在每次运算之后，不同的进程可能会看到不同的值（这也就是没有一致性的行为） 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK锁的方式 通过缓存一致性协议 最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的 它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 ##参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析 海 子]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程]]></title>
    <url>%2F2016%2F07%2F01%2F2016%2F2016-07-01%2F</url>
    <content type="text"><![CDATA[并发编程的三个问题：原子性问题，可见性问题，有序性问题 原子性概念简介 一个操作或者多个操作，要么全部执行，要么就都不执行 执行的过程不会被任何因素打断 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。Java内存模型只保证了基本读取和赋值是原子性操作。 Java语言提供的保证：通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 普通的共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值。 Java语言提供的保证 volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性程序执行的顺序按照代码的先后顺序执行。 指令重排序（Instruction Reorder）处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 处理器在进行重排序时是会考虑指令之间的数据依赖性。重排序会影响多个线程内程序执行的结果。换句话说，重排不会影响单个线程内程序执行的结果。 结论：指令重排的适用范围是线程，它不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 举个参考资料里的例子： 我相信，有经验的程序员，即使不懂的指令重排，本能上也不会用两个线程异步的执行下诉初始化操作。 //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingWithConfig(context); 计划执行：在线程1里执行语句1，初始化加载操作，完成后，标志位inited置为true，线程2，跳出睡眠，执行doSomethingWithConfig方法。 实际执行：由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 Java语言提供的保证：通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性 volatile关键字一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 volatile关键字的使用场景volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。因此，当保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 状态标记量 double check。 单例的最优写法: class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null){ instance = new Singleton(); } } } return instance; } } 参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/Protobuf之Protocol Buffers配置指南]]></title>
    <url>%2F2016%2F06%2F27%2F2016%2F2016-06-27%2F</url>
    <content type="text"><![CDATA[使用Protobuf，先配置环境，以下是配置Protobuf的步骤和编译Protobuf原文件的步骤 Java:Compiled Environment Download:https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-java-3.0.0-beta-3.zip Install:$ ./configure $ make $ make check $ make install Check version:$ protoc --version Protocol Buffers Outputhttps://developers.google.com/protocol-buffers/ To Objective-C(.h .m)$ protoc --proto_path=src --objc_out=build/gen src/foo.proto src/bar/baz.proto To Java(.java)$ protoc --proto_path=src --java_out=build/gen src/foo.proto –proto_path可以缩写为： －I Objective-C:####Download: https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-objectivec-3.0.0-beta-3.zip Install:$ objectivec/DevTools/full_mac_build.sh Building:There are two ways to include the Runtime sources in your project: Add objectivec/\*.h &amp; objectivec/GPBProtocolBuffers.m to your project. or Add objectivec/\*.h &amp; objectivec/\*.m except forobjectivec/GPBProtocolBuffers.m to your project. If the target is using ARC, remember to turn off ARC (-fno-objc-arc) for the.m files. The files generated by protoc for the *.proto files (\*.pbobjc.h&#39; and*.pbobjc.m`) are then also added to the target.]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活法3－寻找你自己的人生王道]]></title>
    <url>%2F2016%2F05%2F23%2F2016%2F2016-05-23%2F</url>
    <content type="text"><![CDATA[早些时候，就有想写写随笔。这个类目当作我阅读好书的笔记思考。 2011年，第一次读稻盛和夫《活法（壹）》一书，犹如闪电于混沌中飞越，对我的价值观带来一次迄今为止最大的更新和改动。 今天重拾活法－－系列叁，书读过半，深感于语句散发出来的韵律和共鸣。摘要如下： 能力出众，满腔热情，干净十足，事业一开始就拼命努力，若再有好运相助，成功便几成定数。相较于成功，保持成功更为不易。不论经营，政治或治学领域，“成功”不足为奇。成为不骄，谦虚律己，生命不息，克己不止，方才为人杰。只是这样的人似乎太正派，旁者看来颇为无趣。然而，若非颇为无趣之人，则不可能实现持久的成功 考虑到这是译文，也就不必在意成功这词的随意滥用了。 再摘引如下： 克己，临于万事欲克而不得。故先修身养性而后成也。 只有将“克己”精神融入自己的品性，血肉之中，事到临头才不致想克制也克制不了。为此，需积以时日，不断在平时就训练努力克制自己，抑制自身的欲望。 都天下无二道，圣人无两心。自天子以至于庶人，皆是以修身为本，其本乱而末至者，否矣。《大学》里的观点：平天下，治国，齐家，当从修身开始。 这里稻盛和夫讲得于旁观者看来无趣和我们要做个有趣的人说的有趣，概念会冲突么？这值得思考]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件工程里解决问题的思维]]></title>
    <url>%2F2016%2F04%2F10%2F2016%2F2016-04-10%2F</url>
    <content type="text"><![CDATA[今天在项目开发中，遇到一个问题，在尝试解决无果后，对解决问题的思维产生一番思考。记录如下。 在我看来，解决一个项目问题的思维能拆分成若干个环节，这些若干个环节彼此相互互斥，解决问题的过程被映射为一环环固化思维的串接。问题得到解决存在一个最小思维量。当认知超过最小思维量时，就能推测、预判问题的变化。 思维量存在且不限于以下两个属性：思维复杂度和环节确定性。思维复杂度表示解决问题的可能性数量或方向多少。环节确定性指的是：互斥并且单一的指向下一个思维环节。互斥和单一指向两者缺一不可。当一个环节在这个思维过程中与其它环节形成互斥，即表示这个思维环节是解决问题的有效组成成分；单一指向的作用是能促成思维导向同一个结果：解决问题。一个方向而不是多个方向，这大大的降低思维复杂度。 另一方面，每个思维环节的确定性大小会影响下一个环节的确定性。如果一个环节不确定是对是错、正确程度未知，就会导致该环节的指向不再单一而是多个。所以，不高的环节确定性会造成较高的思维复杂度，这是不利于工程问题的顺利解决的。 结论：基于上述认知，工程能力提高的过程其实就是增加思维环节确定性和数量的过程。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年的年度小结]]></title>
    <url>%2F2015%2F12%2F31%2F2015%2F2015-12-31%2F</url>
    <content type="text"><![CDATA[2015年，于我是全新的一年。很多事情，从这一年才开始走上轨道，我感到开心和幸运。在写这篇小结之前，读完了糊糊老师的年度小结散文，杂感繁多，就摘录一小段文字吧，如下： 人如何能说服自己用当下去换一个未来的结果，将现在的自己当成工具一般，去为充满了无常的未来牺牲此刻。一个不够快乐的过程，如何得来圆满的结果？ 我想，我不需要说服自己，在这过程中，本就是快乐多于痛苦，收获多于汗水的，所以我感到幸运。 做为安卓开发人员，这一年，我花大量的时间在安卓技艺的熟练和学习上。主要有以下方面： 1) 对安卓基本的控件做到了熟练使用。不再像去年那般书写代码要通过大脑思考反复验证生涩的写，而是可以主要通过手指记忆敲出大量常用的代码，包括ListVIew，RecyclerView，Notification，ViewPager，Fragment，WebView等等。 2) 多次获得了一些有效项目实践。体现在项目重构，减少App启动时间，代码重构优化，Android6. 0权限适配，UI多屏幕适配上。 3）年底开源了自己写的一个字母表控件到github上。虽然这个控件很小，和github上各位大牛相比不值一提，但却是某种新的开始。 4）其他杂项。如纸质设计，git使用，gradle的学习，大都只是入门。尤其是gradle的学习，我希望接下来抽一段时间，好好把这块深入进去。 今年入手了Macbook pro，Mac相比于Window对开发人员真友善了，我想吼一句相用恨晚啊。今年看的一些书籍，简单做了记录吧。 《Android开发艺术探索》，很赞，五星推荐。（还在阅读中） 《HTTP权威指南》 读完一遍，对代理服务器／缓存服务器，http 报文有了一个全面的了解。 《MacTalk 人生元编程》&amp;《MackTalk 跨越边界》，这两本是池建强老师的微信文章集文成册，一部分讲解Mac的使用，更多的是关于程序员生活状态／工作的人文内容。 通过这一年的学习，更清晰的是了解到接下来一年，我该在哪些地方提高自己的安卓水平。2016年对于我来说，是很重要的一年，是技术道路上需要我更多投入的，以期达到一种升华和质变的一年。 2016年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentTransition的replace，add，show，hide方法的使用差异]]></title>
    <url>%2F2015%2F12%2F26%2F2015%2F2015-12-26%2F</url>
    <content type="text"><![CDATA[android项目，使用Fragment来展示视图，替换Activity显示，能有效的提高响应的速度。结合在项目中的实践，接下来说说我对这些方法的使用感悟。 replace使用使用replace()替换后会将之前的fragment的view从viewtree中删除，触发顺序: detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView() attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 使用该方法，每次都可以走一遍生命周期方法，让对象保持在最新的状态，同时也会带来频繁的数据请求，实例销毁和创建 replace时，通过FragmentTransition的addToBackStack(String name)方法，把被置换的fragment压入任务栈，放在新的fragment下。在replace时如果带上tag参数，那么就可以通过FragmentManager的findFragmentByTag（）找到被置换的fragment对象 这样，当按返回键时，被置换的Fragment就能重新显示出来，并执行对应的生命周期方法（如上显示的触发顺序） add使用使用该方法，常和show和hide配合，达到replace方法的显示效果。在使用过程中，有时候会出现视图重叠。原因有两种： 没有使用FrameLayout作为容器 第一次add把Fragment添加到容器后，第二次通过 FragmentManager.findFragmentByTag(“fragment” + position)找到Fragment而不是重新新建实例add进容器 一个MainActivity加上多个Fragment来构建android项目界面主体。用这种方式，底部每一个菜单就是一个fragment，暂且叫它一级操作界面，通常用add－show －hide方式显示Fragment，在每一个Tab里（二级以上操作界面），通过replace不同的fragment来展示不同的视图 使用这种方式，我在项目中遇到了一个问题。如果二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，那么这时候在一级操作界面里，调用了二级操作界面的对象的成员对象将变成null 原来，当二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，二级以上的界面通过replace来显示不同的界面，这时候二级操作界面的fragment将按上面的触发顺序重新走一遍生命周期方法，创建了新的实例，原来在一级目录里引用的二级界面上的Fragment的成员对象依然是旧实例里的 因此这时候解决的办法可以，在每次创建二级界面的fragment实例时，重新更新一遍（set方法）一级界面会用到的所有涉及二级界面fragment的成员变量]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少App的启动时间]]></title>
    <url>%2F2015%2F12%2F10%2F2015%2F2015-12-10%2F</url>
    <content type="text"><![CDATA[这几天在做App的启动时间优化，减少了将近一半的启动时间。先把一些感悟分享如下： 如何查看App的启动时间通过android自带的工具adb，使用命令行查看adb shell am start -W -n 包名/.启动Activity例如：adb shell am start -W -n com.adb.xyz/.view.LaunchActivity 优化思路：打开App，程序首先运行Application 的onCreate方法，多数App接下来会进入扉页，最后是主页的Activity。如果在onCreate方法里，运行过多代码以及做了耗时操作，App在启动的时候就会出现一片白屏或黑屏。 而我门要做的就是把运行在onCreate的方法里的代码尽量的移到扉页中运行。 这里还有三个注意事项：Android6.0后权限的适配。如果在Application里执行代码有需要用户授权，那么需要在BaseActivity里，权限请求回调函数中，从新执行Application里的代码。 同时还要关注，上述变动对主页Activity带来的影响，有些在主页里执行的代码要做异常处理，然后在请求授权的回调里重新执行一遍。 项目工程里，如果引用的第三方库使用到了.so文件，这些.so文件的执行速度跟手机的硬件内核有关。因此，会看到，不同的手机，相同的优化方案，减少的App启动时间会不同。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓三种动画小结]]></title>
    <url>%2F2015%2F11%2F24%2F2015%2F2015-11-24%2F</url>
    <content type="text"><![CDATA[安卓中，动画可以分为三类。逐帧动画，补间动画，属性动画。稍微小结下，我对这三个动画的认识。 逐帧动画AnimationDrawble,所以逐帧动画，其实是一种图像。通过设置ImageView类的background好或者src从代码和xml两个方式上载入。 ####纯代码 AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground(); frameAnimation.start(); xml定义&lt;animation-list android:id=&quot;@+id/selected&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/ wheel0&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel1&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel2&quot; android:duration=&quot;50&quot; /&gt; &lt;/animation-list&gt; 补间动画补间：开发者只需要给出动画的起始和结束帧状态，中间的帧交由安卓系统计算和补齐。抽象类Animation是补间动画的基类。同样可以分为xml和纯代码两种方式显示。补间动画无法实现动画无限重复播放。 涉及的APIAlphaAnimation,ScaleAnimation,RotateAnimation,TranslateAnimation,AnimationSet，Interpolator(差值接口),TimeInterpolator,Transformation,Camera（三维图形变换，类似Matrix） Animation animation = AnimationUtils.loadAnimation(Context context,int id) 实现自定义补间动画继承Animation，重写initalize()方法和applyTransformation(float interpolatedTime,Transformation t)方法 interpolatedTime:代表了动画的时间进行比，不管动画实际的持续时间如何，当动画播放时，该参数总是自动从0变化到1. Transformation 该参数代表了补间动画在不同时刻对图形或组件的变形程度。 applyTransformation方法的参考代码：camera.save(); camera.rotateY(360 *interpolatedTime); Matrix matrix = transformation.getMatrix(); camera.getMatrix(matrix); matrix.preTranslate(-centerX,-centerY); camera.restore(); 属性动画属性动画主要有两方面组成：1计算各帧的相关属性值 2为指定对象设置这些计算后的值。对象的属性名称有：rotationX,rotationY,scaleX,scaleY,alpha,translationX,translationY监听事件 ValueAnimator.AnimatorUpdateListener , Animator.AnimatorListener 涉及的APIAnimator:属性动画的基类。 ValueAnimator: 负责第一方面的内容。因此第二方面，为指定对象设置属性值须由程序员通过监听来完成。 ObjectAnimator,是ValueAnimator的子类，使用起来更简单。 AnimatorSet（属性动画组合），它是Animator的子类，用于组合多个Animator,指定播放顺序。 Evaluator和TypeEvaluatorEvaluator 计算器，控制属性动画如何计算属性值。TypeEvaluator 计算器接口，通过实现该接口来实现自定义计算器。 IntEvaluator FloatEvaluator ArgbEvaluator PointFEvaluator RectEvaluator ValueAnimator的使用基本用法 调用ValueAnimator的ofInt(),ofFloat()或ofObject静态方法创建 设置持续时间，插值方式，动画模式等属性 注册监听器AnimationUpdateListerner，在监听方法里，通过getAnimatedValue()方法，把当前帧的值应用到所需要的对象上。 start()启动动画 如果getAnimatedValue()返回的不是系统默认的值，借助TypeEvaluator接口，用系统自带的实现类，如PointFEvaluator,FloatArrayEvaluator,或者自己实现TypeEvaluetor,重写evaluator方法。 代码如下： valueAnimator.setObjectValues(new PointF(0, 0)); valueAnimator.setEvaluator(new TypeEvaluator&lt;PointF&gt;() { @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) { Log.e(&quot;evaluate&quot;,&quot;fraction=&quot;+fraction + &quot; startValue=&quot;+startValue +&quot; endValue=&quot; + endValue); PointF pointF = new PointF(); pointF.x = 200 * fraction * 3; pointF.y = (float) (0.5 * 10 * 200 * fraction * fraction); return pointF; } }); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { PointF pointF = (PointF) animation.getAnimatedValue(); ball.setTranslationX(pointF.x); ball.setTranslationY(pointF.y); } }); ObjectAnimator的使用继承自ValueAnimator，完成了属性动画的两个方面，所以可以直接把动画应用到对象上。 注意事项 该对象存在对应属性的setter方法。 如果只提供一个值，则该值被认为是结束值，此时需要提供getter方法。 如果该对象的setter方法不会自动调用invalidate()方法，则需要在onAnimationUpdate()监听方法里调用invalidate()刷新屏幕。 xml定义属性动画&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;objectAnimator android:duration=&quot;600&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:propertyName=&quot;alpha&quot; android:repeatCount=&quot;infinite&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot; /&gt; Animator animator = AnimatorInflator.loadAnimator(Context context,int resId); 多个属性动画同时播放的实现通过AnimatorSetAnimatorSet s = new Animatorset(); s.play(animator1).before(animator2); s.paly(animator2).befor(animator3); 2、ValueAnimator,ObjectAnimater的AnimatorUpdateListener监听方法onAnimationUpdate里，调用对象的多个属性setter即可 3、借助PropertyValuesHolder PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;,1f,0f); PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0f); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0f); ObjectAnimator animator1 = ObjectAnimator.ofPropertyValuesHolder(txt,holder1, holder2, holder3); animator1.setDuration(800); animator1.setInterpolator(new AccelerateDecelerateInterpolator()); animator1.setRepeatMode(ValueAnimator.REVERSE); animator1.setRepeatCount(ValueAnimator.INFINITE); animator1.setStartDelay(1000); animator1.start(); 借助ViewPropertyAnimator实现同时播放动画//need API12 mBlueBall.animate()// .alpha(0)// .y(mScreenHeight / 2).setDuration(1000) // need API 12 .withStartAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;START&quot;); } // need API 16 }).withEndAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;END&quot;); runOnUiThread(new Runnable() { @Override public void run() { mBlueBall.setY(0); mBlueBall.setAlpha(1.0f); } }); } }).start(); 等效于： PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(“alpha”, 1f, 0f, 1f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(“y”, 0, mScreenHeight / 2, 0); ObjectAnimator.ofPropertyValuesHolder(mBlueBall, pvhX, pvhY).setDuration(1000).start(); 参考资料 《疯狂安卓讲义》 Android 属性动画（Property Animation） 完全解析 （下）]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对变量范围转换引发的思考]]></title>
    <url>%2F2015%2F10%2F07%2F2015%2F2015-10-07%2F</url>
    <content type="text"><![CDATA[程序中，变量活动范围有：方法/函数（局部）里的，成员变量（全局变量） 当一个变量从局部变量升级到全局变量，该变量可以跨方法使用，因此在一个方法里对该变量赋值，在另一个方法里就能马上感知到并获取变量的值，体现着监听设计思想。 变量升级，并不是都带来了好的方面。一个变量升级后，就要求程序员考虑是否需要对这个变量进行维护。（所谓维护就是该变量是否处在一个循环中）如果需要维护，即变量处在循环中，则要考虑是否需要对该变量进行初始化和善后处理（因为全局变量是和其他变量或方法相互联系的）如果需要，则进一步考虑变量在循环中从0次，到1次，到2次的变化过程，并从这三次变化过程中提取规律。如果获取规律？程序员的经验以及一些更底层的规律。 把一个变量从局部编程全局的途径有如下方法： 1）利用java语言的特性，从方法变量编程成员变量 2）java语言特性，编程静态变量 3）通过单例，存储在手机内存中 4）放在Application中（严格说，这种方法其实也属于3）中的单例法） 5）存储在本地，需要用到的时候，再从本地获取。比如SharedPeference，IO流写入和读取。 变量从全局变量降级成局部变量，带来的好处就是降低了变量维护难度。只需要在该方法作用范围内考虑，同时对变量个体而言，作用范围的缩小，自然增加了变量作用的安全性。 由此，还可以推广到逻辑思考切入点事宜。 一个问题，肯定是处在特定的范围或事件中的。澄清前提，划清界限很有必要。解决一个问题，修复一个bug，首先需要把这个bug产生的起始点找到，这个起始点有时候是浮动的，可以往前多些，也可以往后移些。找到bug的起始点后，还要清楚这个bug的结束点。在这起始点和结束点之间的这一段范围里，我们去修改这个bug。为了定位bug，有时候当第一直觉和感知还无法定位bug的时候，就需要对这一段范围进行切割分段。如何切割？切割的依据是什么？这里涉及到责任链，可以选取一个范围大小的责任链作为参考进行分割，其实也即是业务逻辑功能模块来分割。然后定位到某一段时，再次分割。 这种循序渐进的方式，带来了逻辑的严密，bug就不容易被我们漏过。面对问题，只要有严密的思路和逻辑对bug和问题进行分解、拆分，加上有效时间的累积实践和反馈，就一定能找到解决和修复的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
