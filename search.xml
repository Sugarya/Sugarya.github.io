<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android原生项目集成ReactNative混合开发]]></title>
    <url>%2F2018%2F08%2F03%2F2018%2FAndroid%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90React-Native%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 12345678910npm init&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;&#125;npm install --save react react-native@版本号curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 配置原生安卓项目的Gradle12345678910111213141516171819202122232425allprojects &#123; repositories &#123; maven &#123; url &quot;$rootDir/node_modules/react-native/android&quot; &#125; jcenter() &#125;&#125;dependencies &#123; implementation &apos;com.facebook.react:react-native:版本号&apos;&#125;android &#123; defaultConfig &#123; ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &quot;armeabi-v7a&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; &#125; configurations.all &#123; resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos; &#125;&#125; 添加权限12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;/&gt;&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt; 添加React native入口在项目根目录下，新建index.js文件作为React Native控件配置页 Hello World示例 12345678910111213141516171819202122232425import React from &apos;react&apos;;import &#123;AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, &#125;, hello: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;,&#125;);AppRegistry.registerComponent(&apos;AndroidRnDemoApp&apos;, () =&gt; HelloWorld); 编译运行到安卓真机12adb reverse tcp:8081 tcp:8081npm start 打包新建assert资产文件 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/ 小结 本次Android集成了React Native0.51.0版本的环境（最新为0.56.0），采取了原生项目为主，编译和打包仍走安卓项目的Gradle流程 React Native集成过程中，由于Kotlin改写了模块iml文件里的某处标签信息，使得项目无法正常编译，往文件里手动添加如下标签得以修复： 1&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第七讲-泛型在Java和Kotlin上的横向比较]]></title>
    <url>%2F2018%2F07%2F16%2F2018%2FKotlin%E7%AC%AC%E4%B8%83%E8%AE%B2-%E6%B3%9B%E5%9E%8B%E5%9C%A8Java%E5%92%8CKotlin%E4%B8%8A%E7%9A%84%E6%A8%AA%E5%90%91%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 阅读本文前，如果对Java泛型不够了解，不妨先阅读我之前写的两篇说Java泛型的文章 重拾Java泛型 上篇 重拾Java泛型 下篇 语法比较泛型方法Java 1234567891011public static&lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)&#123; Iterator&lt;? extends T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext())&#123; T t = iterator.next(); if(t.compareTo(result) &gt; 0)&#123; result = t; &#125; &#125; return result; &#125; Kotlin1234567891011fun &lt;T : Comparable&lt;in T&gt;&gt; max(list: List&lt;out T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 查看Kotlin里的Comparable类和List类源码，Comparable类定义，List类定义，所以可以不必重复表明Comparable的逆变能力和List的协变能力。 1234567891011fun &lt;T : Comparable&lt;T&gt;&gt; max(list: List&lt;T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 不管是泛型类还是泛型方法，泛型的使用分为两个步骤 第一步，声明泛型参数 第二步，才是使用泛型参数 上面的泛型方法，以Java泛型方法为例，泛型声明部分是： 1&lt;T extends Comparable&lt;? super T&gt;&gt; 引入泛型类型名称为T，这个数据类型的关系是实现Comparable的类。 使用泛型的部分如下： 1List&lt;? extends T&gt; 入参的集合具有对类型T的协变能力。 所以，有些书或者网上资料，会出现两个概念：声明点变型，使用点变型。这个概念说的就是这件事 再来看下in位置，和out位置的概念 所以，类型参数T上的关键字out有两方面含义： 具有协变的能力 T只能用在out位置 我们再看一个有趣的例子 我有一个方法，入参的一个集合，我希望入参集合元素是EditText的子类的集合，如何构建满足这个关系的方法呢？至少有下面的两种方式： 1234567fun test2(list: MutableList&lt;out EditText&gt;)&#123;&#125;fun &lt;T: EditText&gt;test3(list: MutableList&lt;T&gt;)&#123;&#125; 上面test2， test3方法都能实现预期的效果。不同的是，test2使用协变来实现，也意味着只能读不能写操作，test2不是泛型方法。test3方法通过在声明表明泛型参数的类型关系来实现，可读可写，它是泛型方法。 对应的Java代码如下 private void test2(List&lt;? extends EditText&gt; list){ } private &lt;T extends EditText&gt; void test3(List&lt;T&gt; list){ } 实现泛型参数多约束Java 123private &lt;T extends Serializable &amp; CharSequence&gt; void ensureTrailingPeriod(T seq)&#123; &#125; kotlin 123fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T: Serializable, T: CharSequence&#123; &#125; 这是Java语法上很大的不同，Kotlin要实现多约束，使用到where关键词，这是全新的表示法。 实化类型参数来看一段Java代码： private &lt;T&gt; void test(T t){ if(t instanceof String){ String s = (String)t; }else if(t instanceof Integer){ Integer i = (Integer)t; } } 入参是泛型的，通过instanceof来判断泛型具体是哪个类型。再看一段代码 private &lt;T&gt; void test2(Object o){ //编译不通过 if(o instanceof T){ } } 泛型作为参数类型时，编译不通过。如果要完成上述的逻辑，要怎么实现？可以通过class近似等效实现 class ClassJudge&lt;T&gt;{ Class&lt;T&gt; kind; public ClassJudge(Class&lt;T&gt; kind) { this.kind = kind; } public boolean isInstance(Object o){ return kind.isInstance(o); } } 调用 Integer a = 12; boolean instance = new ClassJudge&lt;String&gt;(String.class).isInstance(a); System.out.println(&quot;instance = &quot; + instance); Kotlin在语言层面作出了支持，对上述Java代码test2方法，kotlin代码如下： 12345inline fun&lt;reified T&gt; test2(any: Any)&#123; if(any is T)&#123; &#125;&#125; 因此需要具备两个条件： 是内联函数 inline 关键词 reified 集合协变在Kotlin里，非空类型是可空类型的子类型。 Java实现的协变 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); Kotlin实现的协变 1val list: MutableList&lt;out Number&gt; = arrayListOf&lt;Int&gt;() 集合逆变Java实现的逆变 1List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;(); 对应的Kotlin逆变的实现： 1val list: MutableList&lt;in Int&gt; = arrayListOf&lt;Number&gt;() 变型（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。 由此可见，在泛型里，extends 不全等于 ：。extends代表子类型关系和协变，而Kotlin的 ：只代表子类型关系。 12&lt;out T&gt; = &lt;? extends T&gt;&lt;in T&gt; = &lt;? super T&gt; 星投影和Java无限制通配符？差异星投影如何使用 12&lt;*&gt; = &lt;out Any?&gt;&lt;*&gt; = &lt;in nothing&gt; 投影一词，顾名思义，是对Any？的投影，获得了Any？部分的能力—Any？协变的能力，即失去写操作，只能读操作。 12345fun printFirst(list: List&lt;*&gt;)&#123; if(list.isNotEmpty())&#123; println(list.first()) &#125;&#125; 场景二：泛型类存储所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化到一个分开的位置，预防了误用，保证了它不会被错误地使用。 其他非空性与泛型Java和Kotlin默认，泛型参数都是可空的，以Kotlin为例 12345class Processor&lt;T&gt; &#123; fun process(value: T)&#123; value?.hashCode() &#125;&#125; 泛型参数是可空类型，可以理解为默认实现&lt;T: Any?&gt;，因此要实现非空类型，只需&lt;T: Any&gt;，如下 12345class Processor2&lt;T: Any&gt; &#123; fun process(value: T)&#123; value.hashCode() &#125;&#125; 所以，泛型 和&lt;T: Any&gt;是有区别的，前者是可空类型，后者是非空类型，确切说，和&lt;T:Any?&gt;等效 小结Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 ##参考资料 仔细说说Java中的泛型 Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ Java 泛型进阶 Java为什么要添加运行时获取泛型的方法 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第六讲-委托类和属性]]></title>
    <url>%2F2018%2F06%2F12%2F2018%2FKotlin%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%A7%94%E6%89%98%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 委托类实现一个接口，可以使用by关键字将接口实现委托给另一个对象。 1234567891011121314151617181920212223interface OnClickListener&#123; fun onClick() fun onLongClick()&#125;class ViewClickDelegate : OnClickListener&#123; override fun onClick()&#123; println(&quot;ViewClickDelegate onClick&quot;) &#125; override fun onLongClick() &#123; println(&quot;ViewClickDelegate onLongClick&quot;) &#125;&#125;class View(val name: String, onClickListener: OnClickListener) : OnClickListener by onClickListener&#123; override fun onLongClick() &#123; println(&quot;$name onLongClick&quot;) &#125;&#125; 类委托后我们依然可以通过重写的方式来覆盖委托类的实现，这里View实现onLongClick方法，覆盖重写了ViewClickDelegate类里的onLongClick方法。 类委托的本质是：把抽象方法的实现交给了by后的委托对象 延迟初始化和委托属性延迟初始化属性不在对象创建的时候初始化，而是在第一次使用时初始化。完成后像普通属性一样使用 123456789101112open class Food(val name: String) &#123; override fun toString(): String &#123; return &quot;[$name]&quot; &#125;&#125;class Container(val name: String) &#123; lateinit var foodList: List&lt;Food&gt;&#125; 惰性初始化属性第一次使用该属性时才初始化，且只初始化一次。用旗号标示是否初始化过，旗号有多种选择和实现方式。 在代码定义处执行初始化，有助于代码维护。 对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。 普通实现12345678910class Container2(val name: String) &#123; private var _foodList: List&lt;Food&gt;? = null val foodList: List&lt;Food&gt; get() &#123; if (_foodList == null) &#123; _foodList = arrayListOf(Food(&quot;米糊&quot;)) &#125; return _foodList!! &#125;&#125; by lazy(){}实现惰性初始化1234567891011121314151617181920class Container4(val name: String) &#123; val food: Food by lazy&#123; Food(&quot;米糊&quot;) &#125;&#125;//指定锁class Container5(val name: String) &#123; val food: Food by lazy(Container5::class)&#123; Food(&quot;米糊&quot;) &#125;&#125;//默认 线程安全 SYNCHRONIZED//PUBLICATION，同步锁不是必需的，允许多个线程同时执行class Container6(val name: String) &#123; val food: Food by lazy(LazyThreadSafetyMode.SYNCHRONIZED)&#123; Food(&quot;米糊&quot;) &#125;&#125; 在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性，索引属性；关联属性，限制属性。接下来看下Kotlin如何实现关联属性和限制属性的 关联属性（可观察属性）通过PropertyChangeSupport代码实现属性监听12345678910111213141516171819class Shelf(val name: String, _book: Book) &#123; private val propertyChange: PropertyChangeSupport = PropertyChangeSupport(this) var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把逻辑封装，抽取出基类 123456789101112131415161718192021222324252627282930open class BasePropertyChange &#123; val propertyChange = PropertyChangeSupport(this) protected fun addChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(key, propertyChangeListener) &#125; protected fun removeChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(key, propertyChangeListener) &#125;&#125;class Shelf_2(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把book里的set访问器的逻辑封装成一个类 123456789101112131415161718192021222324252627282930class BookDelegate(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book fun getValue(): Book = field fun setValue(value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf2(val name: String, _book: Book) : BasePropertyChange() &#123; val _bookDelegate: BookDelegate = BookDelegate(_book, propertyChange) var book: Book set(value) &#123; _bookDelegate.setValue(value) &#125; get() = _bookDelegate.getValue() fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 至此，我们用Kotlin手工实现了可观察属性变化的功能，测试下 12345678910111213fun testObserverField() &#123; val shelf = Shelf2(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt.newValue as Book println(&quot;old book = $oldBook , new book = $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行上述代码结果如下： old book = Book(name=Think in java) , new book = Book(name=Kotlin in action) 使用Kotlin委托实现Kotlin的委托属性在语言层面提供了在属性的读访问器里调用委托类里operator修饰的两参数getValue方法，属性写访问器调用operator修饰setValue三个参数方法 12345678910111213141516171819202122232425class BookDelegate2(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book operator fun getValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;): Book = field operator fun setValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;, newValue: Book) &#123; val oldBook = field field = newValue propertyChange.firePropertyChange(&quot;book&quot;, oldBook, newValue) &#125;&#125;class Shelf3(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate2(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 通常借助ReadWriteProperty接口能方便我们实现委托 12345678910111213141516171819202122232425class BookDelegate3(var field: Book, val propertyChange: PropertyChangeSupport) : ReadWriteProperty&lt;Shelf3_1, Book&gt; &#123; override fun getValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;): Book &#123; return field &#125; override fun setValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;, value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf3_1(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate3(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 测试上述代码： 1234567891011121314fun testDelegateFieldForKotlin() &#123; val shelf = Shelf3_1(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt?.newValue as Book println(&quot;Kotlin委托 old book is $oldBook, and new book is $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action!&quot;)&#125; 运行结果如下： Kotlin委托 old book is Book(name=Think in java), and new book is Book(name=Kotlin in action!) 委托属性的本质：把属性访问器的实现交给了by后的委托对象 使用Kotlin的自带的实现可观察属性其实，Delegate.observable()类实现了上面提到的所有逻辑了。 我们看下Delegate.observable方法的源码 1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 该方法返回ObservableProperty对象，看下ObservableProperty对象源码 1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 该对象有getValue和setValue方法，这和我们自己实现的BookDelegate3类里的getValue和setValue方法逻辑几乎相同。不同之处是，官方还多了beforeChange()控制，和afterChange()供实现类覆盖重写。 Kotlin标准库已经提供了可观察属性的属性委托实现了 123456class Shelf4(val name: String, _book: Book) &#123; var book: Book by Delegates.observable(_book, &#123;property, oldValue, newValue -&gt; println(&quot;The old book&apos;s name is \&quot;$&#123;oldValue.name&#125;\&quot;, and the new book&apos;s name is \&quot;$&#123;newValue.name&#125;\&quot;&quot;) &#125;)&#125; 测试下上述的代码 1234fun testObserverFieldForKotlin()&#123; val shelf = Shelf4(&quot;书架&quot;, Book(&quot;think in java&quot;)) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行结果如下 The old book’s name is “think in java”, and the new book’s name is “Kotlin in action” 限制属性Kotlin也为我们提供了现成的委托类来实现限制属性 12345class Shelf5(val name: String, val book: Book ,_year: Int) &#123; var year: Int by Delegates.vetoable(_year, &#123;property, oldValue, newValue -&gt; newValue &lt;= 99 &#125;)&#125; 测试上述代码 12345678fun testVetoableFieldForKotlin()&#123; val shelf = Shelf5(&quot;书架&quot;, Book(&quot;think in java&quot;), 0) shelf.year = 200 println(&quot;current book is $&#123;shelf.year&#125;&quot;) shelf.year = 20 println(&quot;current book is $&#123;shelf.year&#125;&quot;)&#125; 运行结果如下： current book is 0current book is 20 注意：上述用的是成员函数，事实上，扩展函数也能实现委托属性 使用Map实现委托属性MapAccessors.kt文件里，有如下扩展函数源码 1234567891011@kotlin.jvm.JvmName(&quot;getVarContravariant&quot;)@kotlin.internal.LowPriorityInOverloadResolution@kotlin.internal.InlineOnlypublic inline fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V = @Suppress(&quot;UNCHECKED_CAST&quot;) (getOrImplicitDefault(property.name) as V)@kotlin.internal.InlineOnlypublic inline operator fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) &#123; this.put(property.name, value)&#125; 由此可见， MutableMap存在getValue方法和setValue方法，那么就可以用于委托，事实上，也确实如此。 举个例子: 123456789101112131415161718192021class Fruit(name: String) : Food(name)&#123; private val attributeMap = HashMap&lt;String, String&gt;() val color: String by attributeMap val size: String by attributeMap fun setAttributeMap(name: String, value: String)&#123; attributeMap.put(name, value) &#125;&#125;fun testDelegateMap()&#123; val fruit = Fruit(&quot;西瓜&quot;) fruit.setAttributeMap(&quot;color&quot;, &quot;绿色&quot;) fruit.setAttributeMap(&quot;size&quot;, &quot;2kg&quot;) println(&quot;color = $&#123;fruit.color&#125;, size = $&#123;fruit.size&#125;&quot;)&#125; 运行结果 color = 绿色, size = 2kg 小结类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 参考资料维基百科：惰性初始化模式 维基百科：惰性求值]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第五讲-Kotlin的类型和空处理]]></title>
    <url>%2F2018%2F06%2F03%2F2018%2FKotlin%E7%AC%AC%E4%BA%94%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 ##Kotlin的类型类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 以字符串类型举例，字符串平台类型如下： String！ 程序员不能使用这种语法，Java代码转Kotlin代码的时候会出现，表示可控性未知，也可以理解为己有肯能是非空类型也有可能是可空类型 ####非空类型和可空类型的理解可空类型 = 非空类型 + null Type? = Type + null 因此，String？，String是两种不同的数据类型，就像Int和String是两种数据类型那般。 ###基本数据类型Kotlin不区分基本数据类型和包装类型，都是使用一种基本类型： 下面是非空基本类型 Char, Boolean, Byte, Short, Int，Long, Float, Double 可空基本类型 Char？, Boolean?, Byte?, Short?, Int?，Long?, Float?, Double? Kotlin的基本类型如果转成Java基本数据类型，要怎么办？ 对于变量、属性、参数和返回类型，Kotlin的基本类型会被编译成Java的基本数据类型。用作泛型类型参数的基本数据类型会被编译成对应的Java包装类型。 注意： 和Java不同，小范围的值不能自动转化为大范围的值，而是看成两种不同的类型 下面的代码演示了数据类型的表示，各类型转化，数据类型智能推断，字符串类型转成基本数据类型 1234567891011121314151617181920212223242526272829303132333435fun testBasicType() &#123; val bb: Byte = 127 val boolean = false val aa: Char = &apos;a&apos; var i: Int = 21_4748_3647 //10位 var l: Long = 922_3372_0368_5477_5807L //19位 //不存在小写的l val f: Float = 123f val f2: Float = 124F val a16 = 0x123ef3 val b16 = 0XcCCef3 val c2 = 0b1010 val cc2 = 0B11001 val b: Byte = 1 val eas = b + 1L //Long + Byte =&gt; Long , eas为Long类型 fun foo(l: Long) &#123; println(l) &#125; foo(44) //单独写44可能是byte，int long，这里智能推断44会被认为是long //字符串转基本数据类型 val p = &quot;44&quot;.toInt() val p2 = &quot;44&quot;.toLong() val p3 = &quot;44&quot;.toFloatOrNull() val p4 = &quot;44&quot;.toDouble() val translate = l.toInt().toLong().toFloat().toDouble().toInt()&#125; ###Any，Unit，Nothing类型 Any 相当于 Object，不同点：是非空类型，缺少Object的wait，notify方法 Unit相当于Java的Void；不同点：Unit是一个完备的类型，可以作为类型参数。Unit是Any的子类 Nothong表明函数不会有返回类型（没有返回类型），该函数不会正常终止，Nothing是Unit的子类 1234567891011121314151617181920212223242526272829303132fun getStrinLenght(s: String?): Int &#123; if (s == null) &#123; throw IllegalArgumentException() &#125; else &#123; return s.length &#125;&#125;fun fail(): Nothing = throw IllegalArgumentException()fun getStrinLenght2(s: String?): Int = if (s == null) &#123; fail() &#125; else &#123; s.length &#125;fun testAnyAndNothing(o: Any?): View &#123; val filterO = o ?: fail() return when (filterO) &#123; is View -&gt; &#123; View(&quot;View&quot;) &#125; is TextView -&gt; &#123; TextView(&quot;TextView&quot;, &quot;&quot;) &#125; else -&gt; &#123; fail() &#125; &#125;&#125; 可以认为：throw IllegalArgumentException()返回的类型是Nothing，nothing是Int的子类型。 ####小结Any，Unit和Nothing三者关系： A Whirlwind Tour of the Kotlin Type Hierarchy ##空安全相关的运算符 ###安全调用？.如果值是null，整个表达式的值为null。 12345678open class Company(val name: String, val address: String?)fun testNullType()&#123; val company = Company(&quot;京东&quot;, null) val length = company.address?.length println(&quot;length = $length&quot;)&#125; ###Elvis运算符 ？： 12345678910fun testElvis(list: List&lt;Company?&gt;?, defaultAddress: String?)&#123; val defaultAdd = defaultAddress ?: &quot;&quot; val length = defaultAddress?.length ?: 0 //.?为空调用，表达式返回null，遇到了？： println(&quot;defaultAdd = $defaultAdd, length = $length&quot;) val companyList = list ?: throw IllegalArgumentException(&quot;null list&quot;) val address = companyList[0]?.address?.toUpperCase() ?: defaultAddress //多重空安全调用和Elvis联合使用 println(&quot;address = $address&quot;)&#125; ###安全转换as?as？运算法尝试把值转换成制定的类型，如果值不是合适的类型就返回null。 1234567891011121314151617181920212223open class View(val name: String)class TextView(name: String, val text: String) : View(name)fun testAsClient()&#123; val company = Company(&quot;JD&quot;, &quot;亦庄&quot;) testAs(company) testAs2(company) val tv = TextView(&quot;TextView&quot;, &quot;I am a message content&quot;) testAs2(tv)&#125;fun testAs(o: Any)&#123; val tv = o as TextView println(&quot;name = $&#123;tv.name&#125;&quot;)&#125;fun testAs2(o: Any)&#123; val tv = o as? TextView ?: TextView(&quot;Default TextView&quot;, &quot;&quot;) println(&quot;The content of $&#123;tv.name&#125; is = $&#123;tv.text&#125;&quot;)&#125; ###非空断言 !! 把任何值转换成非空类型 12345678910fun testNoNullClient()&#123; val result = testNoNull(&quot;Kotlin&quot;) println(&quot;result = $result&quot;)&#125;fun testNoNull(s: String?) : String&#123; val length = s!!.length println(&quot;$s&apos;s length is $length&quot;) return s!!.toUpperCase()&#125; ###let函数 把可空值作为实参传递一个只接收非空值的函数 1234567891011121314151617fun testLet()&#123; val length = getTheBigCompanyInTheWorld().address?.length val upperCase = getTheBigCompanyInTheWorld().address?.toUpperCase() val letter = getTheBigCompanyInTheWorld().address?.get(0) println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;)&#125;fun testLet2()&#123; getTheBigCompanyInTheWorld().address?.let &#123; val upperCase = it.toUpperCase() val length = it.length val letter = it[0] println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;) &#125;&#125;fun getTheBigCompanyInTheWorld(): Company = Company(&quot;JD&quot;, &quot;Beijing&quot;) ###可空类型的扩展函数 允许接收者为null的调用，在扩展函数内部处理null。不需要安全调用了 看几个Kotlin标准库，String定义的扩展函数isNullOrEmpty 123public inline fun CharSequence?.isNullOrEmpty(): Boolean &#123; return this == null || this.length == 0&#125; 注意： 在Java中，this永远是非空的，在Kotlin中，this可以为null。 因此在定义扩展函数时，需要考虑扩展是否需要为可空类型定义。本质上是对null在哪个环节处理的思考，是要在调用时使用空安全调用处理呢，还是在调用的函数内部处理。 ###泛型参数默认是可空类型 1234567fun &lt;T&gt; myPrintln(t: T)&#123; println(t.toString())&#125;fun testGenericityClient()&#123; myPrintln(null)&#125; ###转Java代码为Kotlin代码时，对空的处理 ####带注解的Java变量翻译到Kotlin时被认为是可空类型或者非空类型 Javax.annotation包下 android.support.annotation包下 org.jetbrains.annotations下 @Nullable + Type = Type?@NotNull + Type = Type ##参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第四讲-Kotlin的类、对象和接口]]></title>
    <url>%2F2018%2F05%2F27%2F2018%2FKotlin%E7%AC%AC%E5%9B%9B%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 类类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 为了简化，Kotlin支持步骤2和步骤1合并操作，在主构造函数参数前加var/val； 支持步骤3和步骤2合并，对定义的属性直接赋值。支持步骤3和步骤2和步骤1合并操作，使用主构造函数的默认参数表达。 当然这些合并带来简便的同时，降低了构造的能力。 最初的状态（步骤1，步骤2，步骤3都存在） 123456789class User(_sickName: String)&#123; val sickName: String init &#123; println(&quot;init&quot;) sickName = _sickName &#125;&#125; 步骤2和步骤1的合并，在主构造函数里传参和定义类的属性 123456class User(val sickName: String)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 步骤3，步骤2和步骤1的合并 123456open class User private constructor(val sickName: String = &quot;Kotlin&quot;, var age: Int)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 注意：Java中需要重载构造方法的场景大多数都被Kotlin参数默认值和参数命名的语法特性涵盖了 子类的构造方法 123456789101112131415 open class AirBook(name: String, val year: Int, val size: Int) &#123; constructor(name: String, year: Int) : this(name, year, 22)&#123; println(&quot;constructor&quot;) &#125;&#125; class MacBookPro: AirBook&#123; public constructor(name: String, year: Int) : super(name, year) &#123; &#125; public constructor(name: String, year: Int, size: Int) : super(name, year, size)&#123; &#125;&#125; 子类在创建的时候，必须调用父类的构造函数，如果其父类还有父类，仍然要调用父类的父类的构造函数，直至顶层的基类。 12345678open class AirBook(name: String, val year: Int, val size: Int)&#123; init &#123; &#125; constructor(name: String, year: Int) : this(name, year, 22)&#123; &#125;&#125; 构造函数可以调用当前自身的构造函数，因为自身的构造函数必然有至少一个调用了父类的构造函数。 属性访问器在kotlin里，一个属性 = 字段 + 属性访问器；这里的字段是Java里的成员变量 属性访问器分为读访问器getter，和写访问器setter 访问器里存在field字段，用来连接写访问器和读访问器，作为两者的通信桥梁 val修饰的属性只有读访问器，var修饰的属性既有有读也有写访问器 Kotlin引入属性访问器后，凡事对属性进行赋值操作，就会调用属性的写访问器setter；读取值的操作对应调用的是属性的读访问器 那么如果我们要自定义一个类似Java里的setter方法，要怎么做呢？ 通过var变量的私有setter来实行 代码如下: 12345678910class TableLamp(val name: String, lightness: Int)&#123; var lightness: Int = 1 private set fun setupLightness(lightness: Int)&#123; this.lightness = lightness println(&quot;setupLightness lightness = $lightness&quot;) &#125;&#125; 这样对属性lightness的修改，只能通过setupLightness方法。 修饰词final, open, abstract相互影响和使用Kotlin的函数，类默认是final的，如果想重写函数，类有子类，则需使用open修饰。abstract修饰的函数和类，意味着有open的特性。这和Java的用法是一致的。 Kotlin自带的特殊类数据类，嵌套类，内部类，密封类的基本写法这里就略去不谈。 数据类datadata修饰的类，必须有主构造函数，且主构造每个入参必须都val或var修饰 data修饰补充的方法里的所用的变量取决于主构造函数的入参 嵌套类和内部类定义在某个类内部并用inner修饰的类称为内部类 嵌套类可以类比Java的静态内部类，Kotlin的内部类类比Java的内部类，他们含有外部类的引用。与Java内部类不同的是，Kotlin的内部类能对外部类的变量进行写操作。 举个例子 123456789class TextView&#123; var counter: Int= 0 inner class Operator&#123; fun calculate()&#123; counter ++ &#125; &#125;&#125; 内部类Operator的成员函数可以写外部类的counter属性，这在Java里是做不到的。 密封类sealed关键词修饰的类，表达有限个子类。 123456789sealed class Color constructor(val name: String)class Red : Color(&quot;Red&quot;)class Green : Color(&quot;Green&quot;)class Blue : Color(&quot;Blue&quot;)class Gray : Color(&quot;Gray&quot;) 上述写法，编译器就会知道，Color的子类的数量，此例Color一共只有四个子类，分别是：Red，Green， Blue， Gray。如果增加或删除Color的子类，编译器是能感知到的。密封类的子类可以作为嵌套类，也可以写在密封类所在的文件里，但是不能写在其他文件里。 举个和When搭配的应用例子： 12345678910111213141516171819fun testSealed(color: Color): Int = when (color) &#123; is Red -&gt; &#123; println(&quot;Red&quot;) 1 &#125; is Green -&gt; &#123; println(&quot;Green&quot;) 2 &#125; is Blue -&gt; &#123; println(&quot;Blue&quot;) 3 &#125; is GRAY -&gt;&#123; println(&quot;GRAY&quot;) 4 &#125; &#125; 密封类的意义：如果不用密封类，使用when总是不得不添加一个默认分支。更重要的是，如果你添加了一个新的子类，编译器并不能发现有地方改变了。如果你忘记了添加一个分支，就会选择默认的选项，这可能导致潜在的bug。 使用密封类就能解决上述的问题。 Object的使用声明一个类并创建一个对应的实例。与类一样，对象可以包含属性，方法，初始化语句块等的声明。对象声明可以继承类和实现接口，尤其不包含状态的时候很适用，也可以有扩展函数。 对象声明创建单一的实例，对象声明在定义的时候就创建了，不需要在代码的其他地方调用构造方法。 因此，对象声明不允许有构造函数。 123456object NameComparator : Comparator&lt;String&gt;&#123; override fun compare(o1: String, o2: String): Int &#123; return o1.compareTo(o2, true) &#125;&#125; Java调用上述代码，则需要通过INSTANCE来调用，如下 1CaseInsensitiveFileComparator.INSTANCE.compare(&quot;abc&quot;, &quot;abe&quot;); 伴生对象创建单一的实例，可以实现Java里访问类的私有成员的静态方法 在对象声明的基础上，使用companion关键字来标记，这样做就获得了直接通过容器类名称来访问这个对象的方法和属性的能力。 举个例子，实现CarFactory工厂 通过对象声明的实现 1234567891011class CarFactory&#123; object Instance&#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.Instance.newCar(&quot;Mini Cooper&quot;) 通过伴生对象的实现 1234567891011class CarFactory&#123; companion object &#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.newCar(&quot;Mini Cooper&quot;) 对象表达式既然是表达式，就意味着有返回值 与Java的匿名内部类只能扩展一个类或者实现一个接口不同，Kotlin的匿名对象可以实现多个接口或者不实现接口。 与对象声明不通，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。在对象表达式里不经可以访问创建它的函数中的变量，还可以修改变量的值 举个例子 12345678910fun countClick(view: View)&#123; var clickCount = 0 view.addClick(object : IClick&#123; override fun onClick() &#123; clickCount ++ &#125; &#125;)&#125; 小结object对象在Kotlin中的意义： 实现Java里静态的功能，等效实现静态调用 代替Java匿名内部类书写 接口123456789interface IFocus &#123; val focusName: String fun showOff()&#123; println(&quot;IFocus foucusName length = $&#123;focusName.length&#125;&quot;) &#125; fun onFocus()&#125; IFocus接口声明函数，让子类实现，默认方法showOff，和抽象方法onFucus 123456789class View : IFocus&#123; override val focusName: String get() = &quot;View&quot; override fun onFocus() &#123; showOff() &#125; &#125; View实现IFocus接口，focusName由View来确定，获取focusName逻辑写在IFocus的默认方法里。调用如下 val view = View() view.onFocus() 调用返回内容 IFocus foucusName length = 4 其他访问权限修饰词protected在Kotlin和Java的区别kotlin中protected只能是其子类和自身才能访问；Java中则是同包下所有文件和不同包的子类能访问 Kotiln访问权限由小到大排列依次是：private, protected, internal, public Kotlin函数和属性默认是public的，Java的默认是包级访问范围，即同一个包下的类能访问。Kotlin缺少包级别访问控制，而多了一个模块访问范围internal。internal表示同一个项目模块下的类都能访问 参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第三讲-拓展函数及其他]]></title>
    <url>%2F2018%2F05%2F07%2F2018%2FKotlin%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 1234567891011121314151617181920212223242526public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123; override fun add(element: E): Boolean override fun remove(element: E): Boolean override fun addAll(elements: Collection&lt;E&gt;): Boolean public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean override fun removeAll(elements: Collection&lt;E&gt;): Boolean override fun retainAll(elements: Collection&lt;E&gt;): Boolean override fun clear(): Unit public operator fun set(index: Int, element: E): E public fun add(index: Int, element: E): Unit public fun removeAt(index: Int): E override fun listIterator(): MutableListIterator&lt;E&gt; override fun listIterator(index: Int): MutableListIterator&lt;E&gt; override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;&#125; MutableList接口提供了增加和删除集合元素的能力。 创建不可变集合val list = listOf&lt;String&gt;(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val letter = list[0] var list1 = listOfNotNull&lt;Int&gt;(1, 4, 8) 创建可变集合val list2 = arrayListOf&lt;Int&gt;(1, 2, 3, 4) list2.set(0, 10) list2[0] = 10 list2.add(5) println(&quot;list2 = $list2&quot;) val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.add(&quot;d&quot;) println(&quot;e = $list3&quot;) println(&quot;last element = ${list3.last()}&quot;) val list4 = mutableMapOf&lt;String, String&gt;(&quot;1&quot; to &quot;A&quot;, &quot;2&quot; to &quot;B&quot;) val list5 = mutableSetOf&lt;String&gt;(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;) 参数Kotlin的函数比Java函数强大的地方之一是入参可以有默认值，即默认参数； 在Kotlin调用函数时，可以指定入参的名称，即命名参数； 与Java不同，Koltin表示可变参数，不是参数后面加三个点，，而是在入参前加vararg关键词即可。Kotlin中存在一个展开运算符 – *（星号），它和可变参数搭配使用；作用是把一个数组展开成可变参数传入 详细说明，可看这篇文章Kotlin里的输入参数 顶层函数与属性 很多代码并不能归属到任何一个类中，有时一个操作对应两个不同的类的对象，而且重要性相差无几。 有时存在一个基本的对象，但不想通过实例函数来添加操作，让它的API继续膨胀。 在Java里，我们使用静态方法。Kotlin里没有static修饰词，它一种方式，使用顶层函数来实现相同的效果。 顶层函数实现一个功能，把集合中元素添加前缀，后缀，用分隔符间隔展示 在kt类里直接写 12345678910111213141516171819const val counter: Int = 0fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String ): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 顶层函数是包内成员，包内直接访问。若包外访问，需要import（IDEA等开发工具会为你自动import） 顶层函数是都是静态函数，默认函数所在的文件名加KT作为容器类，比如上述joinToString方法是在Example3_2文件名下的顶层函数，在Java里调用是时 Example3_2Kt.joinToString(collection, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;); 如果我想更改调用静态方法的容器类的类名为StringUtils，则需要在kotlin文件里添加 @file:JvmName(&quot;StringUtils&quot;) 这时候调用形式如下： StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 顶层属性counter就是顶层属性，等效于容器类的静态成员变量，即Java里如下写法 public static final int counter = 0; 拓展函数与属性拓展函数基本使用StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 每次调用上述实现的joinToString方法传入四个参数，有点多，我希望减少入参数量。StringUtils是工具类类名，工具类类名在整个调用过程中是不够高效的。达到优雅的途径之一就是做到高效而简洁。这个工具类具体是什么名字并不会影响这个函数的输入和输出，这个类名的意义是作为joinToString容器的标示，如果能把其中一个入参名作为类名，这个入参同时做两件事：传入自身到函数体里，作为调用的句柄名。 强大的Kotlin为我们实现了这样的能力：扩展函数。把上述方法生命为一个拓展函数，如下所示： 1234567891011fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;)&#123; val sb = StringBuilder() sb.append(prefix) for((index, element) in this.withIndex())&#123; if(index &gt; 0)&#123; sb.append(separator) &#125; sb.append(element.toString()) &#125; sb.append(postfix)&#125; 接收者类型：函数名前的类，上例Collection就是该扩展函数的接收者类型 接收者对象：接收者类的实例，上例this.withIndex方法的this指代的就是Collection对象，是该扩展函数接收者对象 这时候我们要使用joinToString方法，变成这样用了 val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.joinToString(&quot;_&quot;, &quot;[&quot;, &quot;]&quot;) 导入范围需要进行导入扩展函数才能生效，好在开发工具为我们自动导入了。如果定义的扩展函数所在的类和其接收者类型的类在一个包下，可以不需要显式导入。 有一种情况，如果你定义的扩展函数名和其他包里定义的函数名相同，你需要导入全类名以示区分。还有另一种方式，通过as在导入的地方重命名扩展函数名 import sugarya.chapter3.joinToString as jts 这时候，就可以调用jts就相当于调用joinToString方法 扩展函数的本质和特性其实，Kotlin把上述代码翻译到JVM上运行时。拓展函数的本质是：把接收者对象作为第一个入参的函数。通常我们在顶层位置定义扩展函数，这样扩展函数就能被其他包的文件调用。因此，扩展函数并没有改变接收者类里的代码，扩展函数并不是类的一部分，它是声明在类之外的，却能像成员变量那般使用。 像成员变量那般使用，扩展函数和成员变量不是一回事，它们之间是有区别的 扩展函数不能访问私有或者受保护的成员，因为接收者对象只是静态方法的一个入参，这个入参有大的访问能力，扩展函数就是多大访问能力。 扩展函数不能被接收者类的子类重写／继承。前面说了，扩展函数只是静态方法，并不是真实的接收者里的成员，自然也就无法重写了。 对于第2点的理解，我们举一个例子 12345678910111213class Person(name: String, var age: Int) : Animal(name)//拓展定义是写在Example2_4.Kt文件里fun Animal.move()&#123; println(&quot;animal move&quot;)&#125;fun Person.move()&#123; println(&quot;Person move&quot;)&#125;val animal: Animal = Person(&quot;Kotlin&quot;, 5)animal.move() 输出结果： animal move animal.move是拓展函数，转化为静态方法是Example2_4.move(animal),所以，move方法调用的就是Animal类下的move。 扩展属性扩展属性是对扩展函数能力的弱化／简化使用。相当于Java里第一个参数是接收者对象的静态getter方法和setter方法。扩展函数和扩展属性搭配使用，在扩展函数里访问扩展属性。举个例子 val Animal.length: Int get() = this.name.length * 10 fun Animal.move(){ println(&quot;animal move ${this.length}&quot;) } 扩展函数的应用看几个扩展函数的应用例子 分割字符串有一个字符串“ab.cd12.ef”，需要分割成三部分：ab, cd12, ef 使用Java，我们很容易写成这样 String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;.&quot;); java里split（）方法入参的字符串表示的正则表达式，在正则表达式里“.”表示任意字符，所以，如果照上面所写，返回为空，找不到字符。 使用Java正确实现是： String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;\\.&quot;); Kotlin在此基础上，通过扩展函数扩展字符串方法，通过默认参数实现重载效果。 123456789101112131415161718192021/** * Splits this char sequence to a list of strings around occurrences of the specified [delimiters]. * * @param delimiters One or more strings to be used as delimiters. * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`. * @param limit The maximum number of substrings to return. Zero by default means no limit is set. * * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from * the beginning to the end of this string, and matches at each position the first element in [delimiters] * that is equal to a delimiter in this instance at that position. */public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123; if (delimiters.size == 1) &#123; val delimiter = delimiters[0] if (!delimiter.isEmpty()) &#123; return split(delimiter, ignoreCase, limit) &#125; &#125; return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map &#123; substring(it) &#125;&#125; Kotlin实现 &quot;ab.cd12.ef&quot;split(&quot;.&quot;) Kotlin里用Regex类表示正则，使用正则实现如下 val regex = Regex(&quot;\\.&quot;) val result = &quot;ab.cd12.ef&quot;.split(regex.toPattern()) 解析字符串在Kotlin变得更容易了，除了split，Kotlin还提供了其他方法，再看一个例子 解析文件路径解析一个文件路径：“/Users/mine/Documents/MyDocument/Photoes／546294_308008399296566_779316797_n.jpg”,获取目录路径，文件名，文件拓展名 Kotlin代码实现 val msg = &quot;/Users/mine/Documents/MyDocument/Photoes/546294_308008399296566_779316797_n.jpg&quot; val dirPath = msg.substringBeforeLast(&quot;/&quot;) val filePath = msg.substringAfterLast(&quot;/&quot;) val fileName = filePath.substringBeforeLast(&quot;.&quot;) val extendName = filePath.substringAfterLast(&quot;.&quot;) println(&quot;directory path = $dirPath, fileName = $fileName, extendName = $extendName&quot;) 输出： directory path = /Users/mine/Documents/MyDocument/Photoes, fileName = 546294_308008399296566_779316797_n, extendName = jpg 局部属性在Java里，函数的最小的作用域是在一个类里（private修饰的方法），而Kotlin引入局部函数–允许在函数里定义一个函数，让函数（方法）的最小作用域降到一个函数体里。提供更小粒度的复用，这样有什么意义呢？ 这样是有意义的。 没有局部函数的特性的Java语言里，对方法最小作用域的组织方式是这样的：一个复杂的类里有很多方法，当方法A里的代码行数很多时，通常拆分出几个新的方法a1，a2，a3等等，这些新的方法之间如果存在整体的逻辑关系，就能组合成一个内部类，a1，a2，a3是该内部类的方法。直接在A里新建内部类并调用即可。外部类的其他方法比如方法B也能方便的调用。 Kotlin局部函数提供了比上述Java更细致的代码组织方式：如果我们只在一个方法A里多次用到，这时候在方法A里，定义a1，a2，a3，在方法A里多次使用方法a1，a2，a3。这种方式相较于上面的内部类组织方式，带来的益处是降低定义内部类带来的语法开销。 对于什么时候引入局部函数，我们有了下述认识：当需要在方法粒度上多次调用一段逻辑时。具体的场景有，登录验证，表单数据校验。 中缀调用 对只有一个参数的函数使用中缀调用 中缀调用的函数，需要对其使用inflix修饰符 中缀不仅适用于成员函数也适用于扩展函数 举个中缀的例子 val pair: Pair&lt;String, String&gt; = &quot;a&quot; to2 &quot;A&quot; 上面的中缀调用是怎么定义呢？ infix fun &lt;T, V&gt; T.to2(v: V): Pair&lt;T, V&gt; = Pair(this, v) 三重引号的字符串三重引号字符串不仅在于避免转义符，而且可以包含任何字符，包括换行符。 看一个佛祖镇楼的例子 1234567891011121314151617181920212223 val bless = &quot;&quot;&quot; _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG &quot;&quot;&quot; println(bless) 这样控制台按原样格式输出佛祖图 小结这是Kotlin实战第三章涉及的所有知识点，结合自己的理解整理归纳成本篇文章。]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第二讲-初出茅庐]]></title>
    <url>%2F2018%2F04%2F05%2F2018%2FKotlin%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90%2F</url>
    <content type="text"><![CDATA[年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？ 年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？val = 加了final的变量 val message = &quot;Kotlin&quot; // final String message = &quot;Kotlin&quot;; var count = 0 val msg: String = &quot;Kotlin&quot; //value var count2: Int = 0 // variant val p = Person(&quot;Kotlin&quot;) p.name /* Q1 var与val什么区别？ val = 加了final变量 */ val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;) languageList.add(&quot;Go&quot;) 字符串模板类比Java Web JSP里的EL表达式 println(&quot;message = &quot; + message) println(&quot;message = $message&quot;) println(&quot;count = ${count}&quot;) println(&quot;language list size = ${languageList.size}&quot;) println(&quot;\$: ${count2}&quot;) 函数fun max(a: Int, b: Int): Int { if (a &gt; b) { return a } return b } fun max2(a: Int, b: Int) = if (a &gt; b) a else b 问题：表达式和语句有什么区别？ 表达式有返回值，语句没有。表达式可以包含在语句或表达式里。语句与语句之间是并列的 Kotlin常见的表达式有：if，when，try{}catch 关于Whenfun filter(a: Int) { when (a) { 0 -&gt; println(&quot;0&quot;) 1 -&gt; println(&quot;1&quot;) in 2..10 -&gt; println(&quot;in 2..10&quot;) !in 11..20 -&gt; println(&quot;! in 11..20&quot;) Integer.parseInt(&quot;21&quot;) -&gt; println(&quot;21&quot;) 22, 23 -&gt; println(&quot;22 , 23&quot;) else -&gt; println(&quot;else&quot;) } } fun filter2(x: Any) { when (x) { is Int -&gt; println(&quot;Int&quot;) is String -&gt; println(&quot;String&quot;) is Person -&gt; print(&quot;JavaPerson&quot;) } } fun filter3(x: Any) = when (x) { is Int -&gt; { val a = 3 &quot;Int&quot; } is String -&gt; { val b = &quot;&quot; &quot;String&quot; } else -&gt; { &quot;else&quot; } } fun filter4(x: Any) = when { x is Int -&gt; &quot;Int&quot; x is String -&gt; &quot;String&quot; else -&gt; &quot;else&quot; } } 关于Kotlin里的循环和迭代for (i in 0..5) { println(&quot;i : $i&quot;) } for(j in 0 until 5){ println(&quot;j : $j&quot;) } for(k in 5 downTo 0){ println(&quot;k : $k&quot;) } val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;, &quot;Go&quot;) for((index, value) in languageList.withIndex()){ println(&quot;index = $index, value = $value&quot;) } val languageMap = hashMapOf&lt;String, String&gt;(&quot;j&quot; to &quot;Java&quot;, &quot;k&quot; to &quot;Kotlin&quot;, &quot;g&quot; to &quot;Go&quot;) for((key, v) in languageMap){ println(&quot;$key : map value = $v&quot;) } 异常处理背景知识： Java异常继承自Throwable，分为两种 运行时异常RuntimeException，也叫非受检异常 受检异常 CheckedException Java处理异常有两种方式： try catch 捕获异常 throws抛出异常 先看下Java的例子 //非受检异常 private static void testRuntimeException() { int i = Integer.parseInt(&quot;!&quot;); } //受检异常 private void testCheckedException() { try { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } catch (FileNotFoundException e) { e.printStackTrace(); } } private void testCheckedException2() throws FileNotFoundException { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } 从上面程序可知：Java强制要求开发人员处理受检异常. 常见的受检异常： Exception, FileNotFoundException, IOException, SQLException 常见的未检查异常： NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException 上述Kotlin下的代码如下： fun testRuntimeException(){ val i = Integer.parseInt(&quot;!&quot;) } fun testCheckedException(){ val fis = FileInputStream(&quot;/temp&quot;) throw IllegalArgumentException(&quot;&quot;) } 可知：与Java不同，对受检异常，Kotlin不强制开发人员处理。 小结对于异常，Kotlin与Java的不同之处如下： Kotlin不区分受检异常和非受检异常, 都不强制处理异常 Kotlin不存在throws，不允许抛出异常 当try{}catch{}作为表达式的使用时fun readNumber(){ val a = try { val c = &quot;&quot; Integer.parseInt(&quot;!&quot;) }catch (e: Exception){ e.printStackTrace() 0 } println(&quot;a = $a&quot;) } 关于枚举1234567891011121314enum class Season&#123; SPRING, SUMMER, AUTUMN, WINTER&#125;enum class Color(val r: Int, val g: Int, val b: Int)&#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0,0,255); fun rgb() = r * 255 * 255 + g * 255 + b&#125; 关于类和属性我们看下Java的 123456789101112131415161718192021222324252627public class Rectangle &#123; private final int width; private final int height; private final boolean isSquare; public Rectangle(int width, int height, boolean isSquare) &#123; this.width = width; this.height = height; this.isSquare = isSquare; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public boolean isSquare() &#123; return isSquare; &#125;&#125;``` 等效Kotlin实现 class Rectangle(val width: Int, val height: Int){ val isSquare get() = width == height}` Java中，成员变量就是一个字段，访问成员变量通过setter或者getter方法，相当于变量的访问器。Kotlin把这个概念作为语言层面的支持了。kotlin中每个属性，如果是val变量就自带访问器get(),如果是var属性则自带get()和set() 因此Kotlin中，一个属性 = 字段 + 访问器；这是Kotlin对Java语言的进化。 小结该文是对Kotlin实战一书第二章知识点代码的梳理和总结，完整代码，已上传到GitHub上，KotlinInActionExample 传送门]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第一讲-输入参数]]></title>
    <url>%2F2018%2F03%2F22%2F2018%2F%20Kotlin%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下：本专栏的第一篇，分享下Kotlin里输入参数的特性 命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下： 1234567891011121314151617181920212223242526272829public class SeparatorUtils &#123; /** * * @param collections 集合 * @param prefix 前缀 * @param separator 分隔符 * @param postfix 后缀 * @param &lt;T&gt; 集合泛型 * @return 分隔后的结果 */ public static &lt;T&gt; String separator(Collection&lt;T&gt; collections, String prefix, String separator, String postfix) &#123; Objects.requireNonNull(collections); StringBuilder sb = new StringBuilder(); sb.append(prefix); int size = collections.size(); int index = 0; for (T t : collections) &#123; sb.append(t.toString()); if(index &lt; size - 1)&#123; sb.append(separator); &#125; index ++; &#125; sb.append(postfix); return sb.toString(); &#125;&#125; private static void testSeparator(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Java&quot;); list.add(&quot;Kotlin&quot;); list.add(&quot;Python&quot;); list.add(&quot;JavaScript&quot;); list.add(&quot;Ruby&quot;); list.add(&quot;Go&quot;); String separator = SeparatorUtils.separator(list, &quot;(&quot;, &quot;,&quot;, &quot;)&quot;); System.out.println(&quot;separator result = &quot; + separator); } 输出结果： separator result = (Java,Kotlin,Python,JavaScript,Ruby,Go) 这是一个完整的编码过程，来了一个需求，通过新增类和方法，在需要的地方，调用实现。需求被解决了，代码默默地在角落发挥着作用。 转眼三个月过去，团队里来了新人，他阅读到testSeparator方法；当读到SeparatorUtils.separator（）方法，对于传的四个参数代表什么含义，乍看之下他并不清楚，需要点进去读实现代码或者看注释说明才确切明白。那么还有没有更易于阅读的方式呢？Kotlin的命名参数能做到。 SeparatorUtils.separator方法用Kotlin重写如下： 123456789101112131415161718fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 调用joinToString方法可以这样 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val s = joinToString(list, postfix = &quot;)&quot;, separator = &quot;,&quot;, prefix = &quot;(&quot;) println(&quot;s = $s&quot;) 上述即是命名参数，在调用处使用，形式为：参数名=参数值；这样的入参带来了两个便利： 便于阅读，按顺序阅读代码就能知晓方法参数的含义 调用时入参的位置可以任意（调用的入参顺序和定义的入参的顺序允许不一致） 这样看起来真不错的 默认参数定义函数时，给入参提供默认值，在调用处，如果不传入实参，则该参数使用默认值，可用于方法重载。例如对上述Kotlin代码的joinToString方法改变入参 12345678910111213141516171819@JvmOverloadsfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 在Kotlin调用joinToString（）支持如下，最后一个我们同时使用了Kotlin的命名参数和默认参数的特性。 val list = arrayListOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;Ruby&quot;, &quot;Go&quot;) val s = joinToString(list) val s2 = joinToString(list,&quot;,&quot;) val s3 = joinToString(list,&quot;,&quot;,&quot;[&quot;) val s4 = joinToString(list,&quot;,&quot;,&quot;[&quot;,&quot;]&quot;) val s5 = joinToString(list, prefix = &quot;[&quot;, postfix = &quot;]&quot;) 上述调用体现了方法重载，默认参数可提供方法重载的效果 上面出现的@JvmOverloads注解是用来做什么的呢？ 默认参数特性，使用是有前提的：用Kotlin定义函数，并在Kotlin代码里调用该函数。因此，如果在Java文件里调用Kotlin定义的joinToString方法，默认不支持默认参数特性的，也即方法重载失效。 @JvmOverloads提供了让默认参数特性在Java环境也得到支持。原理是：kotlin代码编译成java代码时，会增加增加下面的方法，这些正是Java方法重载。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class StringUtils &#123; public static final int count = 11; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix, @NotNull String postfix) &#123; Intrinsics.checkParameterIsNotNull(collection, &quot;collection&quot;); Intrinsics.checkParameterIsNotNull(separator, &quot;separator&quot;); Intrinsics.checkParameterIsNotNull(prefix, &quot;prefix&quot;); Intrinsics.checkParameterIsNotNull(postfix, &quot;postfix&quot;); StringBuffer sb = new StringBuffer(prefix); Object element; for(Iterator var6 = CollectionsKt.withIndex((Iterable)collection).iterator(); var6.hasNext(); sb.append(element)) &#123; IndexedValue var5 = (IndexedValue)var6.next(); int index = var5.component1(); element = var5.component2(); if (index &gt; 0) &#123; sb.append(separator); &#125; &#125; sb.append(postfix); String var10000 = sb.toString(); Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;sb.toString()&quot;); return var10000; &#125; // $FF: synthetic method // $FF: bridge method @JvmOverloads @NotNull public static String joinToString$default(Collection var0, String var1, String var2, String var3, int var4, Object var5) &#123; if ((var4 &amp; 2) != 0) &#123; var1 = &quot;,&quot;; &#125; if ((var4 &amp; 4) != 0) &#123; var2 = &quot;(&quot;; &#125; if ((var4 &amp; 8) != 0) &#123; var3 = &quot;)&quot;; &#125; return joinToString(var0, var1, var2, var3); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix) &#123; return joinToString$default(collection, separator, prefix, (String)null, 8, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator) &#123; return joinToString$default(collection, separator, (String)null, (String)null, 12, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection) &#123; return joinToString$default(collection, (String)null, (String)null, (String)null, 14, (Object)null); &#125; public static final void testExtend(@NotNull Container $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, &quot;$receiver&quot;); String var1 = &quot;call the container testExtend method&quot;; System.out.println(var1); &#125;&#125; 可变参数可变参数关键词：vararg(分别取variate和arguments前三个字母) 来看一个Kotlin的Collections类里的一个方法 123456/** * Returns a new [ArrayList] with the given elements. * @sample samples.collections.Collections.Lists.arrayList */public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt; = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true)) 调用 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) arrayListOf入参数量可以任意多个 Java实现可变参数，在数据类型后面加三个点：… ，看下Java里的Arrays里的一个方法 12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 展开运算符 *把数组展开成一个一个元素。展开运算符常与可变运算符联合使用。比如这样： 12val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)val list = arrayListOf(*array) 我得到了一个ArrayList集合，集合里的元素是”a”, “b”, “c”]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈Java反射]]></title>
    <url>%2F2018%2F01%2F22%2F2018%2F2018-01-22%2F</url>
    <content type="text"><![CDATA[在日常开发中尽量不要用反射，如果需要，先考虑通过复制原始类的形式来避免反射，还不行再考虑通过反射。 反射能帮我们做什么？ 反射构建出无法直接访问的类 set或get到无法访问的类变量 调用不可访问的方法 在日常开发中尽量不要用反射，如果需要，先考虑通过复制原始类的形式来避免反射，还不行再考虑通过反射。 反射能帮我们做什么？ 反射构建出无法直接访问的类 set或get到无法访问的类变量 调用不可访问的方法 每个包装器原始数据类型类具有名为 TYPE 的静态字段int.class 和 Integer.TYPE 指的是同一个类对象。 上一篇我在Java反射札记里说了如何反射一个类，代参实例对象，反射属性和方法。这次我们来看一个开源类库 jOOR 传送门 (https://github.com/jOOQ/jOOR) 我们一起学习下这个库的代码 这个开源库适配了Java6，Java8 和2017年11月份已经发布的Java9，作者在开发这个类库使，借鉴了已有的项目，做了调研和测试。 github上给出的Demo代码段： 12345String world = on(&quot;java.lang.String&quot;) // Like Class.forName() .create(&quot;Hello World&quot;) // Call most specific matching constructor .call(&quot;substring&quot;, 6) // Call most specific matching substring() method .call(&quot;toString&quot;) // Call toString() .get(); 上述代码采用链式调用，on方法 create方法，call方法内部都是调用的on的重载方法，返回Reflection类，最后的get()内部采用了泛型返回，如下： /** * Get the wrapped object * * @param &lt;T&gt; A convenience generic parameter for automatic unsafe casting */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T get() { return (T) object; } 关于泛型的使用，可以查阅之前的两篇： 重识Java泛型 上 重识Java泛型 下 在Android项目中，findViewById经过这样封装后，再也不用强转类型了。 类加载机制JVM里java的类的加载流程图这部分内容已在：Java反射札记 这篇讲解了，这里不重复了 Loading -&gt; Linking -&gt; Initialization 类一定会初始化的五大情况 使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。 关于第五点，没有接触过 现在通过代码实践来试试看吧 我定义了SuperClass类和SubClass类 SuperClass类 123456789101112131415161718public class SuperClass &#123; public static String sValue = &quot;666&quot;; public static final String HELLO_WORLD = &quot;hello world!&quot;; static &#123; Out.println(&quot;SuperClass init&quot;); &#125; public String getContent()&#123; return &quot;This is String result&quot;; &#125; public static void setsValue(String value)&#123; sValue = value; &#125;&#125; SubClass 12345678910111213public class SubClass extends SuperClass &#123; public static String sTemp = &quot;&quot;; static &#123; sTemp = &quot;sub class temp&quot;; Out.println(&quot;Subclass init&quot;); &#125; public void instanceTest()&#123; Out.println(&quot;instanceTest&quot;); &#125;&#125; 测试下第一点，new的时候/** * 类初始化 */ private static void testVersion1_2() { SubClass subClass = new SubClass(); } 输出： 12SuperClass initSubclass init 子类SubClass和SuperClass都经历了类初始化阶段 测试下第一点里提到的引用静态字段时/** * 类初始化3 */ private static void testVersion1_3() { Out.println(SubClass.sTemp); } 输出： SuperClass init Subclass init sub class temp 再看下这段代码 /** * 类初始化1 主动引用／被动引用 */ private static void testVersion1_1() { Out.println(SubClass.sValue); } 你觉得SubClass类会调用static静态代码块么？ 输出: 12SuperClass init666 答案是不会，神奇的一幕，SubClass没有经过类初始化 Java“相等”判定相关方法我们最熟悉的是instanceof方法，这个是实例对象的方法，判断当前对象是否是某个类的实例。 如果我要比较class类与类之间是否子类关系呢？要比较class对象和一个实例对象呢？ Java反射为我们提供了解决方法 /** * 相等判断 除了 instanceof */ private static void testVersion2_1() { Out.println(SuperClass.HELLO_WORLD); } private static void testVersion3_1() { boolean isAssignable = SuperClass.class.isAssignableFrom(SuperClass.class); Out.println(&quot;isAssignable = &quot; + isAssignable); } private static void testVersion3_2() { SubClass subClass = new SubClass(); boolean isInstance = SuperClass.class.isInstance(subClass); Out.println(&quot;isInstance = &quot; + isInstance); } 说明：使用isInstance，isAssignableFrom是需要注意判断的逻辑关系。比如拿testVersion3_1方法举例，boolean isAssignable = SuperClass.class.isAssignableFrom(SuperClass.class);说的是SuperClass是否是SuperClass的子类啊？isAssignable的布尔值就是答案 参考资料 Java反射最佳实践 JVM类加载机制详解（一）JVM类加载过程]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式实战分析 下篇]]></title>
    <url>%2F2018%2F01%2F17%2F2018%2F2018-01-17%2F</url>
    <content type="text"><![CDATA[还记得上次分享的练习题么 有一箱东港九九草莓，想吃其中最大的一颗草莓？（可模拟所需的所有数据） 引子还记得上次分享的练习题么 有一箱东港九九草莓，想吃其中最大的一颗草莓？（可模拟所需的所有数据） 自己实现筛选工具类public static &lt;T&gt; T getMax(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) { Objects.requireNonNull(list); Iterator&lt;T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext()) { T next = iterator.next(); int value = comparator.compare(result, next); if (value &gt; 0) { result = next; } } return result; } 其中Comparator不是系统的类，是我自己实现的接口 Comparator类代码： 123456789101112131415161718@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T t1, T t2); static &lt;E&gt; Comparator&lt;E&gt; comparing(ToIntFunction&lt;E&gt; function) &#123; return (E b1, E b2) -&gt; function.applyAsInt(b2) - function.applyAsInt(b1); &#125; static &lt;E&gt; Comparator&lt;E&gt; comparing(ToIntFunction&lt;E&gt; function, ToIntFunction&lt;E&gt; function2) &#123; return (E b1, E b2) -&gt; function.applyAsInt(b2) - function.applyAsInt(b1) == 0 ? function2.applyAsInt(b2) - function2.applyAsInt(b1) : function.applyAsInt(b2) - function.applyAsInt(b1); &#125; default Comparator&lt;T&gt; thenCompare(ToIntFunction&lt;T&gt; function)&#123; return (T t1, T t2) -&gt; compare(t1, t2) == 0 ? Comparator.comparing(function).compare(t1, t2) : compare(t1, t2); &#125;&#125; 使用lambda如何实现private static void filterVersion1() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, (Strawberry b1, Strawberry b2) -&gt; b2.getWeight() - b1.getWeight()); Out.println(&quot;我想吃最大的草莓是：&quot;); Out.println(strawberry.toString()); } 通过方法引用如何实现private static int getComparator(Strawberry b1, Strawberry b2) { return b2.getWeight() - b1.getWeight(); } private static void filterVersion2() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, Practice2Client::getComparator); Out.println(&quot;我想吃最大的草莓是：&quot;); Out.println(strawberry.toString()); } 在使用方法引用时，取方法名要格外恰当，好的方法名能让代码像是在描述问题而不是在解决问题 现在我不想吃最大的草莓了，我想吃最甜的草莓，要怎么做呢？高阶函数：如果一个函数的输入或者输出也是函数，那么这个函数就是高阶函数。举个例子 private static com.sugarya.interfaces.Comparator&lt;Strawberry&gt; comparing(Function&lt;Strawberry, Integer&gt; function) { return (Strawberry b1, Strawberry b2) -&gt; function.apply(b2) - function.apply(b1); } private static void filterVersion4() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, comparing(Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } 如果最大的草莓重量相同时，我想吃其中最甜的，怎么做？private static com.sugarya.interfaces.Comparator&lt;Strawberry&gt; comparing(Function&lt;Strawberry, Integer&gt; function, Function&lt;Strawberry, Integer&gt; function2) { return (Strawberry b1, Strawberry b2) -&gt; function.apply(b2) - function.apply(b1) == 0 ? function2.apply(b2) - function2.apply(b1) : function.apply(b2) - function.apply(b1); } /** * 找到最大的草莓，如果一样大，就要其中最甜的 */ private static void filterVersion5() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, comparing(Strawberry::getWeight, Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } java8的接口允许定义静态方法，要定义实例方法，需要关键词default，即为默认方法 如果要在其他类里再次筛选，代码就要重复，因此，考虑把逻辑封装到接口里，代码如下： 有没有办法像链式调用那样，在外层添加新的判断逻辑呢？可以的，Comparator接口里，实现thenCompare方法。 default Comparator&lt;T&gt; thenCompare(ToIntFunction&lt;T&gt; function){ return (T t1, T t2) -&gt; compare(t1, t2) == 0 ? Comparator.comparing(function).compare(t1, t2) : compare(t1, t2); } /** * 最大的草莓，如果一样大，就要其中最甜的 */ private static void filterVersion7() { Strawberry strawberry = CollectionUtils.getMax(RAW_STRAWBERRY_LIST, Comparator.comparing(Strawberry::getWeight).thenCompare(Strawberry::getSweetness)); Out.println(&quot;我想吃最甜的草莓是：&quot;); Out.println(strawberry.toString()); } 复合Lambda表达式这里我们自己实现了一个Lambda表达式的复合使用。把多个简单的Lambda复合成复杂的表达式 lambda重构Lambda与匿名内部类的差异匿名类中this代表的是函数式接口对象，但是在Lambda表达式中代表的是外部所在的类。 lambda表达式里的局部变量不能和外部的变量重名，匿名内部类可以 匿名内部类可以实现非函数式接口，lambda表达式只能作为是函数式接口的传入 lambda表达式的类型问题lambda表达式反映的是结构 12345678910111213private static void testLambda() &#123; testLambdaSign((Task) () -&gt; &#123; println(&quot;&quot;); &#125;);&#125;private static void testLambdaSign(Runnable runnable) &#123; println(&quot;testLambdaSign Runnable&quot;);&#125;private static void testLambdaSign(Task task) &#123; println(&quot;testLambdaSign task&quot;);&#125; lambda实战应用表达式解决设计模式与生俱来的设计僵化问题 lamdba表达式与设计模式对策略方法，观察者模式时，把设计模式里涉及到函数式接口替换成lambda表达式表示即可。 模板设计模式模板设计模式，通过继承抽象类，实现抽象方法来实现。这时候可以直接引入一个新的参数，来替换抽象类，函数描述符。 1234567891011121314151617181920212223242526public abstract class AbstractComputer &#123; public void work()&#123; powerOn(); int hardware = checkHardware(); loadOS(hardware); &#125; public void work(Consumer&lt;Integer&gt; consumer)&#123; powerOn(); int hardwareParam = checkHardware(); consumer.accept(hardwareParam); &#125; protected void powerOn()&#123; Out.println(&quot;开启电源&quot;); &#125; protected int checkHardware()&#123; Out.println(&quot;检查硬件&quot;); return 1; &#125; protected abstract void loadOS(int hardware);&#125; 责任链模式而责任链模式使用了复合lambda表达式 把数据结构里的链式思维应用在面向对象的编程里，将每一个链条的节点看作是一个对象，每个对象拥有不同的处理逻辑。一个业务逻辑被看作从链条的首端发出，途径一个个链节点，至末端结束。 面向对象的编程： 使用父类&amp;子类建立思维体系 通过类与类的相互联系和通信来组织逻辑 用重写来表达变化 用抽象方法表达抽象 用接口来表达抽象 链节点：作为对象，我们建立一个基类来表示，具体的每个节点是它的子类。 每个对象／节点处理不同的逻辑：不同是变化，需要抽象出来，可以用抽象方法表达抽象，也可以用接口表达抽象。这里我们用抽象方法来做 链式思维：每个当前节点，持有下一个节点，如果是双向的链式，则再持有上一个节点。常用的方式，当前节点的输出作为下一个节点的输入 代码实现123456789101112131415161718192021222324public abstract class AbstractNode&lt;T&gt; &#123; private AbstractNode&lt;T&gt; nextNode; public T startChain(T t)&#123; T element = handle(t); if(nextNode != null)&#123; return nextNode.handle(element); &#125; return t; &#125; public AbstractNode&lt;T&gt; getNextNode() &#123; return nextNode; &#125; public void setNextNode(AbstractNode&lt;T&gt; nextNode) &#123; this.nextNode = nextNode; &#125; public abstract T handle(T t);&#125; FirstNode1234567public class FirstNode extends AbstractNode&lt;String&gt; &#123; @Override public String handle(String s) &#123; return &quot;Hello, &quot; + s; &#125;&#125; SecondNode1234567public class SecondNode extends AbstractNode&lt;String&gt; &#123; @Override public String handle(String s) &#123; return s.replace(&quot;lamda&quot;,&quot;lambda&quot;); &#125;&#125; 使用12345678private static void testChainByLambda() &#123; Function&lt;String, String&gt; firstNode = s -&gt; &quot;Hello, &quot; + s; Function&lt;String, String&gt; secondNode = s -&gt; s.replace(&quot;lamda&quot;, &quot;lambda&quot;); Function&lt;String, String&gt; chain = firstNode.andThen(secondNode); String result = chain.apply(&quot;This is lamda&quot;); Out.println(&quot;chain result = &quot; + result); &#125; 简单工厂工厂设计模式，使用到构造函数的方法引用 123456789101112131415public class FruitFactory2 &#123; private static Map&lt;FruitType, Supplier&lt;? extends Fruit&gt;&gt; FRUIT_MAP = new HashMap&lt;&gt;(); static &#123; FRUIT_MAP.put(FruitType.Apple, Apple::new); FRUIT_MAP.put(FruitType.Strawberry, Strawberry::new); &#125; public static &lt;T extends Fruit&gt; T createFruit(FruitType fruitType) &#123; Objects.requireNonNull(fruitType); return (T)FRUIT_MAP.get(fruitType).get(); &#125; &#125; Java8的lambda表达式与Kotlin，Python的差异这些设计模式在使用lambda表达式重写会更简洁，但是也有人疑问，lambda只是让代码简洁而已，我用匿名内部类或接口仍然可以健壮的实现功能啊。对于这个疑问，我的理解是，如果赞同函数式编程是未来的方向，那么就很有必要使用lambda表达式，lambda表达式这套新的符号背后承载的是不同以往的思维方式–即所谓的“函数式”的思维。不够好的式Java8的lambda是不完全的函数式，但是从另一个角度来说，这也是好的，java8不完全的函数式能让java 7的程序员更容易和平稳得从面向对象过渡到函数式编程。 函数式的程度由低到高是： Java8 《 Kotlin 《 Python 我分别举个Koltin和Python的例子 Kotlin实现链式private fun startChain(str: String): String{ val firstNode: (String) -&gt; String = {s -&gt; &quot;Hello, &quot; + s} val secondNode = { s: String -&gt; s.replace(&quot;lamba&quot;, &quot;lambda&quot;)} return secondNode(firstNode(str)) } Kotlin比Java8更加函数式 Python实现链式1234567def startChain(x): firstNode = lambda x: &quot;Hello, &quot; + x secondNode = lambda x: x.replace(&quot;lamda&quot;, &quot;lambda&quot;) return secondNode(firstNode(x))print(startChain(&quot;This is lamda&quot;)) Python比Kotlin更加函数式]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>Functional Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式实战分析 上篇]]></title>
    <url>%2F2018%2F01%2F10%2F2018%2F2018-01-10%2F</url>
    <content type="text"><![CDATA[lambda表达式是Java 8中最大语言改变了，允许我们将函数当作参数传递给其他方法，简而言之就是实现了：行为参数化。 lambda表达式是函数式编程里重要的概念。现在我尝试通过一个例子来说明Lambda表达式的演化过程 lambda表达式是Java 8中最大语言改变了，允许我们将函数当作参数传递给其他方法，简而言之就是实现了：行为参数化 lambda表达式是函数式编程里重要的概念。现在我尝试通过一个例子来说明Lambda表达式的演化过程 一个果农的需求变化有个应用程序是帮助果农了解自己的库存的。这位果农可能想有一个查找库存中所有绿色苹果的 功能。但到了第二天，他可能会告诉你:“其实我还想找出所有重量超过150克的苹果。”又过了两天，农民又跑回来补充道:“要是我可以找出所有既是绿色，重量也超过150克的苹果，那就太 棒了。” 你要如何应对这样不断变化的需求? 需求变更过程1. 果农查找库存中所有绿色苹果实现代码如下： 1234567891011121314151617/** * 筛选绿苹果 * @param rawAppleList * @return */private static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; rawAppleList)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty())&#123; return result; &#125; for(Apple apple : rawAppleList)&#123; if(&quot;Green&quot;.equalsIgnoreCase(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result;&#125; 2. 果农查找库存中所有红色苹果需求从查找绿苹果变成了查找红苹果，可以推测之后农户有可能要查询黄苹果，因此新增一个颜色入参 12345678910111213141516171819/** * 筛选任意一颜色的苹果 * @param rawAppleList * @param color * @return */private static List&lt;Apple&gt; filterApplesWithColor(List&lt;Apple&gt; rawAppleList, String color)&#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty())&#123; return result; &#125; for(Apple apple : rawAppleList)&#123; if(color.equalsIgnoreCase(apple.getColor()))&#123; result.add(apple); &#125; &#125; return result;&#125; 3. 果农查找库存中超过150克的重苹果方法的入参增加一个形参：重量 /** * 筛选出大苹果 * @param rawAppleList * @param weight * @return */ private static List&lt;Apple&gt; filterApplesWithWeight(List&lt;Apple&gt; rawAppleList, int weight){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(weight &lt; apple.getWeight()){ result.add(apple); } } return result; } 4. 果农查找库存中的绿苹果和超过150克的重苹果引入表示重量和颜色的入参 /** * 通过颜色和重量筛选苹果 * @param rawAppleList * @param color * @param weight * @return */ private static List&lt;Apple&gt; filterApplesByProperty(List&lt;Apple&gt; rawAppleList, String color, int weight){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(color != null &amp;&amp; weight &gt; 0) { if (weight &lt; apple.getWeight() &amp;&amp; color.equalsIgnoreCase(apple.getColor())) { result.add(apple); } } } return result; } 果农之后想对苹果的不同属性做筛选，比如大小、形状、产地，品种等，怎么办？ 如果这位果农想多个属性组合查询，做更复杂的查询，比如红色的来自福建的大苹果，又该怎么办？ 应对这些需求，需要给方法里添加很多参数，有没有更好的封装？ 接口上述过程，复制了大部分的代码来实现遍历查询。如果你想要改变筛选遍历方式来提升性能呢? 那就得修改所有方法的实现，而不是只改一个，这代价太大了。我们需要复用，我们需要抽象。 提取抽象要确定抽象的部分，确定要求我们对需求的变更和未来的演化过程有清晰的认识，基于这种认识来确定抽象。 使用接口定义一个抽象方法，不同的判断条件交给不同的实现类来完成。一次判断条件看作一种行为，不同的实现类表达不同的筛选行为。 /** * 筛选苹果 * @param rawAppleList * @param predicate * @return */ private static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; rawAppleList, IApplePredicate predicate){ List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); if(rawAppleList == null || rawAppleList.isEmpty()){ return result; } for(Apple apple : rawAppleList){ if(predicate.test(apple)){ result.add(apple); } } return result; } 此时，filterApples方法的行为的差异取决于我们传给IApplePredicate的实现类的行为，filterApples行为被参数化了。 匿名内部类在使用过程中，发现如果判断条件有很多种，会生成多个实现类。使用匿名内部类能化简代码，减少啰嗦 List&lt;Apple&gt; apples = filterApples(RAW_APPLE_LIST, new IApplePredicate() { @Override public boolean test(Apple apple) { if (&quot;Red&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &lt; apple.getWeight() &amp;&amp; &quot;福建&quot;.equals(apple.getProducingArea())) { return true; } return false; } }); 果农需要查询什么，我传入不同筛选条件的匿名内部类。 使用Lambda表达式使用匿名内部类存在一段模板代码，我们希望连这样的模板代码都没有，让代码更简洁些。 然后，简洁性和易读性这两者看起来存在矛盾，简洁就意味着代码量少，往往也带来不易读。 Oracle工程师提出了一种处理方式： Lambda表达式来化解简洁性和易读性的冲突。 1234567filterApples(RAW_APPLE_LIST, (Apple apple) -&gt; &#123; if(&quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight())&#123; return true; &#125; return false;&#125;); lambda表达式详解lambda表达式组成部分使用匿名内部类和lambda表达式对比 123456789101112private static void testFilterAnonymous()&#123; filterApples(RAW_APPLE_LIST, new IApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); &#125; &#125;);&#125;private static void testFilterApplesLambda()&#123; filterApples(RAW_APPLE_LIST, (Apple apple) -&gt; &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight());&#125; lambda表达式由参数，箭头和方法体三部分组成. 一个方法有入参，返回值和方法实现。匿名内部类的里的test方法的入参，作为lambda箭头左侧部分，(当入参达到两个以上时使用圆括号)，test方法实现作为了lambda箭头右侧部分，test方法的返回值用右侧表达式返回值来表达。当需要多条语句时，需要用花括号{}，并显示声明返回的类型 1234567apple -&gt; &#123; println(&quot;&quot;); return &quot;Green&quot;.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); &#125;;``` lambda表达式是有返回类型的，是对应的接口名 Predicate filter = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566### 什么地方使用lambda表达式有函数式接口的地方就可以使用lambda表达式。**函数式接口：**只定义了一个抽象方法的接口。@FunctionalInterface我们熟悉的Runnable，Callback，Comparator, Comparable都是函数式接口写lambda表达式时，入参数量，各个参数的类型以及表达式返回类型怎么确定呢？这些信息，需要熟悉对应的函数式接口。Java8引入了一些新的函数式接口，常见的如下* Predicate\&lt;T&gt; boolean test(T t); * Consumer\&lt;T&gt; void accept(T t); * Supplier\&lt;T&gt; T get(); * Function\&lt;T, R&gt; R apply(T t); * BiFunction R apply(T t, U u); * UnaryOperator\&lt;T&gt; public interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123;&#125;* BinaryOperator\&lt;T&gt; public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;&#125; * Comparator int compare(T o1, T o2);**说明：**Java库提供的这些接口，没有异常处理，因此，要么我们自己定义函数式接口抛出一场，要么在使用这些系统提供的函数式接口写Lambda表达式时，自己捕获异常### lambda的相关概念#### 目标类型lambda表达式返回类型，也即函数式接口#### 函数描述符比如，上文的Predicate&lt;Apple&gt;的抽象方法的函数描述符为： (Apple) -&gt; Boolean ### Lambda表达式的类型检查Java编译器如何检查Lambda表达式的类型？1. 在调用lambda表达式处，找到目标类型，即函数式接口2. 找到在函数式接口里，抽象方法函数名，入参，返回值，生成函数描述符号。3. 抽象方法的函数描述符和lambda表达式的签名比对### 同样的Lambda表达式，可以有不同返回类型看下面的例子 Predicate appleFilter = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();12 Function&lt;Apple, Boolean&gt; appleFilter1 = (Apple apple) -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight();1234相同的Apple-&gt;Boolean 返回类型可以是Predicate，也可以是Function### 类型推断利用泛型的类型推断，可以省略lambda表达式入参的类型声明，比如 Predicate filter = apple -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight(); 12 filterApples(RAW_APPLE_LIST, apple -&gt; “Green”.equalsIgnoreCase(apple.getColor()) &amp;&amp; 150 &gt; apple.getWeight());123456## 方法引用方法引用能有效的简化lambda表达式，我们来举个例子创建一个草莓类，Strawberry public class Strawberry { private int weight; private String color; public Strawberry() { } public Strawberry(int weight) { this.weight = weight; } public Strawberry(int weight, String color) { this.weight = weight; this.color = color; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return &quot;Strawberry{&quot; + &quot;weight=&quot; + weight + &quot;, color=&apos;&quot; + color + &apos;\&apos;&apos; + &apos;}&apos;; } }12 public class TransferUtils { public static int doubleValue(int value){ return 2 * value; } public void tripleOver(int a){ System.out.println(String.valueOf(3 * a)); } }1234### 构造函数的方法引用无参构造 Supplier strawberrySupplier = Strawberry::new;Strawberry strawberry = strawberrySupplier.get();1一个参数的构造 IntFunction f = Strawberry::new;Strawberry strawberry = f.apply(10);1两个参数的构造 BiFunction&lt;Integer, String, Strawberry&gt; biFunction = Strawberry::new;Strawberry strawberry = biFunction.apply(20, “RED”);1234### 静态方法类名::方法名 /** * 静态方法引用 */ private static void testMRStatic(){ List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4); List&lt;Integer&gt; collect = list.stream() .map(TransferUtils::doubleValue) .collect(Collectors.toList()); println(collect); } 123456789### 实例的方法引用* 无入参的实例方法，格式同静态方法引用 String::length这种使用会有一个疑问：实例的方法引用为什么能用类名来引用？其实这里还是调用了实例的方法，上文的实例是字符串对象。 /** * 实例方法引用无参方法 */ private static void testMRObject(){ Arrays.asList(new Strawberry(21), new Strawberry(23)).forEach(Strawberry::displayWeight); } 1234 * 带入参的实例方法 类实例名::方法名 /** * 实例方法引用有参方法 */ private static void testMRObject2(){ TransferUtils transferUtils = new TransferUtils(); Arrays.asList(1, 2, 3, 4).forEach(transferUtils::tripleOver); } ` 练习题有一箱东港九九草莓，找到其中最大的一颗？（可模拟所需的所有数据） 小结lambda演化路径接口 –》匿名内部类–》Lambda表达式 问题回顾 从Java7到Java8，lambda表达式经历了怎样的逻辑演化？ lambda表达式能用在哪些场景？ lambda表达式和匿名内部类是什么关系？ 方法引用如何简化lambda表达式？ lambda表达式还可以复合使用，还可以在策略模式，模板方法，观察模式（接口回调）等设计模式中使用 相关的代码，已上传到Github 代码传送门 参阅的资料 简书：【译】Java 8的新特性—终极版 书籍：Java8实战 书籍：Java8函数式编程]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>Functional Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌2017GDD见闻录]]></title>
    <url>%2F2017%2F12%2F14%2F2017%2F2017-12-14%2F</url>
    <content type="text"><![CDATA[今年的谷歌开发者大会，还是盛况空前，热闹非凡。大会简单的说分为两大部分：技术分享，谷歌技术体验。今年的谷歌开发者大会，还是盛况空前，热闹非凡。大会简单的说分为两大部分：技术分享，谷歌技术体验。 在一个小时的开幕式里，讲述了谷歌去年一年以来的发展和变化，涉及Android，Android Wear，Firebase，ARCore，Tensorflow。尤其，开幕式上谷歌Cloud人工智能和机器学习首席科学家李飞飞宣布了一个重磅消息：谷歌AI中国中心在北京成立，充分表露了谷歌对中国市场的重视。今年Tensorflow相关内容的会场异常火爆，有开发者甚至提前听上一场的分享，就是为了把座位确定下来。 不得不说，谷歌的开发者活动搞得非常酷和良心，提供免费的自助午餐还有狂欢晚宴Party，更是赠送给开发者一大波礼物 DIY音响 笔记本包 贴纸 嘉宾工牌 谷歌腾出了一块场地用以展示其新技术和酷炫的产品。今年这次体验了一遍，重点感受了Android Wear，ARCore。这两个领域都是对Android手机平台的拓展和强化，相信之后尤其是ARCore会有一轮应用的小爆发。还有个很有趣的小应用girogio cam，会识别手机拍的照片内容，然后根据这个内容创作一首音乐，交互做的特别赞。 我在玩Map Line游戏 有一个谷歌开发技术创新英雄榜，展示了国内开发者使用谷歌新技术的案例。 下午有一场半个kotlin分享，我想说：我看好kotlin的发展，这门语言对Java程序员尤其有意义，kotlin比Java 8更好的函数式支持，更具动态语言的特性，对Java程序员有更好的更平滑的思维训练和跟进。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Google GDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对一路走来的学习路径的感想]]></title>
    <url>%2F2017%2F11%2F20%2F2017%2F2017-11-20%2F</url>
    <content type="text"><![CDATA[毕业多年，通信人在程序员圈混迹了4年之久。记得初入职场，技术老大和我两次的长聊中，谈话内容至今印象深刻的有两点： 一门成熟的语言一定有自举能力，即自身语言实现的编译器能解析自己 业务代码要尽快做完，业余时间里要拿80%放在计算机基础知识的学习上 学习策略毕业多年，通信人在程序员圈混迹了4年之久。记得初入职场，技术老大和我两次的长聊中，谈话内容至今印象深刻的有两点： 一门成熟的语言一定有自举能力，即自身语言实现的编译器能解析自己 业务代码要尽快做完，业余时间里要拿80%放在计算机基础知识的学习上 当时感觉，我是一名Android 工程师，我要打造好我的产品和用户体验，要把界面做到极致。在这之前，我是80%的下班时间继续优化和提高App的用户体验上的，当下我表示赞同，但是其实并没有足够重视，这两年多来一直并没有贯彻这个学习策略 计算机的基础能力有哪些呢？ 计算机结构，操作系统，算法和数据结构，网络通信协议，设计模式，编程语言 针对特定领域的工程师，还有该领域的基础知识。比如安卓工程师的安卓基础能力：对framework的熟知，包括自定义控件所需的所有能力等等 从容与持续忘记看的哪篇文章说过，做事不可用力过猛，期望越多则失望也越多，情绪的波峰和波谷反差也会越大。学习不可用力过猛，否则容易产生焦虑，焦虑是情绪弹簧的刚度值，焦虑让情绪偏向负面的势能增大。学习亦不可过于激动兴奋，否则容易在情绪低谷时对正向情感产生更多依赖。 学习贵乎平和从容 平和从容的源泉是深信持续的力量，相信持续是走向非常的桥梁 平和从容的就近法门是？ 走路要慢，回答要慢，冥想也算吧 每天重复做一件事，有一以贯之的生活 零和，无谓的接受损失 快乐求诸己 凝思远望，从容平和]]></content>
      <categories>
        <category>生活百感</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矢量图和矢量动画]]></title>
    <url>%2F2017%2F11%2F18%2F2017%2F2017-11-18%2F</url>
    <content type="text"><![CDATA[Android 5.0（API 级别 21）及以上版本支持矢量图， 如果要在Android2.1（API 7）到Android 4.4（API 20）版本使用矢量图，需要： Gradle 的 Android 插件 2.0 或更高版本 使用support 23.2或更高版本支持 Gradle配置 Android 5.0（API 级别 21）及以上版本支持矢量图， 如果要在Android2.1（API 7）到Android 4.4（API 20）版本使用矢量图，需要： Gradle 的 Android 插件 2.0 或更高版本 使用support 23.2或更高版本支持 Gradle配置 123defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125; 1appcompat-v7 使用AppCompatImageView, 使用app:srcCompat 如果你的Activity直接或间接继承自AppCompatActivity，当前视图中的ImageView在编译过程中会被自动转为AppCompatImageView（support包中所有含有AppCompat前缀的控件均受相同处理），因而在Activity中通过findViewById()的实例用ImageView或AppCompatActivity接收是没有区别的。 涉及到的类：VectorDrawableVectorDrawableCompatAnimatedVectorDrawableCompat Vector Asset Studio 支持必要的标准，但并非支持所有 SVG 和 PSD 功能，如果您收到错误，应验证矢量图是否像预期一样显示 矢量图适用于简单的图标，与对应的png图像相比，矢量图首次加载时可能消耗更多的 CPU 资源，所以推荐将矢量图像限制为最大 200 x 200 dp 在很多情况下，最好将图标设置为黑色 (android:fillColor=”#FF000000”)。通过此方法，您可以为布局中放置的矢量图添加 tint 属性，图标颜色将随之变为 tint 颜色。如果图标颜色不是黑色，图标颜色可能反而与 tint 颜色较为搭配。 如果最低 API 级别为 Android 4.4（API 级别 20）及更低版本，且您未启用支持库技术，则 Vector Asset Studio 将生成 PNG 文件 适合icon图标的应用场景，不适用于频繁切换回收的应用场景，会造成卡顿，因为矢量图是不被硬件加速支持的 注意点对PathData做缩放，旋转，位移时，name名称对应矢量图标签 &lt; group &gt; 来实现的 的 android:viewportWidth 和 android:viewportHeight 就是设置画布的大小 PathData内容说明： 如果同一个命令连续用多次，那么后面命令的字母是可以省略的，例如 M 25,25 L 50,25 L 50,50，第二个 L 是可以省略的，可以写成 M 25,25 L 50,25 50,50 大写字母代表绝对路径，小写的字母代表相对路径 参考资料： Android使用矢量图（SVG, VectorDrawable）实践篇 Android矢量动画实践 SVG 的 PathData 在 Android 中的使用 Android 矢量图动画（完结篇）]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参加Hackthon是一种什么样的体验]]></title>
    <url>%2F2017%2F11%2F07%2F2017%2F2017-11-07%2F</url>
    <content type="text"><![CDATA[我和我的队友们参加了为期两天的创新马拉松比赛。我们从无到有，目标是构建一个智能穿搭的AI虚拟衣橱，产品通过App来呈现。 我和我的队友们参加了为期两天的创新马拉松比赛。我们从无到有，目标是构建一个智能穿搭的AI虚拟衣橱，产品通过App来呈现。 项目介绍 项目名称：另衣伴 我们为美代言，为爱美的你推荐穿搭。我们目标实现： 1）自家衣橱随手带。逛商场，遇到喜欢的衣服，拍一张，我们在衣橱里找到搭配的衣服。 2）线上爱衣随意试。线上要是有你喜欢的衣服，我们告诉你同款衣服最近的店铺，试穿说走就走。 3）衣海淘金随心荐。在京东服饰里，找到匹配虚拟衣橱里的衣服。你的选择，我都懂。 衣服在前，我们要做的就是为你节省纠结与选择的烦恼。我们负责搭配，你负责美。 最后我们做出的产品，只实现了目标（1） 数据是本地模拟的，效果图如下： 该App已开源到Github上， 召唤传送门，欢迎star 附上产品另衣伴Android App下载二维码： 整个比赛过程中，有收获更有许多感触如何快速开发一款App？一个App有几个部分组成： 第三方类库 页面基类 网络请求 项目目录和Gradle配置 页面跳转和动画 快速开发一款App，就需要对上面这五个方面有自己熟悉的解决方案和套路，同时还需要： 封装App高频的交互逻辑，抽取特定场景为组件。当App的其他页面需要使用时，用组合的方式低耦合的快速引入。 选择合适的项目组织方式，现在安卓项目架构组织方式有MVC，MVP，MVVM；小型App和小团队使用MVC即可；中大型，多人开发App项目，考虑使用MVP或MVVM。 从开源世界里找到合适的第三方类库。在实现特殊的交互时，还需要快速的理顺开源框架代码组织关系，修改部分代码来满足自己的业务需要。 这时候开发一款App，就变成了拼图游戏，把一个个App的模块（图片）／轮子拼起来即可。在拼的时候，考虑怎么拼的无缝（高性能，内存不泄漏），怎么拼的快（敏捷开发） 重复的轮子要不要再造？我的思考结果是，只要项目时间允许，就得争取造轮子，哪怕是重复的轮子，或者已经有很优秀的轮子。只有自己造过轮子，看别人家的轮子（类库）才能做到驾轻就熟，举重若轻。 RxBus／EventBus如何理解？RxBus／EventBus是事件总线，提供全局消息通信，能实现类与类的通信。 使用时要注意： 监听的生命周期，做到生命周期最小。 发送的消息专项专用。只用一个类表示一个消息，一个消息实现一个功能。 消息总线只能用于组件的间的解耦。这意味着，它适用于页面间的通信，不适合一页面内，不同成员内部的通信。比如Adapter和Fragment之间的通信就完全不必使用事件总线的方式，通过方法来通信就可以了，从整个项目组织和可维护性上看，此处使用接口通信最适宜。 技术之外比赛开始之前，有10天左右的准备时间，这期间团队内部对比赛方向产生了分歧。队伍内算法工程师认为，我们要先有个全局的把握，像写论文一样去思考，优先把产品方案和框架定出来，时间不够可以不必落地产品；而我则主张以落地产品做出App为基本前提，最后的讨论的结果是两条线并行。 现在复盘，其实这样是不好的。在只有半个月的时间，资源是相当有限的，当时就应该统一思想，以产品落地为优先。发散讨论的过程是必要的，最后队长要有意识地把讨论集中起来，这个引导和集中是队长的工作内容和职责。 在进行团队讨论时，一定要有文字记录，讨论的后期全程录音了。这个会议文档必须由队长或者是项目进度推动人或者项目全局思考人来担任。 一次讨论整理出的结论，达成的共识要作为下一次讨论的起点，上一次讨论分配出去的任务，要作为下一次讨论的基础和输入。所以，会后的任务需要完成，大家任务的完成情况会很大影响整个项目的质量。 过程中，我既要完成另衣伴App研发，也要扮演队长（项目经理）的角色，明显感觉到了自己的精力不够用，不同工作内容和性质的切换会大大增加精力的损耗。 一线研发兼职不了项目经理，但是一线技术人员可以兼职产品经理的活。我感觉，好的团队有很多种，其中有一种可以是这样的：技术人员都是极客，同时又充当半个产品经理，主动的发挥各自的创造力和主观能动性。 智能推荐穿搭，很大的难点是搭配逻辑的建立和实施，这块难度大，准备前期，队长未能果断坚定的确立并执行以寻找并借助第三方类库为方向，项目完成度被大大折扣了。只有细化的分配任务到队员身上，才是推进项目的前提。如果分配的任务做到细致和明确责任人了，遇到未完成的，为了保证项目进度和质量，队长需要顶上和有效跟进。 队伍里大家对比赛的诉求和出发点会不一致，那么这期间面对同一件事就会有不同程度的发力。理想状态是：大家的出发点和发力程度是相近的。 小结和计划感谢队伍小伙伴们的努力和付出，我们经历了一个产品从0到1的质变，在半个月内从产品方案到想法最终落地。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Hackthon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件随想录--给软件项目打个比方]]></title>
    <url>%2F2017%2F10%2F10%2F2017%2F2017-10-10%2F</url>
    <content type="text"><![CDATA[如果把Java项目工程比做一部电影，那么出品人是公司，制片人是程序员，导演和演员是项目里的所有类 一个软件项目就像一部电影如果把Java项目工程比做一部电影，那么出品人是公司，制片人是程序员，导演和演员是项目里的所有类。 因此对类产生了一种划分方式：导演类（Director Class），角色类（Role Class）。对类里的方法产生了同样的划分：导演方法（Director Method）和角色方法（Role Method）。导演负责调用角色,角色做具体的事。 对应在方法里，导演方法里的实现即是调用角色方法或角色类，角色方法里是具体某个功能或行为的实现过程。在现实世界，存在纯粹的导演。导演方法里没有自己的逻辑实现就是纯粹的导演方法。也有自导自演的导演–导演方法里不仅有调用角色还附加有某些功能的实现过程。 对应在类里，项目中的Manager类就是导演类，工厂模式里的Factory类也是导演类，角色类就是那些被调用的类。大多数类是自导自演，对上是角色类，对下导演类。上下带来了层次性，存在顶级导演（最初的第一个导演类），高级导演（处在调用层次前列的） 我们是有好奇心的程序猿，某个恍然的时刻问自己：如果对自导自演的类不断向上追溯，最初调用在哪里发生呢？ 这真是有意思的思考。最初的调用就是Main方法，就是程序的主入口。如果我们把一段可运行的软件比做密西西比河，那么干流是导演类，支流是角色类。我们知道，主干和分支都是相对的，这个干流的分支是这个分支下的分支的干流。当我们想知道密西西比河最终流向哪里时，想要对密西西比河有一个主要的认识时，我们只要沿着密西西比河主干向前走就能找到河的出口和终点。软件项目里，找到那个主入口，沿着主入口的逻辑往下阅读。当我们想要了解某个细节时，找到主干下的对应的分支，从这个分支阅读代码。 一个软件项目代表一个二维的世界代码所在的世界是二维的世界，有横轴和纵轴。调用一个高级导演类的导演方法，形成了一个纵向世界；一个方法调用，当这个方法对类的成员变量做了修改，那么其他方法使用了这个成员变量；此时这个过程就形成了一个横向世界。 小结软件是程序员固化的思维，代码也是有味道的，当代码存在异味的时候，也即意味着重构要来临。做一个嗅觉敏感的程序猿，软件项目就会具有可读性和可维护性。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidThings之我见]]></title>
    <url>%2F2017%2F09%2F25%2F2017%2F2017-09-25%2F</url>
    <content type="text"><![CDATA[在传感器里集成Android Thing 加云处理，来收集商品数据 特性 Android things越少交互越好，只能开启&amp;安装唯一一个App，不涉及多进程，不支持动态权限申请 支持谷歌市场（play Service框架），支持firebase，采用Weave协议 支持RxJava和Kotlin编写 在传感器里集成Android Thing 加云处理，来收集商品数据 特性 Android things越少交互越好，只能开启&amp;安装唯一一个App，不涉及多进程，不支持动态权限申请 支持谷歌市场（play Service框架），支持firebase，采用Weave协议 支持RxJava和Kotlin编写 Android Things和Android在SDK上的区别？ 没有通知，ContentProvider 提供Android Things Console Android Things对安卓开发者的开发场景？ 硬件I／O支持：GPIO，PWM，I2C， SPI， UART，I2S。也就是说可以支持任何无线协议 上述是我参加谷歌社区Android Things分享所得。 个人的看法Android Things其实是嵌入式开发，在微型的硬件上做缩小版的Android开发，用熟悉的Android Studio，JDK，SDK。只是超瘦客户端的方式，嵌入式的设备每个都比较小，但是数量众多，为的是收集数据，上传到云服务，然后分析。大数据时代，数据都哪里来？这是未来来的数据来源之一，这个过程重点是收集到数据之后的处理，云存储，然后在服务器上的对数据加工处理，作为AI分析的前提。 小结因此，我的结论是：作为安卓程序猿，从技术成长和技能栈升级角度看，Android Things这个方向不适合。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Json序列化与反序列遇到Map时]]></title>
    <url>%2F2017%2F06%2F22%2F2017%2F2017-06-22%2F</url>
    <content type="text"><![CDATA[软件开发从数据的角度会经历三个阶段：获取数据，处理数据，展示数据 获取数据有如下方式： 从数据库获取 从网络请求获取 从本地生成业务逻辑的数据 背景软件开发从数据的角度会经历三个阶段：获取数据，处理数据，展示数据 获取数据有如下方式： 从数据库获取， 从网络请求获取， 从本地生成业务逻辑的数据。 App客户端上，数据最初来源于后台接口，http请求获取到json字符串，json反序列化生成实体类；在这个反序列化过程中可以生成基本数据类型，JavaBean，数组，集合。集合里有List和Map，平时我们遇到反序列化情况是Map&lt;String,Object&gt;，如果需要序列化成Map&lt;Object,Object&gt;，要怎么处理呢？ Json格式的表达，是以Key：Value的形式，Key只能是字符串，Value可以是对象或者数据，Map\&lt;Object,Object&gt;中Map的键是对象，这要怎么用json表现？ 常用的Json解析库有Gson，Jackson, Fastjson。阿里的Fastjson号称解析速度最快，Jackson解析速度比Gson快，常用在服务器端。谷歌的Gson解析稳定，常在App端使用，在中小数据量解析上和Jackson性能相近。我们来看看这三个库解析的结果 正文Gson与Map\&lt;Object,Object&gt;数据准备，生成Map集合 private LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; createMap() { LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; categoryMap = new LinkedHashMap&lt;&gt;(); List&lt;CategoryEntity&gt; firstCategoryList = new ArrayList&lt;&gt;(); firstCategoryList.add(new CategoryEntity(&quot;201&quot;, &quot;全部分类&quot;, true)); categoryMap.put(new CategoryEntity(&quot;101&quot;, &quot;全部分类&quot;, true), firstCategoryList); List&lt;CategoryEntity&gt; secondCategoryList = new ArrayList&lt;&gt;(); secondCategoryList.add(new CategoryEntity(&quot;211&quot;, &quot;遥控赛车&quot;, false)); secondCategoryList.add(new CategoryEntity(&quot;212&quot;, &quot;乐高积木&quot;, false)); secondCategoryList.add(new CategoryEntity(&quot;213&quot;, &quot;泰迪小熊&quot;, false)); categoryMap.put(new CategoryEntity(&quot;111&quot;, &quot;儿童玩具&quot;, false), secondCategoryList); List&lt;CategoryEntity&gt; thirdCategoryList = new ArrayList&lt;&gt;(); thirdCategoryList.add(new CategoryEntity(&quot;221&quot;, &quot;电磁炉&quot;, false)); thirdCategoryList.add(new CategoryEntity(&quot;222&quot;, &quot;电饭煲&quot;, false)); categoryMap.put(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false), thirdCategoryList); List&lt;CategoryEntity&gt; fourthCategoryList = new ArrayList&lt;&gt;(); fourthCategoryList.add(new CategoryEntity(&quot;231&quot;, &quot;Java8函数式编程&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;美的历程&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;黑客与画家&quot;, false)); fourthCategoryList.add(new CategoryEntity(&quot;232&quot;, &quot;代码的未来&quot;, false)); categoryMap.put(new CategoryEntity(&quot;131&quot;, &quot;自营书籍&quot;, false), fourthCategoryList); return categoryMap; } Gson的序列化和反序列示例代码： private void gsonTest() { LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String toJson = GsonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;toJson = &quot; + toJson); LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; parserMap = GsonUtil.getInstance().fromJson( toJson, new TypeToken&lt;LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt;&gt;() { }.getType()); LOG.D(TAG, &quot;fromJson = &quot; + parserMap.toString()); List&lt;CategoryEntity&gt; parseCategoryList = parserMap.get(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false)); LOG.D(TAG, &quot;parseCategoryList = &quot; + parseCategoryList.toString()); } 几点说明： 选用LinkedHashMap()，可以确保按位置顺序反序列化 GsonUtil单例模式，反序列化类型通过TypeToken来指定 序列化结果如下： [ [ { &quot;id&quot;: &quot;101&quot;, &quot;isSelected&quot;: true, &quot;name&quot;: &quot;全部分类&quot; }, [ { &quot;id&quot;: &quot;201&quot;, &quot;isSelected&quot;: true, &quot;name&quot;: &quot;全部分类&quot; } ] ], [ { &quot;id&quot;: &quot;111&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;儿童玩具&quot; }, [ { &quot;id&quot;: &quot;211&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;遥控赛车&quot; }, { &quot;id&quot;: &quot;212&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;乐高积木&quot; }, { &quot;id&quot;: &quot;213&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;泰迪小熊&quot; } ] ], [ { &quot;id&quot;: &quot;121&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;厨房用品&quot; }, [ { &quot;id&quot;: &quot;221&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;电磁炉&quot; }, { &quot;id&quot;: &quot;222&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;电饭煲&quot; } ] ], [ { &quot;id&quot;: &quot;131&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;自营书籍&quot; }, [ { &quot;id&quot;: &quot;231&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;Java8函数式编程&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;美的历程&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;黑客与画家&quot; }, { &quot;id&quot;: &quot;232&quot;, &quot;isSelected&quot;: false, &quot;name&quot;: &quot;代码的未来&quot; } ] ] ] 小结： Gson序列化LinkedHashMap, 它会把Map的Key部分和Value部分放在同一层级，作为数组的元素。 Jackson与Map\&lt;Object,Object&gt;使用jackson序列化／反序列化代码： private void jackJsonTest(){ LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String json = JacksonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;jackJson = &quot; + json); LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; parseMap = JacksonUtil.getInstance().fromJson( json, new com.fasterxml.jackson.core.type.TypeReference&lt;LinkedHashMap&lt;CategoryEntity,List&lt;CategoryEntity&gt;&gt;&gt;() {}); LOG.D(TAG, &quot;parse map = &quot; + parseMap.toString()); List&lt;CategoryEntity&gt; categoryEntityList = parseMap.get(new CategoryEntity(&quot;121&quot;, &quot;厨房用品&quot;, false)); LOG.D(TAG, &quot;jackson list = &quot; + categoryEntityList.toString()); } 说明： JacksonUtil使用单例，通过TypeReference指定jackson反序列的类型 Jackson解析结果如下： { &quot;CategoryEntity{id=&apos;101&apos;, name=&apos;全部分类&apos;, isSelected=true}&quot;: [ { &quot;id&quot;: &quot;201&quot;, &quot;name&quot;: &quot;全部分类&quot;, &quot;selected&quot;: true } ], &quot;CategoryEntity{id=&apos;111&apos;, name=&apos;儿童玩具&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;211&quot;, &quot;name&quot;: &quot;遥控赛车&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;212&quot;, &quot;name&quot;: &quot;乐高积木&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;213&quot;, &quot;name&quot;: &quot;泰迪小熊&quot;, &quot;selected&quot;: false } ], &quot;CategoryEntity{id=&apos;121&apos;, name=&apos;厨房用品&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;221&quot;, &quot;name&quot;: &quot;电磁炉&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;222&quot;, &quot;name&quot;: &quot;电饭煲&quot;, &quot;selected&quot;: false } ], &quot;CategoryEntity{id=&apos;131&apos;, name=&apos;自营书籍&apos;, isSelected=false}&quot;: [ { &quot;id&quot;: &quot;231&quot;, &quot;name&quot;: &quot;Java8函数式编程&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;美的历程&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;黑客与画家&quot;, &quot;selected&quot;: false }, { &quot;id&quot;: &quot;232&quot;, &quot;name&quot;: &quot;代码的未来&quot;, &quot;selected&quot;: false } ] } 小结：Jackson在序列化Map时，会把Map的Key对应的对象默认解析成字符串；但是这个字符串格式不是Json的格式，通过添加自定义Map的键的序列化解析类和反序列化解析类，可以实现对CategoryEntity对象Json序列化／反序列化 public JacksonParser() { mObjectMapper = new ObjectMapper(); SimpleModule simpleModule = new SimpleModule(); simpleModule.addKeyDeserializer(CategoryEntity.class, new MapKeyDeserializer()); simpleModule.addKeySerializer(CategoryEntity.class, new MapKeySerializer(CategoryEntity.class)); mObjectMapper.registerModule(simpleModule); } Fastjson与Map\&lt;Object,Object&gt;Fastjson序列化和反序列示例 12345private void fastJsonTest() &#123; LinkedHashMap&lt;CategoryEntity, List&lt;CategoryEntity&gt;&gt; linkedHashMap = createMap(); String s = FastJsonUtil.getInstance().toJson(linkedHashMap); LOG.D(TAG, &quot;fastJson = &quot; + s);&#125; 说明： 单例FastJsonUtil，通过TypeReference来指定反序列化类型 解析结果 { {&quot;id&quot;:&quot;101&quot;,&quot;name&quot;:&quot;全部分类&quot;,&quot;selected&quot;:true} :[{&quot;id&quot;:&quot;201&quot;,&quot;name&quot;:&quot;全部分类&quot;,&quot;selected&quot;:true}], {&quot;id&quot;:&quot;111&quot;,&quot;name&quot;:&quot;儿童玩具&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;211&quot;,&quot;name&quot;:&quot;遥控赛车&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;212&quot;,&quot;name&quot;:&quot;乐高积木&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;213&quot;,&quot;name&quot;:&quot;泰迪小熊&quot;,&quot;selected&quot;:false}], {&quot;id&quot;:&quot;121&quot;,&quot;name&quot;:&quot;厨房用品&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;221&quot;,&quot;name&quot;:&quot;电磁炉&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;222&quot;,&quot;name&quot;:&quot;电饭煲&quot;,&quot;selected&quot;:false}], {&quot;id&quot;:&quot;131&quot;,&quot;name&quot;:&quot;自营书籍&quot;,&quot;selected&quot;:false} :[{&quot;id&quot;:&quot;231&quot;,&quot;name&quot;:&quot;Java8函数式编程&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;美的历程&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;黑客与画家&quot;,&quot;selected&quot;:false},{&quot;id&quot;:&quot;232&quot;,&quot;name&quot;:&quot;代码的未来&quot;,&quot;selected&quot;:false}] } 小结：fastjson序列化Map，生成的字符串不是json格式，Key部分直接序列化成对象。通过{}:[]这种格式来表现Map\&lt;CategoryEntity,List\&gt;的key和value。 小结开发中，较少会遇到需要序列化Map\&lt;Object,Object&gt;，即使遇到了也可以通过改变实体类的数据结构来规避这种解析，把Key的Object对象放入到Value的对象里，组成新的实体类，而Map的Key用String来表示。因此，本例的Map\&lt;CategoryEntity,List\&gt;,可以把Map的Key部分的对象Category放入到List集合的里。这样，在某些场景，把二维层面的数据，降为一维数据，通过链式的调用来获取原来二维的数据，把数据维度转化成了链式调用的深度。 示例代码上传到Github上了，欢迎Star，传送门]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8函数式编程--编程范式的趋势]]></title>
    <url>%2F2017%2F06%2F16%2F2017%2F2017-06-16%2F</url>
    <content type="text"><![CDATA[让我们来说说函数式编程–Lambda表达式 上周开始，看了这本书–Java 8 函数式编程，以下是我的读书摘抄 让我们来说说函数式编程–Lambda表达式 上周开始，看了这本书–Java 8 函数式编程，以下是我的读书摘抄。 背景知识：函数接口：只有一个抽象方法的接口 方法签名：由方法名+形参列表构成+返回值类型。JVM是并没有特别明确的将数据类型写出来，而是提供了特殊的表示法。 惰性求值方法： 只描述Stream，不产生实际执行的方法 及早求值： 立刻执行 函数的副作用：当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响（例如修改全局变量或修改参数） 纯函数：输入输出数据流全是显式的（显式的含义是：函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部） 非纯函数：与纯函数相反，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如，读取全局变量，修改全局变量。 阿姆达尔定律：对于固定负载情况下描述并行处理效果的加速比s，S=1/(1-a+a/n)，其中a为并行计算部分所占比例，n为并行处理结点个数 正文Lambda表达式在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值 Lambda表达式 传入一段代码块 不需要显式声明／指定参数类型（编译器可以通过方法签名来推断类型） Lambda表达式引用的局部变量必须是final或既成事实上的final变量（基本类型只能赋值一次，对象的引用不能改变） Stream API意义和创新：遍历从外部迭代变成了内部迭代。把程序扮演Director导演类的部分逻辑和操作提取、转移到了类库中 实现机制Stream操作分为惰性求值和及早求值；形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。 整个过程被分解为多个惰性求值操作和一个单个及早求值操作，而这些多个操作只需要遍历一次。整个过程和建造者模式有共同之处。建造者模式使用一系列操作来设置属性并配置，最后调用build方法，这时，对象才被真正创建。 常用的流操作collect：流生成集合 map：改变流中元素的类型 flatMap：把最初流中的一个元素转成一个流 filter：过滤流中的元素 Max/Min：求极值，返回 Optional （涉及比较器类Comparator，因为比较意味着排序，排序意味着需要一个排序的指标） reduce Lambda表达式正确使用姿势1）明确要达成什么转化，而不是说明如何转化2）写出的函数尽量没有副作用纯函数的优点 无状态，线程安全。不需要线程同步。 纯函数相互调用组装起来的函数，还是纯函数。 可缓存结果，原生支持并行（不懂） I/O API可以看作是一种特殊的全局变量。文件、屏幕、数据库等输入输出结构可以看作是独立于运行环境之外的系统外全局变量，而不是应用程序自己定义的全局变量。 类库装箱类型在Lambda表达式上的体现 int整型在内存中占用4个字节，Integer在内存中占用16字节； 基本类型和装箱类型相互转化需要额外的计算开销 在Java中想要一个包含整型值的列表List,实际上得到的却是一个包含整型对象的列表List； 对于需要大量数值运算的算法来说，由于上述的原因，减缓了程序的运行速度 因此，Stream类的某些方法对基本类型和装箱类型做了区分；Java 8对整型，长整型和双浮点型做了特殊处理；方法有：mapToLong(),MapToInt(); Lambda表达式的重载Lambda表达式的类型就是对应的函数接口类型。遇到重载时调用准则： 优先执行最具体的类型 如果最具体的类型有多个，则需要认为指定类型 默认方法Java 8新增一个关键词default，在接口中，可以存在由default修饰的默认方法（也就是说，Java 8接口里，不再只能是抽象方法，具体的方法也可以存在即默认方法；同时，也允许存在静态方法），当子类不实现这个接口的某个抽象方法时，子类就是使用该默认方法。 还要注意一点：一个类要实现的接口里，存在默认方法和它父类的方法相同，则优先选择父类定义的方法。 归纳出两条简单的定律： 类胜于接口。如果在继承链中有方法或抽象方法声明，那么久可以忽略接口中定义的方法 子类胜过父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认的方法，那么子类中定义的方法胜出。 Optional该新的数据类型，用来替换null。Optional对象相当于值的容器，类似ThreadLocal用法 创建Optional对象：Optional.of() 获取值：get(); 获取可能存在的空值：empty(). 判断Optional对象理是否有值：isPresent(); orElse(T t),当Optional对象为空时，提供一个备选值t orElseGet(Supplier supplier):当Optional对象为空时，调用这个函数接口 特殊的修饰@FunctionalInterface该注释会强制javac检查一个接口是否符合函数接口的标准（一个接口，只有一个抽象方法），如果该注释添加给一个枚举类型，类或另一个注释，或者接口含不止一个抽象方法，javac就会报错（编译的时候）。重构代码时，使用它能很容易发现问题。 高级集合类方法引用本小节摘自【译】Java 8的新特性—终极版 方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 西门的例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。 public static class Car { public static Car create( final Supplier&lt; Car &gt; supplier ) { return supplier.get(); } public static void collide( final Car car ) { System.out.println( &quot;Collided &quot; + car.toString() ); } public void follow( final Car another ) { System.out.println( &quot;Following the &quot; + another.toString() ); } public void repair() { System.out.println( &quot;Repaired &quot; + this.toString() ); } } 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。 final Car car = Car.create( Car::new ); final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create( Car::new ); cars.forEach( police::follow ); 数据并行化并发，并行；数据并行化；任务并行化 调用parallelstream()／parallel(),生成一个并行化流 收集器Collectors.toList()，Collectors.toSet,Collectors.to 调试Lambda表达式对于业务稳定，生命周期较长的产品，可以引入单元测试。 程序员写出的程序bug，有两种： 实现业务逻辑的思路错误 实现业务逻辑的思路对了，但是在实现过程中出了问题，开发者设想的过程和真实的情况不同。 软件产品种，大部分bug来源于第二种。我们对单元测试，下一个定义：单元测试是测试一段代码的行为是否符合预期的方式。我们对每一个方法输出结果都存在一个预期，这个预期是我们在实现业务过程中的一个环节，这些环节全部累加起来，每个环节的结果都是我们想要的，那么这个业务我们就能正确的实现了。因此，单元测试，能检测出第二种bug； 对重构Lamdba表达式的思考如果存在多个方法，每个方法的处理过程相同，输入输出类型相同，不同的是操作的具体逻辑，则可以把相同的操作提取成新的方法，不同的操作通过方法入参来体现。比如下面两个方法： 计算音乐家数量 public long countMusicians(){ return albums.stream() .mapToLong(albu -&gt;.getMusicians().count) .sum() } 计算单曲数量 public long countTracks(){ return albums.stream() .mapToLong(albu -&gt;.getTracks().count) .sum() } 要怎么重构呢？ 首先我们定义一个函数接口，输入Album类，输出一个long型, 引入泛型（Java 8其实已经定义了这种输入输出的接口了） public interface ToLongFunction&lt;T&gt;{ long applyAsLong(T value); } 我们知道，Lambda表达式返回类型是函数接口，因此上述的两个方法就可以重构成下面的样子 public long countMusicians(){ return countFeature(ablum -&gt; album.getMusicians().count()) } public long countTracks(){ return countFeature(ablum -&gt; ablum.getTracks().count()) } private long countFeature(ToLongFuction&lt;Album&gt; function){ return albums.stream() .mapToLong(function) .sum(); } 整个思考过程，和非函数式编程是类似的。 对惰性求值方法的调试Java 8 提供了一个方法peek()，举个例子 Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .peek(e -&gt; System.out.println(&quot;Peeked value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList()); 这样就能对流的每一个元素处理的先后值的变化进行观察了]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浪潮之巅--站在时代的潮前企业]]></title>
    <url>%2F2017%2F06%2F05%2F2017%2F2017-06-05%2F</url>
    <content type="text"><![CDATA[前段时间看了吴军老师的浪潮之巅，做些简单的笔记摘抄，记录如下 前段时间看了吴军老师的浪潮之巅，做些简单的笔记摘抄，记录如下 前言比尔盖茨语录： 我们总是高估未来两年的变化，却低估未来十年的变化。不要让自己无所作为。 任何在商业世界应用的技术，首要准则即是，自动化只有应用在一项有效率的业务上面时才会把效率放大。第二点准则，自动化应用在一项低效的业务上时只会让效率更低。 在IT领域，当你意识到自己有麻烦的时候一切已经太晚了，想救自己已经来不及了。除非你整日在恐慌中忙碌，否则就会被淘汰。 IT产业三大定律摩尔定律（反摩尔定律），安迪-比尔定律，诺威格定理 摩尔定律晶体管的数量每18个月翻番,芯片的性能每隔18个月翻番一次. 有趣的是，还有一个叫反摩尔定律。该定律由Google的前CEO埃里克·施密特提出，即：一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。这要求硬件公司的产品需要快速迭代，电子产品的迭代周期至多是一年半。比如手机领域，华为，小米，锤子，三星等厂商每年都必须发布至少一款新机的。 安迪-比尔定律安迪指英特尔前CEO安迪·格鲁夫，比尔指微软前任CEO比尔·盖茨 定律内容：Andy gives, Bill takes away（安迪提供什么，比尔拿走什么）。 言外之意是硬件提高的性能，很快被软件消耗掉了。这也解释了人们为什么要不断地更新自己的硬件 诺威格定理当公司的市场占有率&gt;50% ，市场占有率无法再翻番了。这句话很直白的话道出许多大公司兴衰的根源：在一个市场占主导地位的公司必须不断开拓新财源，才能长盛不衰。 为什么一家公司转型就那么难呢？一个在某个领域特别成功的大公司已经被优化得非常适应这个市场，它的文化，做事方式，商业模式，市场定位已经甚至过分适应传统的市场。这些使得该公司获得成功的内在因素会渐渐地，深深地植入该公司。就好比一个已经开始养尊处优的40岁的人重新走入课堂，去和一群20岁的年轻人在一起从头开始读书，学习起来比没有负担的年轻人要难得多。更何况，年轻的公司没有退路只有向前进，而成熟的公司总有它传统的业务可以依赖，一旦遇到问题就可能退缩 书中举了例子：以大型机、系统和服务为核心的IBM公司很难在PC市场上成功；微软MSN部门十几年了还不能盈利。 科技公司的上市过程科技公司的经营业务是科技产品和服务，而不是证券，所以它不能自己到证券交易所去兜售自己的股票，要交给承包商。承包商（比如高盛，摩根斯坦利这样的公司）从被承包的公司收购特定数量的股票，并且以同样的价格分配给它们的客户，能获得两笔收入：1.佣金 2.融资7%的股票金额 科技公司找到一家合适的承包商，弄清三件事 上市时市值多少 上市时融资多少 确定给承包商的佣金和今后的期权多少]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一分钟带你了解2017 Google I/O大会内容]]></title>
    <url>%2F2017%2F05%2F18%2F2017%2F2017-05-18%2F</url>
    <content type="text"><![CDATA[北京时间2017年5曰18日凌晨01点钟，2017年Google I/O大会如期举行（ Google I／O大会的IO的含义：Input/Output &amp; Innovation in the open），第一场keynote大体分为如下三个部分： 北京时间2017年5曰18日凌晨01点钟，2017年Google I/O大会如期举行（ Google I／O大会的IO的含义：Input/Output &amp; Innovation in the open），第一场keynote大体分为如下三个部分： Google Home &amp; Google LensGoogle Home在去年谷歌大会上会首次展示，今年新增了语音电话（ Hands Free Calling）等更新 对Google Photos和Youtube这两个App加入了AI功能，新增不同情景下的预测和回应，而且能文字搜索出对应的图片。有一个比较大的点是对IOS系统开放了google Assistance. 人工智能集中体现在Google Lens，它基于视图形识别技术，能根据相机取景进行智能识别，然后分辨出图像里的信息内容，还能和Google Assistant联动。 Android部分Android O Developer Preview（预览版），本次大会并没有像往常那样公布最终的版本号，预测的奥利奥的缩写暂时还没有答案。 本次android新版本，加强了权限和电池使用，系统层面支持画中画（Picture-in-Picture），还有一些零散的体验优化，比如：对通知栏也做了一些更新；简化对文本选择操作；2倍的开机速度 谷歌官方支持了Kotlin开发Android App，这对App开发将带来很大的影响,kotlin能带给开发者更高效的开发效率。早在两三年前，安卓届的大神Jake Wharton就开始涉及Kotlin编程，并开源了好几个kotlin写的类库。作为Android开发者，是时候考虑如何学习kotlin了。 VR/AR 听这部分内容时，人已犯困，只记得个大概。 Daydream ，vive, coming in late 2017 Tango; visual positioning service; Expeditions; 小结不难发现，尽管Android仍然是I／O大会的主角，但已不再成为唯一的主角，人工智能和虚拟现实被谈及得越来越多，相信未来相关的硬件就会大范围的出现在我们生活中，比如虚拟眼镜，各种可穿戴的智能硬件。 最后，借用Google CEO Sundar Pichai一句话：Mobile first to AI first，AI First将会成为未来google的基调。]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[松本行弘眼里的代码未来]]></title>
    <url>%2F2017%2F04%2F21%2F2017%2F2017-04-21%2F</url>
    <content type="text"><![CDATA[代码的未来，松本行弘在2013年所著，该书对云计算、大数据时代下的各种编程语言以及相关技术进行了剖析，并对编程语言的未来发展趋势做出预测。 以下是我阅读这本书的笔记摘抄，这本书能提高程序员的素养。代码的未来，松本行弘在2013年所著，该书对云计算、大数据时代下的各种编程语言以及相关技术进行了剖析，并对编程语言的未来发展趋势做出预测。 以下是我阅读这本书的笔记摘抄，这本书能提高程序员的素养。 第一章对摩尔定路的局限的思考在不远的将来，会出现一些因素，对摩尔定律的继续生效构成障碍 最近的LSI（大规模集成电路）的宽度已经缩小到只有数十纳米，只能排列几个原子，这样在原子尺度上来制造电路是相当困难的 LSI中的电路是采用一种印刷技术印上去的，光的波长成了问题，如果图像的尺寸比光的波长还小，就无法清晰地转印。可见光的波长范围约为400-800nm，因此最近45nm制造的LSI是无法用可见光制造的，而是使用X光代替 在这种原子尺寸的电路中，保持绝缘也是相当困难的。电流通过了原本不该通过的地方，这种漏电流还会引发发热，LSI越来约精密，其密度也越来越高，热密度也随之提高，如果没有充分的散热措施，连LSI本身都会溶化 漏电流和热密度等问题，CPU的性能提高遇到了瓶颈。多CPU化，内存容量增大，SSD硬盘会成为主流，真正的并发编程也会成为主流 算命先生预言的原理1.2节 巴纳姆效应（福勒效应）每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人 冷读术（cold reading）：通过观察对方的言行举止中的一些细微之处来进行揣测，了解到他人的心理活动。像福尔摩斯对他的委托人所运用的那种技巧差不多。 热读术（hot reading）：通过事先对对方进行详细的调查，藉时机说出对方的情况，此时就会显得神奇无比。 IT未来之预测未来应该是位于过去到现在这个方向的延长线上 从价格看未来 普通人所能拥有的计算机性能将比现在大大提高 现在还没使用计算机的地方，以后都会安装上计算机 从性能看未来看看现在的超级计算机，再过20年，就是现在的一般般的配置了，比如数万CPU，数十万核心配置会成为普遍 基于这样的环境，编程又回编程什么样子呢？为了充分利用这么多的CPU，软件开发又会如何进化呢？未来的编程语言应该在如何利用CPU资源这个方面进行争夺，并行处理的功能。 从容量看未来在不久的将来，由超高速低容量的核心内置缓存，高速但断电会丢失数据的主内存（RAM），以及低速但可永久保存数据的外部存储器（HDD）所构成的结构将会消失，取而代之的可能将是由大规模的缓存，以及高速且能永久保存数据的内存所构成的新层次结构。相应的依赖过去存储结构的数据库系统将产生大规模的结构改革。 从带宽看未来1G bit／s的上网服务已面向某些国家的家庭推出了 在性能和带宽寻求平衡的过程中，网络彼此两端的系统构成也会像钟摆一样摇格不停，随着每次钟摆的来回，系统的规模，拓展性和自由度都能够得到提高。 第二章 编程语言的世界世界上第一位程序员实际上是一位女性 机器语言就是一串数字，将计算机的步骤从指令表中查出对应的机器语言编码，再人工写成数列。（机器语言和CPU执行之间至少还有一层：指通过指令表找到并输入对应的机器语言，机器就能执行一条条指令，指令让机器产生计算和处理） 查表这种工作本来应该是计算机最擅长的，人们用更加容易记忆的指令（助记符）来代替数值，并开发了一种能够自动生成机器的语言程序，这就是汇编器。汇编器用来解释汇编语言的程序，汇编语言中所使用的助记符和计算机指令是一一对应的关系。 也就是说汇编语言是由编程者自己的需要发明出来的 编程语言的进化进程看，一个显著的关键词就是“抽象化”。随着抽象化的不断深入，程序员即便不去关心内部的详细情况，也可以编写出程序。人类一次所能掌握的概念的数量，有说法称，大部分人一次只能驾驭5到9个左右的概念。抽象化程序高的编程语言不必描述详细过程，从而可以用简短的代码达到目的。 我的思考： 语言的发展：机器语言－－》汇编语言－－－》高级语言（比如Java，Python），现在几乎程序员都处在使用高级语言上；高级语言经过编译器执行编译处理转化成汇编语言，再经过汇编器和链接器进行汇编和链接处理转化成机器语言，被计算机执行。而现在，编译器和汇编器和链接器都已经很成熟了，程序员在高级语言阶段写代码就可以了 一方面，汇编语言虽然速度快，但是在工业化领域，一个系统用汇编语言，代码量将是极为庞大的，我推测有百万行的代码了。而高级语言，可能只有不到一万行。另一方面，编译器和汇编器非常完善了，引入了很多机制，保证最好的还原。同时，在现在CPU 达到2GB的能力下，高级语言编写的代码带来的损耗完全可以被忽略 未来编程语言格雷厄姆主张，100年后的编程语言的进化主线应该是以最少量公理为基础的“拥有最小最简洁核心的语言”，在现有编程语言中，最具有这一特征的莫过于他最喜欢的Lisp了，Lisp是100年后编程语言的进化方向。 松本行弘认为，编程语言的进化动机，不是工具和语言本身的简化，而是将通过这些工具和语言所得到的结果更简洁地表达出来。抽象化的趋势会一直持续下去 100年后的编程语言有这三种可能： 可能性1：变化不大 可能性2: 使用编程语言来编程这个行为本身不存在了，通过人机对话等方式 可能性3: 发明了更高抽象度的编程语言。是比现在更加强调what，而对如何解决问题的how部分的细节，则不需要人们去过问。 20年后的编程语言： 编程语言本身不会发生多大的变化，实际上现在使用的很多语言，在20年前就已经存在了。 20年后的语言，应该是在分布处理和并行处理功能上进行强化，使得开发者不需要特别心思就能使用这些功能。 线程，RPC（远程过程调用）等显式地使用分布处理和并行处理的形式，早晚会遇到瓶颈，当核心数超过数千个的时候，显式地指定就变得毫无意义了。未来的编程无需显式操作就能实现分布处理和并行处理。 DSL（特定领域语言）所谓DSL（Domain Specific Language），是指利用为特定领域所专门设计的词汇和语法，简化程序设计过程，提高生产效率的技术。是对特定目的的小规模语言的称呼。 DSL的优势：拥有为特定领域所设计的词汇，可以在高级层面上编写代码，节约程序开发的时间。即，不涉及对象领域的内部详细，而是在高级层面上进行描述。 外部DSL由专用语言引擎来实现的DSL，称为外部DSL。比如，数据库访问使用的SQL就是一种典型的外部DSL。正则表达式用来描述字符串模版，也是一种外部DSL。 外部DSL的优点：它独立于编程开发所使用的语言之外，在不同语言中都可以使用。实际上是全新设计的语言和语言引擎，不必被特定的执行模块和现有语言的语法所左右。 内部DSL不是创造一种新的语言，而是在现有语言中实现DSL，而作为DSL基础的这种现有语言称为宿主语言。Lisp，Smalltalk，Ruby这些语言适合作为DSL的宿主语言。 内部DSL的优点：内部DSL借用宿主语言的语法，在理解内部DSL含义时，宿主语言的常识依然有效，可以使用宿主语言所具备的全部功能。 元编程程序在运行过程中，本身的信息可以被访问和操作，就是元编程。程序由数据结构和算法构成，如果环境允许程序本身作为数据结构来操作的话，那么元编程也就和面向一般数据结构的一般操作没什么两样了。 内存管理与GC根判断对象是否可被引用的起始点 GC算法标记清除（Mark and Sweep）从根开始将可能被引用的对象用递归的方式进行标记（通过对象内部的标志来实现），将没有标记的对象视为垃圾进行回收。标记清除原理详细介绍 缺陷： 每次清除都需要全局扫描一次，当在分配大量对象时，只有一小部分存活的情况下，所消耗的时间会大大超过必要的值。 垃圾收集后有可能会造成大量的内存碎片 标记压缩将没有标记的垃圾对象不断压缩 优点：能够有效的缓解标记清除算法回收对象造成的内存碎片问题 缺陷：它引入了额外的开销，比如说额外的空间来保存迁移地址，需要遍历多次堆内存等 复制收集将从根开始被引用的对象复制到另外的空间中，然后再将复制的对象所能够引用的对象用递归的方式不断复制下去。如果旧空间里都是垃圾对象，能一次性回收该旧空间 优点：和标记压缩相比，它不需要遍历堆内存那么多次，节约了时间缺陷：可用堆内存减少了一半 引用计数方式在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减一般发生在变量赋值，对象内容更新，函数结束（局部变量不再被引用）等时间点。当一个对象引用计数为0时，则说明它将来不会再被应用。 优点： 对象不再被引用的瞬间就会被释放 释放操作是针对每个对象个别执行，GC产生的中段时间比较短 缺点： 无法释放循环引用的对象 必须在引用发生增减时对引用计数作出正确的增减，如果漏掉了某个增减，就会引发很难找到原因的内存错误。 引用计数管理不适合并行处理 分代回收（Generational GC）对分配不久，诞生时间较短的年轻对象进行重点扫描，可以更有效地回收大部分垃圾。对所有涉及修改对象内容的地方进行保护，称为写屏障。 刚刚生成不久的年轻对象划为新生代，存活时间较长的对象划为老生代。 全部区域对象GC操作称为完全回收；只扫描新生代对象的回收操作，称为小回收（Minor GC）；将从老生代对新生代的引用记录在一个叫做记录集的表中，在执行小回收的过程中，这个记录集也作为根对待。 缺点： 最大中断时间没有得到改善 增量回收对实时性要求很高的程序中，比起缩短GC的平均中断时间，往往更看重GC的最大中断时间。GC操作细分成多个逐一执行。 写屏障：已经完成扫描和标记的对象被修改，对新的对象产生了引用，这个新对象就不会被标记，明明存活的对象却被回收掉。 并行回收原有的程序运行的同时进行GC操作，用写屏障对当前的状态信息保持更新。不过，让GC操作完全并行，而一点都不影响原有程序的运行，是做不到的，在GC操作的某些特定阶段，仍然需要暂停原有程序运行 任何一种GC算法，都是跟踪和引用计数回收两种思路的组合。 为什么需要引入异常处理 C语言，if-else方式，通过返回整数，实现繁琐 有多处同样的错误，则要重复实现 闭包函数对象：将函数作为值来利用的方法 闭包：在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。被封闭起来的变量的生命周期与封闭它的函数对象生命周期相同 对象是在数据中以方法的形式内含了过程，而闭包则是在过程中以环境的形式内含了数据 动态与静态改善JavaScript性能的技术： JIT（Just In Time） 特殊化；对高频的特殊条件下，运行高速版本的代码 JavaScript是目前最快的动态语言 无论任何程序，或多或少都包含了动态的特性。 动态的编程语言，动态部分主要指运行模式和类型；动态运行模式就是运行中的程序能够识别自身，并对自身进行操作。动态类型有且只有数据拥有类型，静态类型是数据拥有类型，存放数据的变量，表达式也拥有类型，且类型在编译时固定。 动态类型优点： 1.简洁；即少了类型描述的代码和减少与算法本质无关的代码分量2.灵活性高；少了类型带来的制约 静态类型优点： 1.程序中对类型的描述，可以帮助对程序的阅读和理解 2.编译时确定类型，比较容易发现bug，对于这一点，程序中的bug大多数其实是与逻辑有关的，单纯类型错误而导致的bug是少数的。 Duck TypingIf it walks like a duck and quacks like a duck, it must be a duck. 隆重推出鸭子类型，如果某个对象的行为和鸭子一模一样，那无论它真正的实体是什么，我们都可以将它看做一只鸭子。不考虑某个对象到底是哪一个类的实例，只关心其拥有怎样的行为。 小结松本行弘的代码的未来一书还有其他有趣的内容，我想每个程序员都需要知道未来编程是什么样子，知道如今的编程语言正在朝哪些什么方向发展，Go，Lua，Dart这些语言有哪些设计差异。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊安卓App里的搜索]]></title>
    <url>%2F2017%2F03%2F26%2F2017%2F2017-03-26%2F</url>
    <content type="text"><![CDATA[安卓App里，搜索是一个常用功能，是开发中高频需求。借着在公司技术分享的契机，我们一起聊聊那些年我们开发过的搜索栏。 本文分为两大部分：1. 搜索栏的产品逻辑 2. 搜索交互的代码实现。（如果对搜索栏产品逻辑不感兴趣，可以直接跳到第二部分阅读） 安卓App里，搜索是一个常用功能，是开发中高频需求。借着在公司技术分享的契机，我们一起聊聊那些年我们开发过的搜索栏。 本文分为两大部分：1. 搜索栏的产品逻辑 2. 搜索交互的代码实现。（如果对搜索栏产品逻辑不感兴趣，可以直接跳到第二部分阅读） 产品经理篇没有系统的论述搜索栏的交互体系和生命周期，而是尝试通过回答以下三个问题来表达我对搜索栏的理解 什么时候需要搜索栏对于用户来说，用户喜欢点击、长按、滑动、拖拽，而不喜欢输入；搜索需要用户打字输入。另一方面，并不是任何阶段的App都需要搜索栏 当列表不够用时搜索是为了提供用户快速获得他们最想要的数据内容，当总的数据量很少时，直接列表展示所有数据即可。 比如一款旅行类的App，提供各个城市的景点，美食，商城的攻略和介绍。最初，这家初创的互联网公司只提供国内城市， 用户想要查看的各个城市的景点，直接通过滑动城市列表找寻 如果列表展示不够了，考虑在App里增加搜索栏。 当一种元素分类不够用时随着这家旅游公司的成长，它能提供的国内城市由最初的十个不到，增多到的几十个，列表展示这几十个城市已经不合适了，这时候需要对城市进行分类。比如按城市名首字的字母表排序分类，比如按城市所在区域分类。通过分类，每个类别下只有若干个城市名，用户就能快速找到想要的数据。 如果一种分类展示不够用了，考虑在App里增加搜索栏 多种维度分类不够用时这家旅游公司发展迅速，不仅能提供国内的城市，还提供国外城市，比如美国，欧洲等旅游城市，城市名增加到了上千个，这时候需要从之前的一种分类变成多种维度分类。按区域划分变成按五大洲分类，每个州按国家二级分类，每个国家按城市首字字母表三级分类。 如果多级分类不够用了，考虑在App里增加搜索栏 用户搜索时都在想什么搜索速度用户输入关键词查询，能接受的等待时间是有一个范围的，当超过这个范围，用户就会明显感受到等待，这个时间大体为一秒。另一方面，在搜索的时候吸引用户注意力能让用户的时间感知降低，比如引入加载的动画，立刻展示预置的通用图案和内容等 查看关心的信息用户之所以搜索，就是想找到自己想要的搜索内容。这个搜索结果的构成，可以根据App的特性和下一个交互流程来决定。 还是以上文提到的旅游App为例，用户搜索城市，想要知道这个城市好玩的景点，好吃的美食，搜索的结果就需要体现这个城市的景点和美食。这家旅行App的的盈利方式之一是提供车票预订服务，那么搜索结果可以提供跳转到去往该城市的机票或火车票的下单页面。 搜索结束，用户接下来要做什么一旦搜索结束，就意味着下一个交互流程的开始。给用户什么新的交互流程，根据两个方面吧： 延续搜索交互分析App运营数据，分析用户高频的行为，用户搜索的心理活动，对于搜索结果，用户希望获得什么内容。通常是支持用户点击进入详情。比如城市名搜索完，点击进入城市详情页，详细展示该城市的景点和美食 提供新的流程这部分需要结合App的产品定位和业务需求。 依然拿上文那家旅游公司为例，该公司后期提供了车票下单服务，提供用户和当地城市导游一对一聊天提问的服务。在App里，底栏Tab有四个：“城市”，“车票”，“聊天”，“我的” 这时候搜索到的城市结果展示，就需要提供点击跳转到该城市的车票下单页面，以及点击进入和当地导游聊天的页面 参考资料 搜索产品功能浅谈 设计搜索栏，你遵守这五条原则了吗？ 程序员篇有了搜索栏产品经理篇所述的认识，开发搜索栏的意义和方向和产品经理感同身受，对UI交互要求有了共鸣 Gmail搜索交互效果 上面是谷歌邮箱App搜索的交互效果，如何实现这个UI效果？ 实现这个效果，有三个步骤 有两层标题栏，前层是一个toolbar，背后的自己写的布局 当点击前层搜索，让后层的布局显示，前层的布局不显示 实施搜索动画，让背后的布局淡入显示出来，返回时则是上述的逆过程 步骤一toolbar的使用有规范，自制的布局这里也不详诉了 步骤二如果两个布局，一个显示，一个隐藏，通常会想到setVisible()方法来控制，这里提供另一种思路:View对象里，有一个方法bringToFront()，能改变子View在父容器位置顺序，改变了位置，就能改变前景的显示了。API文档对bringToFront的介绍如下： bringToFront() Change the view&apos;s z order in the tree, so it&apos;s on top of other sibling views. 步骤三上图看到，点击搜索图标后，标题栏和状态栏从红色变成了白色，这里涉及到如何代码改变状态栏，淡入和后退键标题栏谈出用到了属性动画 核心代码如下： private void reactionToClickSearchAction() { View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); getWindow().setStatusBarColor(getResources().getColor(R.color.status_bar_gray)); } ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mLlSearchBar, &quot;alpha&quot;, 0, 1); objectAnimator.setDuration(300).setInterpolator(new FastOutSlowInInterpolator()); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); mIsShowSearch = true; mEdSearch.requestFocus(); KeyboardUtils.showSoftInput(mEdSearch, GMailMainActivity.this); } }); objectAnimator.start(); } @Override public void onBackPressed() { if (mIsShowSearch) { mEdSearch.clearFocus(); KeyboardUtils.hideSoftInput(mEdSearch, this); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(mLlSearchBar, &quot;alpha&quot;, 1, 0); objectAnimator.setDuration(200).setInterpolator(new FastOutSlowInInterpolator()); objectAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); } }); objectAnimator.start(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); getWindow().setStatusBarColor(getResources().getColor(R.color.colorPrimaryDark)); } mIsShowSearch = false; return; } super.onBackPressed(); } Google Play搜索交互效果 上面是Google Play子目录页搜索的交互效果，这个交互效果怎么实现呢？ 会发现它和Gmail的交互很像，不同的之处有两点： 点击搜索的动画不同，Google Play的动画不是淡入而是像水波纹一样展开的 状态栏颜色不改变 如何让一个布局水波纹似地展开呢？从API 21 android5.0 棒棒糖版本开始，安卓提供了一个方法ViewAnimationUtils.createCircularReveal() static Animator createCircularReveal(View view, int centerX, int centerY, float startRadius, float endRadius) Returns an Animator which can animate a clipping circle. 那么在5.0以下的版本怎么办，除了自己实现这种效果外，github上已经有人开源了ozodrukh/CircularReveal 核心代码如下： /** * 点击搜索 */ private void reactionToClickSearchAction() { mShowSearchToolbar = true; View childView = mRevealFrameLayout.getChildAt(0); childView.setVisibility(View.VISIBLE); childView.bringToFront(); int centerX = childView.getRight(); int centerY = childView.getBottom() / 2; Animator circularReveal = ViewAnimationUtils.createCircularReveal(childView, centerX, centerY, 0, childView.getWidth()); circularReveal.setDuration(300).setInterpolator(new LinearInterpolator()); circularReveal.start(); circularReveal.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); reactionToCover(true); mEdSearch.requestFocus(); KeyboardUtils.showSoftInput(mEdSearch, GplayMainActivity.this); } }); } private boolean reactionToBackPressed() { if (mShowSearchToolbar) { KeyboardUtils.hideSoftInput(mEdSearch, this); View childView = mRevealFrameLayout.getChildAt(0); childView.bringToFront(); int centerX = childView.getLeft(); int centerY = childView.getBottom() / 2; Animator circularReveal = ViewAnimationUtils.createCircularReveal(childView, centerX, centerY, 0, childView.getWidth()); circularReveal.setDuration(300).setInterpolator(new DecelerateInterpolator()); circularReveal.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); reactionToCover(false); } }); circularReveal.start(); mShowSearchToolbar = false; return true; } return false; } public void reactionToCover(boolean isDark){ if(isDark) { mFrameBodyCover.setVisibility(View.VISIBLE); }else{ mFrameBodyCover.setVisibility(View.GONE); } } 小结上述代码已提交到Github:SearchBarDemo，欢迎star。 参考资料 深入浅出搜索系列之（一）- 初识搜索&amp;version=11020201&amp;pass_ticket=yWwF3qj71PEzLDT%2F02c0%2FFTzD6F%2BT41pTSgxYv5QasYtOCUo42uJXEMTPrVjbiiz) Material Design中全新的动画 深入理解Android L新特性之 页面内容&amp;共享元素过渡动画 Github:ozodrukh/CircularReveal]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异类：一万小时练习的力量]]></title>
    <url>%2F2017%2F03%2F12%2F2017%2F2017-03-12%2F</url>
    <content type="text"><![CDATA[异类 一书由马尔科姆（Malcolm Gladwell）所著。它刷新了我对能力超群之人的认识。两周看完这本书，现做些读书摘抄，并分享下我的读后感异类 一书由马尔科姆（Malcolm Gladwell）所著。它刷新了我对能力超群之人的认识。两周看完这本书，现做些读书摘抄，并分享下我的读后感 积累成功是天赋加上后天努力，但是天赋的作用其实很小，而后天努力的作用其实很大。一个人在学习的过程中，要完美掌握某项复杂技能，就要一遍又一遍艰苦练习，而练习时长必须达到一个最小临界量：一万小时。任何一个领域的世界级水平都需要起码10000小时的训练。人的大脑必需花费那么长的时间消化理解，才能达到极其精通的水平。 练习并不是为了让你一次就能把事情做好，而是为了帮助你越做越好 一万小时的确很难依靠自己达到这一要求，小时候需要获得父母的鼓励与支持，依靠参加某些特定形式的训练课程，或者获得某些特定机遇得以进行训练。 我们如何到持续的练习呢？我的答案是，认识自己，找到自己想要的生活方式和节奏，找寻自己的特质和兴奋点，做什么能带给你快乐，什么事是别人不逼你，你也愿意甚至兴高采烈地做着，一旦开始了，慢慢地你变得擅长做这件事，你发现你比别人做得更好，有了快感，有了正想的情感体验，你会继续做这件事，进入良性循环。 机遇除了能力，机遇和其他完全随机的优势也在帮助特定领域的异类走向成功之巅。异类是那些获得特殊机遇之人，是那些耐心等待，当机遇到来就当仁不让把握住机遇的人们。 机遇并非偶然而是存在规律，马尔科姆在书里就详细分析了冰球运动员，甲壳虫乐队，比尔盖茨，比尔乔伊，弗洛姆，律师行的创始人，这些异类们的机遇规律。 对于加拿大的冰球运动员来说，生于1月就是他们进入全明星队的机遇；对于甲壳虫乐队，汉堡之旅就是机遇；对于比尔盖茨，特殊机遇就是生于正确的年代，并在初中时代就获得电脑终端；对于弗洛姆和我切尔.利普顿.罗森.卡茨律师行的创始人,机遇是多重的，他们生于正确的年代，有着能给他们最勤勉激励的父母，他们拥有少数族裔身份，这种身份帮助他们在纽约其它传统律师事务所拥有少数族裔身份，这种身份帮助他们在纽约其它传统事务所涉足公司并购官司以前，就已在这个领域事件了20年。 个性作用并非个人成功的决定因素。成功人士并非白手起家，他们以某种形式获得家族的隐蔽和支持，看似完全依靠个人奋斗，其实不是。他们一直得益于某些隐蔽的先天优势，或非凡的机缘，抑或某一个文化的特殊优势；这使得他们学得快，干得多，以普通人难以企及的方式认知世界。出生的时代与地域对个体的影响巨大。而我们所处的文化背景，以及我们的祖先留传下来的东西，在我们无意识的情况下，就已限定了我们获得成功的方式。 任何意义上的超常之辈，都是历史与环境的产物，是机遇与积累的结晶。 机遇和积累的关系上述机遇有着什么样的共同点？这些机遇都给了“异类”们更多的练习时间，直至达到一万小时。有句成语，时势造英雄，按照马尔科姆的逻辑，那便是因为局势给那些英雄们提供了成为英雄所需要的练习，当积累至少超过一万小时后，英雄出现了。 小结行走在完成一万小时的路上]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造安卓App丝滑的操作体验－－Fragment深入使用和封装之道]]></title>
    <url>%2F2017%2F03%2F10%2F2017%2F2017-03-10%2F</url>
    <content type="text"><![CDATA[想让App有丝滑般的切换速度和顺畅的体验么？那就放开Activity，使用Fragment来展示UI页面吧 Github futurice/android-best-practices上列举了一些列安卓开发最佳实践建议，其中对Fragment使用做了一些陈述（传送门），我表示赞同。 最近项目需要新增了一个功能模块，我引入了一个Activity，多个fragment的方式来组织UI，这个过程有了一些收获。 简介想让App有丝滑般的切换速度和顺畅的体验么？那就放开Activity，使用Fragment来展示UI页面吧 Github futurice/android-best-practices上列举了一些列安卓开发最佳实践建议，其中对Fragment使用做了一些陈述（传送门），我表示赞同。 最近项目需要新增了一个功能模块，我引入了一个Activity，多个fragment的方式来组织UI，这个过程有了一些收获。 对fragment的操作，我使用support v4包下的，FragmentManager和FragmentTransaction这两个类。 正文如何启动一个Fragmentreplace方式这里我没有用Activity下的getSupportFragmentManager得到了FragmentManager来替换Fragment，而是选择使用fragment下的getChildFragmentManager（）获取FragmentManager。 放在基类BasicActivity里， /** * 替换当前Fragment里的某个FrameLayout布局 * @param resId 被替换的布局ID * @param fragmentTab 新的Fragment名 * @param arguments 传入新的Fragment的Bundle * @param isAddToBack 是否加入回退栈 */ private void replaceOneFragment(@IdRes int resId, String fragmentTab, Bundle arguments, boolean isAddToBack) { int childrenFragmentContainerResID = ((BasicFragment) mCurrentFragment).getChildrenFragmentContainerResID(); int layoutId = resId &lt;= 0 ? childrenFragmentContainerResID : resId; if (layoutId == -1) { throw new IllegalStateException(&quot;You should overwrite getChildrenFragmentContainerResID from BasicFragment&quot;); } FragmentManager manager = mCurrentFragment.getChildFragmentManager(); if (manager != null) { FragmentTransaction transaction = manager.beginTransaction(); transaction .setCustomAnimations(R.anim.right_enter, R.anim.left_exit, R.anim.left_enter, R.anim.right_exit) .replace(layoutId, fragmentProvider(fragmentTab, arguments), fragmentTab); if (isAddToBack) { transaction.addToBackStack(fragmentTab); } transaction.commitAllowingStateLoss(); } } 说明： getChildrenFragmentContainerResID(),该方法在BasicFragment里，用来获取要替换的布局ID BasicActivity里，fragmentProvider()，Fragment提供者 add/show/hide显示Fragment（支持SingleTask启动Fragment） /** * 显示特定Tag的Fragment,如果是第一次显示,则新建并添加该Fragment * * @param fragmentTab Fragment标签名 * @param arguments 传入Fragment的参数 * @param isAddBackStack 是否加入FragmentManager回退栈 * @param launchMode 启动模式 分为： STANDARD，SINGLE，SINGLE_ENHANCEMENT */ private void showOneFragment(String fragmentTab, Bundle arguments, boolean isAddBackStack, LaunchMode launchMode) { FragmentManager manager = getSupportFragmentManager(); if (manager == null) { return; } Fragment fragmentByTag = manager.findFragmentByTag(fragmentTab); if (fragmentByTag != null &amp;&amp; launchMode == LaunchMode.SINGLE_ENHANCEMENT) { popMultipleBackStack(fragmentTab, arguments); return; } FragmentTransaction transaction = manager.beginTransaction(); //设置过渡动画 transaction.setCustomAnimations(R.anim.right_enter, R.anim.left_exit, 0, 0); //隐藏当前所有fragment List&lt;Fragment&gt; fragments = manager.getFragments(); if (fragments != null &amp;&amp; fragments.size() &gt; 0) { for (Fragment f : fragments) { if (f != null) { transaction.hide(f); } } } //第一次添加该Fragment if (fragmentByTag == null) { mCurrentFragment = fragmentProvider(fragmentTab, arguments); mFragmentBackDeque.push(fragmentTab); transaction.add(getFragmentContainerResID(), mCurrentFragment, fragmentTab); if (isAddBackStack) { transaction.addToBackStack(fragmentTab); } transaction.commitAllowingStateLoss(); return; } if (!(fragmentByTag instanceof BasicFragment)) { throw new ClassCastException(&quot;fragment must extends BasicFragment&quot;); } //更新Arguments，按后退键时Fragment里的后退方法里使用 if (arguments != null) { setSupportBackStackArguments(arguments); } //根据启动模式类型，采取不同的方式维护后退栈 switch (launchMode) { case STANDARD: mFragmentBackDeque.push(fragmentTab); break; case SINGLE: synchronizeFragmentBackDequeWhenSingleLaunchMode(fragmentTab); break; } BasicFragment basicFragment = (BasicFragment) fragmentByTag; mCurrentFragment = fragmentByTag; basicFragment.setSupportArguments(arguments); transaction.show(fragmentByTag); transaction.commitAllowingStateLoss(); } /** * fragment 启动模式 */ public enum LaunchMode { /** * 标准模式 */ STANDARD, /** * 单例模式，其他Fragment从自维护的mFragmentBackDeque栈里退出 */ SINGLE, /** * 强化版单例模式，其他Fragment从FragmentManager栈和自维护的mFragmentBackDeque栈里退出 */ SINGLE_ENHANCEMENT, } 说明： popMultipleBackStack（）实现一次弹出多个Fragment 在隐藏当前所有fragment操作，特别需要在遍历时，做个非空判断， for (Fragment f : fragments) { if (f != null) { transaction.hide(f); } } 这样做，是因为Fragment出栈后，会出现栈内顺序不正确的bug，详看Fragment全解析系列（一）：那些年踩过的坑，一文中关于多个Fragment同时出栈的深坑BUG这一部分的内容。 synchronizeFragmentBackDequeWhenSingleLaunchMode（）单例模式下，管理自维护的Fragment后退栈 mFragmentBackDeque是自维护回退管理队列 后退键监听管理使用Fragment组织UI后，返回上一个页面的逻辑有了变化。如果遇到之前replace替换了，则先从该fragment的FragmentManager里恢复原来的被替换的fragment，没有，则把之前hide状态的Fragment重新show显示出来，这个过程需要用了队列自己来维护回退 @Override public void onBackPressed() { if (mFragmentBackDeque == null || mCurrentFragment == null) { return; } //检查当前Fragment的ChildFragmentManager回退栈是否需要回退 int childStackEntryCount = mCurrentFragment.getChildFragmentManager().getBackStackEntryCount(); if (childStackEntryCount &gt; 0) { mCurrentFragment.getChildFragmentManager().popBackStackImmediate(); return; } //检查当前Fragment的自维护的回退栈是否需要回退 if (mFragmentBackDeque.size() &gt;= 2) { showOneFragmentOnBackPressed(); return; } finish(); } showOneFragmentOnBackPressed()实现返回键显示特定Tag的Fragment 同时，如果需要，我们可以给FragmentManager添加OnBackStackChangedListener，监听FragmentManager回退栈成员数量的变化，具体使用见文末的代码 还有一种思路，View提供了setOnKeyListener（OnKeyListener onKeyListener），用OnKeyListener来监听后退健。 Fragment入参管理第一次启动Fragment，走的是fragment生命周期方法，之后启动fragment从hide状态重新show时，不走Fragment生命周期方法，而是调用onHiddenChanged(boolean hidden)方法。因此，在这两种场景下支持给fragment传入参数，并且做到每次显示fragment，都能拿到最新的入参bundle。 我在BasicFragment设计如下： /** * Fragment Argument解析 * @param arguments */ protected void parseArguments(Bundle arguments){ } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); parseArguments(getArguments()); } @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if(!hidden){ parseArguments(getSupportArguments()); } } 这样，新的Fragmnet在继承BasicFragment时，只需要重新parseArguments（）即可 Toolbar管理项目中使用Toolbar，用BasicFragmentWithToolbar来负责Toolbar的设置逻辑 BasicFragmentWithToolbar类里的核心代码 @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if (!hidden) { configureToolbar(); } } @Override protected void configureToolbar() { super.configureToolbar(); int stackEntryCount = getChildFragmentManager().getBackStackEntryCount(); if (stackEntryCount &gt; 0) { FragmentManager.BackStackEntry stackEntry = getChildFragmentManager().getBackStackEntryAt(stackEntryCount - 1); //Get the name that was supplied to FragmentTransaction.addToBackStack(String) when creating this entry String fragmentTab = stackEntry.getName(); BasicFragmentWithToolbar fragmentByTag = (BasicFragmentWithToolbar) getChildFragmentManager().findFragmentByTag(fragmentTab); if (fragmentByTag != null) { fragmentByTag.setupToolbar(); } } else { setupToolbar(); } } /** * 设置Toolbar的显示内容 */ protected void setupToolbar() { mToolbar.setNavigationIcon(R.drawable.icon_header_left); mToolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getAttachActivity().onBackPressed(); } }); } 如何使用上述的Fragment封装我举个例子，我建一个BillContainerActivity，来作为Bill相关的Fragment容器，代码如下 public class BillContainerActivity extends BasicActivity { private static final String TAG = &quot;BillContainerActivity&quot;; @Bind(R.id.frame_activity_order_body) FrameLayout mOrderBody; public static Intent getCallingIntent(Activity activity){ Intent intent = new Intent(activity,BillContainerActivity.class); return intent; } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); initializeShow(); } private void initializeShow() { showOneFragment(BillHomeFragment.class.getSimpleName(),true); } @Override protected BasicFragment fragmentProvider(String fragmentTab, Bundle arguments) { BasicFragment currentFragment; if(BillHomeFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillHomeFragment.newInstance(); } else if(BillProcessFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillProcessFragment.newInstance(arguments); } else if(BillStructureFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BillStructureFragment.newInstance(arguments); } else if(AdjustBillDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = AdjustBillDetailFragment.newInstance(arguments); } else if(BrokerageDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = BrokerageDetailFragment.newInstance(arguments); } else if(InvoiceDetailFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = InvoiceDetailFragment.newInstance(arguments); } else if(InvoiceListFragment.class.getSimpleName().equals(fragmentTab)){ currentFragment = InvoiceListFragment.newInstance(arguments); } else{ currentFragment = BillHomeFragment.newInstance(); } return currentFragment; } @Override protected int getFragmentContainerResID() { return R.id.frame_activity_order_body; } @Override protected int getLayoutResID() { return R.layout.activity_bill_home; } } 说明: 会发现作为Fragment容器的BillContainerActivity，代码量很少，主要做两件事 初始化显示Fragment 实现fragmentProvider方法，该方法把这个容器所需的Fragment构造出来 小结完整封装Fragment的代码随着项目需求在进化和改动，还是决定放到Github上完整代码传送门，欢迎star 相关阅读资料特别鸣谢：YoKey系列 Fragment全解析系列（一）：那些年踩过的坑 Fragment全解析系列（二）：正确的使用姿势 Fragment之我的解决方案：Fragmentation Android开发之Fragment最佳实践 What the Fragment?-Google I/O 2016(需自备梯子) 知乎：关于 Android，用多个 activity，还是单 activity 配合 fragment？ Android multiple fragment transaction ordering]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓EditText－实现输入小数点后几位的逻辑演变]]></title>
    <url>%2F2017%2F02%2F26%2F2017%2F2017-02-26%2F</url>
    <content type="text"><![CDATA[简介在Android开发中，时不时需要用户输入一些数据，有输入就有格式上的要求。比如EditText输入金额时，通常要保留小数点后两位，这个如何实现呢？ 首先在布局文件里，通过android:inputType限定EditText输入的内容，numberDecimal表示只能输入带小数点的浮点格式 简介在Android开发中，时不时需要用户输入一些数据，有输入就有格式上的要求。比如EditText输入金额时，通常要保留小数点后两位，这个如何实现呢？ 首先在布局文件里，通过android:inputType限定EditText输入的内容，numberDecimal表示只能输入带小数点的浮点格式 &lt;EditText android:id=&quot;@+id/tiet_invoice_free_tax_amount&quot; style=&quot;@style/InvoiceDetailEditTextStyle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/item_invoice_detail_height&quot; android:hint=&quot;发票金额(¥)：&quot; android:inputType=&quot;numberDecimal&quot; /&gt; EditText inputType属性详解 传送门 方法一，普通实现给EditText添加TextChangedListener监听，重写onTextChanged方法，输入小数点后两位的逻辑 @Override public void onTextChanged(CharSequence s, int start, int before, int count) { if (s.toString().contains(&quot;.&quot;)) { if (s.length() - 1 - s.toString().indexOf(&quot;.&quot;) &gt; 2) { s = s.toString().subSequence(0, s.toString().indexOf(&quot;.&quot;) + 3); editText.setText(s); editText.setSelection(s.length()); } } if (s.toString().trim().substring(0).equals(&quot;.&quot;)) { s = &quot;0&quot; + s; editText.setText(s); editText.setSelection(2); } if (s.toString().startsWith(&quot;0&quot;) &amp;&amp; s.toString().trim().length() &gt; 1) { if (!s.toString().substring(1, 2).equals(&quot;.&quot;)) { editText.setText(s.subSequence(0, 1)); editText.setSelection(1); return; } } } 这种方法实现复杂，有没有更简单的？ 方法二，简洁实现在重写onTextChanged方法里，一旦输入的内容里包含了“.”，则限定输入的文本长度为小数点所在长度加上后两位的长度。把问题转为如何限定EditText输入的内容长度呢？EditText提供了setFilter()方法，InputFilter.LengthFilter类，实现代码如下： private static final int DEFAULT_MAX_INTEGER_LENGTH = 10; private static final int DEFAULT_DECIMAL_NUMBER = 2; private static final InputFilter[] INPUT_FILTER_ARRAY = new InputFilter[1]; /** * 保留小数点后多少位 */ private int mDecimalNumber = DEFAULT_DECIMAL_NUMBER; /** * 允许最大的整数多少位 */ private int mMaxIntegralLength = DEFAULT_MAX_INTEGER_LENGTH; @Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) { super.onTextChanged(text, start, lengthBefore, lengthAfter); if(text.length() &gt; 0) { String inputContent = text.toString(); if (inputContent.contains(&quot;.&quot;)) { int maxLength = inputContent.indexOf(&quot;.&quot;) + mDecimalNumber + 1; INPUT_FILTER_ARRAY[0] = new InputFilter.LengthFilter(maxLength); } else { INPUT_FILTER_ARRAY[0] = new InputFilter.LengthFilter(mMaxIntegralLength); } setFilters(INPUT_FILTER_ARRAY); } } 与方法一相比，方法二执行效率得到了提高，不必截取字符串长度subString，同时逻辑上也简化了 方法三，优雅实现查阅InputFilter,对该类的描述： InputFilters can be attached to Editables to constrain the changes that can be made to them InputFilter能过滤EditText的输入内容，如此就不必监听OnTextChangeListener，而是设置过滤器的过滤逻辑，优雅得实现显示小数点后几位，核心代码如下： setFilters(new InputFilter[]{new InputFilter() { @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String lastInputContent = dest.toString(); if (lastInputContent.contains(&quot;.&quot;)) { int index = lastInputContent.indexOf(&quot;.&quot;); if(dend - index &gt;= mDecimalNumber + 1){ return &quot;&quot;; } } return null; } }}); filter方法用到的入参说明： source 单次输入的字符内容 dest上次输入的内容 到此，一个输入小数点后几位的自定义控件雏形已经显现了。 二 简单的自定义控件DecimalEditText，实现输入小数点后若干位所有代码如下： public class DecimalEditText extends EditText { private static final int DEFAULT_DECIMAL_NUMBER = 2; /** * 保留小数点后多少位 */ private int mDecimalNumber = DEFAULT_DECIMAL_NUMBER; public DecimalEditText(Context context) { this(context,null,R.attr.editTextStyle); } public DecimalEditText(Context context, AttributeSet attrs) { this(context,attrs, R.attr.editTextStyle); } public DecimalEditText(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DecimalEditText); mDecimalNumber = typedArray.getInt(R.styleable.DecimalEditText_decimalNumber,DEFAULT_DECIMAL_NUMBER); typedArray.recycle(); init(); } private void init(){ setFilters(new InputFilter[]{new InputFilter() { @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String lastInputContent = dest.toString(); if (source.equals(&quot;.&quot;) &amp;&amp; lastInputContent.length() == 0) { return &quot;0.&quot;; } if (lastInputContent.contains(&quot;.&quot;)) { int index = lastInputContent.indexOf(&quot;.&quot;); if(dend - index &gt;= mDecimalNumber + 1){ return &quot;&quot;; } } return null; } }}); } public int getDecimalNumber() { return mDecimalNumber; } public void setDecimalNumber(int decimalNumber) { mDecimalNumber = decimalNumber; } } attr文件 &lt;declare-styleable name=&quot;DecimalEditText&quot;&gt; &lt;attr name=&quot;decimalNumber&quot; format=&quot;integer&quot;/&gt; &lt;/declare-styleable&gt; 小结方法一的实现思路和网络上搜到的实现差不多，从方法一到方法三，是一个解决问题的逻辑演变的过程。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是时候自己来造个轮子了－－增强型RecyclerView]]></title>
    <url>%2F2017%2F01%2F23%2F2017%2F2017-01-23%2F</url>
    <content type="text"><![CDATA[该增强型RecyclerView，增加了以下特性： 上拉滑动到底部，加载更多 支持添加Header头视图 支持加载数据为空时，显示特定视图 支持拖拽，侧滑删除 下拉刷新实现通过给RecyclerView包一层SwipRefreshLayout来实现。 简述该增强型RecyclerView，增加了以下特性： 上拉滑动到底部，加载更多 支持添加Header头视图 支持加载数据为空时，显示特定视图 支持拖拽，侧滑删除 下拉刷新实现通过给RecyclerView包一层SwipRefreshLayout来实现。 本文重点分享上拉加载更多的实现，同时实现添加头部视图，侧滑，拖拽功能实现，该实现存在以下注意点： 如何判断RecyclerView滑动到了底部 通常RecyclerView显示的item布局相同，怎么做到上拉加载更多时出现一个底栏视图 滑动到底栏出现加载更多动画，这个动画什么时候结束？动画生命周期是？ ReclcerViewyou多种布局，如果是网格布局（有多列），怎么做到让上拉加载更多的动画视图和头部视图占用一整行？ 自定义了RecyclerView，如何做到像使用标准RecyclerView那样使用？ 如何实现item的拖拽和侧滑删除？ 实现的注意点解析如何判断RecyclerView滑动到了底部关于布局的逻辑设置，就找LayoutManager。的确，通过查阅官方API手册，有findLastVisibleItemPosition()/findLastCompletelyVisibleItePosition()，在滑动监听里，使用这两个方法就能实现判断 怎么做到上拉加载更多时出现一个底栏视图这里涉及到RecyclerView如何实现多布局显示的知识，通过getItemViewType()，底部上拉加载更多视图设定一种ItemViewType值，对应新建一个ViewHolder. 滑动到底栏出现加载更多动画这个动画什么时候结束？动画生命周期是？ 动画的开始时刻是列表滑倒底部，当滑倒底部时，在客户类（Fragment／Activity）里接口回调，开始网络请求数据，动画的结束时刻是网络加载完成，刷新列表时 ReclcerViewyou多种布局，如果是网格布局（有多列），怎么做到让上拉加载更多的动画视图和头部视图占用一整行？ 和布局相关的，找LayoutManager，这里要找GridLayoutManager，它提供了setSpanSizeLookup（GridLayoutManager.SpanSizeLookup），通过这个方法，可以根据位置来设置item占用一整行还是正常显示 自定义了RecyclerView，如何做到像使用标准RecyclerView那样使用？使用装饰器设计模式，能很好的实现对用户透明使用效果 如何实现item的拖拽和侧滑删除？使用android提供的ItemTouchHelper工具类，能快速的实现 核心代码EnhanceRecyclerViewpublic class EnhanceRecyclerView extends RecyclerView { private static final String TAG = &quot;EnhanceRecyclerView&quot;; private OnLoadMoreListener mOnLoadMoreListener; private InternalAdapter mInternalAdapter; private View mEmptyView; private @LayoutRes int mHeaderResId; private AdapterDataObserver mAdapterDataObserver = new EnhanceAdapterDataObserver(); /** * 滚动方向 */ private int mScrollDy = 0; public EnhanceRecyclerView(Context context) { super(context); } public EnhanceRecyclerView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public EnhanceRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } @Override public void onScrolled(int dx, int dy) { super.onScrolled(dx, dy); mScrollDy = dy; } @Override public void onScrollStateChanged(int state) { super.onScrollStateChanged(state); switch (state) { case SCROLL_STATE_IDLE: LayoutManager layoutManager = getLayoutManager(); int itemCount = getAdapter().getItemCount(); int lastVisibleItemPosition = 0; if (layoutManager instanceof GridLayoutManager) { GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager; lastVisibleItemPosition = gridLayoutManager.findLastVisibleItemPosition(); } else if (layoutManager instanceof LinearLayoutManager) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager) layoutManager; lastVisibleItemPosition = linearLayoutManager.findLastVisibleItemPosition(); } if (lastVisibleItemPosition &gt;= itemCount - 1) { if (getParent() instanceof SwipeRefreshLayout) { SwipeRefreshLayout swipeRefreshLayout = (SwipeRefreshLayout) getParent(); if (swipeRefreshLayout.isRefreshing()) { break; } } if (mOnLoadMoreListener != null &amp;&amp; mScrollDy &gt; 0) { mInternalAdapter.setLoadingIndicatorViewVisible(VISIBLE); mOnLoadMoreListener.onLoadMore(); } } break; } } /** * 重写此方法，设置GridLayout的上拉加载更多视图的位置 * * @param layout */ @Override public void setLayoutManager(LayoutManager layout) { if (layout instanceof GridLayoutManager) { final GridLayoutManager externalGridLayoutManager = (GridLayoutManager) layout; final int spanCount = externalGridLayoutManager.getSpanCount(); int orientation = externalGridLayoutManager.getOrientation(); final GridLayoutManager innerGridLayoutManager = new GridLayoutManager(getContext(), spanCount, orientation, false); innerGridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { int headerViewCount = mInternalAdapter.getHeaderViewCount(); int footViewCount = mInternalAdapter.getFootViewCount(); if (position &lt; headerViewCount) { return spanCount; } int totalItemCount = innerGridLayoutManager.getItemCount(); if (position &gt;= totalItemCount - footViewCount) { return spanCount; } return externalGridLayoutManager.getSpanSizeLookup().getSpanSize(position - headerViewCount); } }); super.setLayoutManager(innerGridLayoutManager); } else { super.setLayoutManager(layout); } } public View getEmptyView() { return mEmptyView; } public final void setEmptyView(View emptyView) { mEmptyView = emptyView; setupEmptyViewHierarchy(emptyView); } protected void setupEmptyViewHierarchy(View emptyView) { ((ViewGroup) getParent().getParent()).addView(emptyView,0); } public void addHeaderResId(@LayoutRes int resId) { mHeaderResId = resId; if (mInternalAdapter != null) { mInternalAdapter.setExternalHeaderResId(resId); } } @Override public void setAdapter(Adapter adapter) { mInternalAdapter = new InternalAdapter(adapter); super.setAdapter(mInternalAdapter); //addHeaderView方法依赖于setAdapter方法 if (mHeaderResId &gt; 0) { addHeaderResId(mHeaderResId); } mInternalAdapter.registerAdapterDataObserver(mAdapterDataObserver); mAdapterDataObserver.onChanged(); } public void setOnLoadMoreListener(OnLoadMoreListener onLoadMoreListener) { mOnLoadMoreListener = onLoadMoreListener; } public void loadMoreOnSuccess() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnSuccess(); } } public void loadMoreOnError() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnError(); } } public void loadMoreOnComplete() { if (mInternalAdapter != null) { mInternalAdapter.loadMoreOnComplete(); } } public final void notifyDataSetChanged() { mInternalAdapter.notifyDataSetChanged(); } public final void notifyItemChanged(int position) { mInternalAdapter.notifyItemChanged(position); } public final void notifyItemChanged(int position, Object payload) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemChanged(position, payload); } public final void notifyItemRangeChanged(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeChanged(positionStart, itemCount); } public final void notifyItemRangeChanged(int positionStart, int itemCount, Object payload) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeChanged(positionStart, itemCount, payload); } public final void notifyItemInserted(int position) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemInserted(position); } public final void notifyItemMoved(int fromPosition, int toPosition) { fromPosition = fromPosition + mInternalAdapter.getHeaderViewCount(); toPosition = toPosition + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemMoved(fromPosition, toPosition); } public final void notifyItemRangeInserted(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeInserted(positionStart, itemCount); } public final void notifyItemRemoved(int position) { position = position + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRemoved(position); } public final void notifyItemRangeRemoved(int positionStart, int itemCount) { positionStart = positionStart + mInternalAdapter.getHeaderViewCount(); mInternalAdapter.notifyItemRangeRemoved(positionStart, itemCount); } public InternalAdapter getInternalAdapter() { return mInternalAdapter; } /** * 上拉加载更多回调 */ public interface OnLoadMoreListener { void onLoadMore(); } private class EnhanceAdapterDataObserver extends AdapterDataObserver { @Override public void onChanged() { super.onChanged(); if (getEmptyView() != null &amp;&amp; getAdapter() != null) { int itemCount = getAdapter().getItemCount(); if (itemCount == 0) { getEmptyView().setVisibility(VISIBLE); setVisibility(GONE); } else { getEmptyView().setVisibility(GONE); setVisibility(VISIBLE); } } } @Override public void onItemRangeChanged(int positionStart, int itemCount) { super.onItemRangeChanged(positionStart, itemCount); onChanged(); } @Override public void onItemRangeChanged(int positionStart, int itemCount, Object payload) { super.onItemRangeChanged(positionStart, itemCount, payload); onChanged(); } @Override public void onItemRangeInserted(int positionStart, int itemCount) { super.onItemRangeInserted(positionStart, itemCount); onChanged(); } @Override public void onItemRangeRemoved(int positionStart, int itemCount) { super.onItemRangeRemoved(positionStart, itemCount); onChanged(); } @Override public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) { super.onItemRangeMoved(fromPosition, toPosition, itemCount); onChanged(); } } } InternalAdapterpublic class InternalAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final String TAG = &quot;InternalAdapter&quot;; private static final int HEADER_ITEM_TYPE = 170118; private static final int FOOTER_ITEM_TYPE = 170116; private RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; mExternalAdapter; private int mBodyItemCount; private FooterView mFooterView; private @LayoutRes int mExternalHeaderResId; public InternalAdapter(RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; externalAdapter) { mExternalAdapter = externalAdapter; mBodyItemCount = externalAdapter.getItemCount(); } @Override public int getItemViewType(int position) { if(isHeaderView(position)){ return HEADER_ITEM_TYPE; } else if (isFootView(position)) { return FOOTER_ITEM_TYPE; } return mExternalAdapter.getItemViewType(position); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { switch (viewType) { case HEADER_ITEM_TYPE: View headerView = LayoutInflater.from(parent.getContext()).inflate(mExternalHeaderResId, parent, false); return new HeaderView(headerView); case FOOTER_ITEM_TYPE: View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_footer_indicator, parent, false); mFooterView = new FooterView(view); return mFooterView; default: return mExternalAdapter.onCreateViewHolder(parent, viewType); } } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if(isHeaderView(position)){ return; } if (isFootView(position)) { return; } if(mExternalHeaderResId &gt; 0){ position = position - getHeaderViewCount(); } mExternalAdapter.onBindViewHolder(holder, position); } @Override public int getItemCount() { mBodyItemCount = mExternalAdapter.getItemCount(); if(mBodyItemCount == 0){ return 0; } else{ return getHeaderViewCount() + mBodyItemCount + getFootViewCount(); } } private boolean isHeaderView(int position){ return mExternalHeaderResId &gt; 0 &amp;&amp; position == 0; } private boolean isFootView(int position) { return (position &gt;= mBodyItemCount + getHeaderViewCount()); } public int getFootViewCount() { return 1; } public int getHeaderViewCount(){ return mExternalHeaderResId &gt; 0 ? 1 : 0; } public void setLoadingIndicatorViewVisible(int visible){ if(mFooterView != null){ mFooterView.setLoadingIndicatorViewVisible(visible); } } public void setExternalHeaderResId(int externalHeaderResId) { mExternalHeaderResId = externalHeaderResId; } public void loadMoreOnSuccess(){ setLoadingIndicatorViewVisible(View.GONE); } public void loadMoreOnError(){ setLoadingIndicatorViewVisible(View.GONE); } public void loadMoreOnComplete(){ setLoadingIndicatorViewVisible(View.GONE); } static class HeaderView extends RecyclerView.ViewHolder{ HeaderView(View itemView) { super(itemView); } } static class FooterView extends RecyclerView.ViewHolder { @Bind(R.id.item_footer_indicator) LoadingIndicatorView mLoadingIndicatorView; FooterView(View itemView) { super(itemView); ButterKnife.bind(this, itemView); mLoadingIndicatorView.setVisibility(View.GONE); } void setLoadingIndicatorViewVisible(int visible){ mLoadingIndicatorView.setVisibility(visible); } } } 底部FooterView的布局item_footer_indicator.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@android:color/transparent&quot; &gt; &lt;com.sugary.refreshrecyclerview.enhancerecycler.indicator.LoadingIndicatorView android:id=&quot;@+id/item_footer_indicator&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; app:indicator_color=&quot;@color/indicator_loading_more_orange&quot; /&gt; &lt;/RelativeLayout&gt; LoadingIndicatorViewpublic class LoadingIndicatorView extends View { //Sizes (with defaults in DP) public static final int DEFAULT_SIZE = 50; private Paint mPaint; private BaseIndicatorController mIndicatorController; private boolean mHasAnimation; public LoadingIndicatorView(Context context) { this(context, null); } public LoadingIndicatorView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public LoadingIndicatorView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(attrs); } private void init(AttributeSet attrs) { TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.LoadingIndicatorView); int indicatorColor = a.getColor(R.styleable.LoadingIndicatorView_indicator_color, Color.GRAY); a.recycle(); mPaint = new Paint(); mPaint.setColor(indicatorColor); mPaint.setStyle(Paint.Style.FILL); mPaint.setAntiAlias(true); mIndicatorController = new BallPulseIndicator(); mIndicatorController.setTarget(this); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int width = measureDimension(dp2px(DEFAULT_SIZE), widthMeasureSpec); int height = measureDimension(dp2px(DEFAULT_SIZE), heightMeasureSpec); setMeasuredDimension(width, height); } private int measureDimension(int defaultSize, int measureSpec) { int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) { result = specSize; } else if (specMode == MeasureSpec.AT_MOST) { result = Math.min(defaultSize, specSize); } else { result = defaultSize; } return result; } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); if (!mHasAnimation) { mHasAnimation = true; mIndicatorController.initAnimation(); } } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); drawIndicator(canvas); } void drawIndicator(Canvas canvas) { mIndicatorController.draw(canvas, mPaint); } private int dp2px(int dpValue) { return (int) getContext().getResources().getDisplayMetrics().density * dpValue; } @Override public void setVisibility(int v) { if (getVisibility() != v) { super.setVisibility(v); if (v == GONE || v == INVISIBLE) { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.END); } else { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.START); } } } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); if (mHasAnimation) { mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.START); } } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mIndicatorController.setAnimationStatus(BaseIndicatorController.AnimStatus.CANCEL); } } 小结：列表数据刷新，改成了调用EnhanceRecylerView方法，用自己建的Adapter刷新数据无效（这是这个轮子的缺陷，有待改进）。 底部滑动动画使用了他人的开源动画 在自制增强型RecyclerView过程中，也刷了一些资料，推荐阅读。 参考资料 RecyclerView必知必会（五星推荐） Github:RecyclerView优秀文集 Github:BeautifulRefreshLayout Github:BaseRecyclerViewAdapterHelper *Github:XRecyclerView]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对2016年的年度小结]]></title>
    <url>%2F2017%2F01%2F03%2F2017%2F2017-01-03%2F</url>
    <content type="text"><![CDATA[尽管这篇年度小结有点迟，但是却是非常必要的。 和去年相似，在写这篇小结之前，刚看完李笑来老师的书《把时间当作朋友》，书本里很多观点发人深省，醍醐灌顶，茅塞顿开。就我最后看的部分，做个简单的摘抄：尽管这篇年度小结有点迟，但是却是非常必要的。 和去年相似，在写这篇小结之前，刚看完李笑来老师的书《把时间当作朋友》，书本里很多观点发人深省，醍醐灌顶，茅塞顿开。就我最后看的部分，做个简单的摘抄： 从整体上看，人脉当然重要。不过针对个体来说，比人脉更重要的是他所拥有的资源。 翻看2015年年度小结，顺利完成了《Android开发艺术探索》一书的阅读，加深了对Gradle的使用和认知。 2016年安卓方面，有了如下更新： 进一步理解了MVC，MPV和MVVM的区别和使用，在android App中使用Clean－Architecture项目架构，在项目里使用RxJava（RxBus），Retrofit2.0， Dagger2.0。 在Google发布App，Material Design在App中的使用。 加入了一家一线互联网公司 2016年阅读了如下书籍： 操作系统－精髓与设计原理 第七版（半本） 黑客与画家（五星推荐） Android开发艺术探索 安卓设计模式－源码解析与实战（抽章节着看，目测不到半本） Gradle For Android 中文版 把时间当作朋友（李笑来著） 2016年上半年最大的收获是对当下热门的开源库的实践，下半年最大的变化就是加入了一家愿景远大的一线互联网公司，非常期待在这个广阔的平台上发挥自己的技术能力。 基于思考，接下来2017年的安卓学习重点和主题是：提高计算机基础素养。为此，计划阅读和学习的书籍（按时间顺序）如下： 深入理解计算机系统 &amp; 操作系统－精髓与设计原理 算法 第四版 Java编程思想 &amp; Effective Java 一本关于函数式 Java8学习的书 鸟哥的Linux私房菜基础学习篇 因此我把2017年度的学习分成三个阶段： 前四月学习计算机基础 5月到8月学习Java 后四月学习Linux 注：如果时间不够，就依次顺延到2018年上半年 2017年将是为以后进一步成长打好基础的一年，非常重要。2017年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用数组和链表实现自制的栈和队列]]></title>
    <url>%2F2016%2F12%2F22%2F2016%2F2016-12-22%2F</url>
    <content type="text"><![CDATA[数组和链表是常用的两种数据结构，在翻看了Stack类，Iterable接口，Iterator接口，Queue的Java源码后，尝试用数组和链表来自己实现一下栈和队列。 自己造过轮子后，实实在在的理解了轮子，才能真正深入的使用轮子。代码如下：数组和链表是常用的两种数据结构，在翻看了Stack类，Iterable接口，Iterator接口，Queue的Java源码后，尝试用数组和链表来自己实现一下栈和队列。 自己造过轮子后，实实在在的理解了轮子，才能真正深入的使用轮子。代码如下： 说明：Stackable是我自己写的接口 数组实现栈public class SugarArrayStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private static final int DEFAULT_CAPACITY = 2; private int N = 0; private E[] a; public SugarArrayStack() { resize(DEFAULT_CAPACITY); } public SugarArrayStack(int size){ resize(size); } private void resize(int size){ E[] temp = (E[])new Object[size]; for(int i = 0; i &lt; N; i++){ temp[i] = a[i]; } a = temp; } @Override public void push(E e){ if(N &gt;= a.length - 1){ resize(a.length * 2); } a[N++] = e; } @Override public E pop(){ E temp = peek(); a[--N] = null; if(N &gt;= 0 &amp;&amp; N == a.length / 4){ resize(a.length / 2); } return temp; } @Override public E peek(){ int index = N - 1; return a[index]; } @Override public int size(){ return N; } @Override public boolean isEmpty(){ return N == 0; } @Override public Iterator&lt;E&gt; iterator() { return new ArrayIterator(N); } private class ArrayIterator implements Iterator&lt;E&gt;{ private int currentIndex; public ArrayIterator(int currentIndex) { this.currentIndex = currentIndex; } @Override public boolean hasNext() { return currentIndex &gt; 0; } @Override public E next() { currentIndex--; return a[currentIndex]; } } } 链表实现栈队列public class SugarLinkedQueue&lt;E&gt; implements Iterable&lt;E&gt;{ private Node&lt;E&gt; mHeadNode; private Node&lt;E&gt; mTailNode; private int mCount = 0; public void enqueue(E e){ Node&lt;E&gt; newTailNode = new Node&lt;&gt;(e,null); if(mCount == 0){ mTailNode = newTailNode; mHeadNode = newTailNode; }else{ Node&lt;E&gt; oldTailNode = mTailNode; mTailNode = newTailNode; oldTailNode.nextNode = newTailNode; } mCount ++; } public E dequeue(){ if(isEmpty()){ throw new IllegalStateException(&quot;Please enqueue an element firstly&quot;); } mCount --; E tempE = mHeadNode.e; mHeadNode = mHeadNode.nextNode; return tempE; } public int size(){ return mCount; } public boolean isEmpty(){ return mCount == 0; } @Override public Iterator&lt;E&gt; iterator() { return new QueueIterator(mHeadNode); } private class QueueIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public QueueIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E currentE = currentNode.e; currentNode = currentNode.nextNode; return currentE; } } private class Node&lt;E&gt;{ private E e; private Node&lt;E&gt; nextNode; public Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 链表实现栈public class SugarLinkedStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private Node&lt;E&gt; headNode; private int count = 0; @Override public boolean isEmpty() { return count == 0; } @Override public int size() { return count; } @Override public void push(E e) { count++; headNode = new Node&lt;&gt;(e, headNode); } @Override public E pop() { if(count &lt;= 0){ throw new IllegalStateException(&quot;please push an element firstly&quot;); } count --; E e = headNode.e; headNode = headNode.nextNode; return e; } @Override public E peek() { return headNode.e; } @Override public Iterator&lt;E&gt; iterator() { return new LinkedIterator(headNode); } private class LinkedIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public LinkedIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E tempE = currentNode.e; currentNode = currentNode.nextNode; return tempE; } } private class Node&lt;E&gt; { private E e; private Node&lt;E&gt; nextNode; private Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 小结在实现过程中，产生了一些心得和感受，如下： 新建一个Java类，顺序是：先初始化成员变量，然后再调用它的构造方法。因此，某些场景上，一些操作是放在成员变量上还是放在构造方法里是有选择和考量的 链表这种数据结构天生包含迭代的编程思想，用递归来解决遇到的问题 数组这种数据结构使用索引访问元素（指针的使用感），操作数组序号来解决遇到的问题 用链表的实现，插入和删除元素的操作和元素数量多少没有关系。 深刻理解Iterator遍历原理，这个接口提供了集合遍历的逻辑封装，逻辑分为两个部分：hasNext方法和next方法。这两个方法合在一起产生出递归的效果，从而实现集合遍历 自制栈实践是时候使用自己造的轮子了 问题表述：给出一个字符串的算术表达式，求其值。比如“((( 10 + (34 - 24))*5)-(200/11))” 思路分析：用两个栈，一个保存运算符，一个保存操作数。将操作数压入操作数栈，将运算符压入运算符栈，忽略左括号，每遇到右括号，弹出一个运算符，弹出所需数量的操作数，计算后所得结果再压入操作数栈。 代码如下： public static void main(String[] args) { String expression = &quot;((( 10 + (34 - 24))*5)-(200/11))&quot;; float result = calculate(expression); System.out.println(&quot;result = &quot;+result); } private static float calculate(String expression) { if (expression != null &amp;&amp; expression.length() &gt; 0) { Stackable&lt;Character&gt; operatorsStack = new SugarArrayStack&lt;&gt;(); Stackable&lt;Float&gt; valueStack = new SugarLinkedStack&lt;&gt;(); StringBuilder sb = new StringBuilder(); char[] charArray = expression.toCharArray(); for (char c : charArray) { switch (c) { case &apos;(&apos;: case &apos; &apos;: break; case &apos;+&apos;: case &apos;-&apos;: case &apos;*&apos;: case &apos;/&apos;: pushNumberValue(valueStack, sb); operatorsStack.push(c); break; case &apos;)&apos;: pushNumberValue(valueStack, sb); Float firstPop = valueStack.pop(); Character operation = operatorsStack.pop(); float f; switch (operation) { case &apos;+&apos;: f = valueStack.pop() + firstPop; break; case &apos;-&apos;: f = valueStack.pop() - firstPop; break; case &apos;*&apos;: f = valueStack.pop() * firstPop; break; case &apos;/&apos;: f = valueStack.pop() / firstPop; break; default: throw new IllegalArgumentException(&quot;this operator haven&apos;t been supported now&quot;); } valueStack.push(f); break; default: sb.append(c); } } return valueStack.peek(); } return -1; } private static void pushNumberValue(Stackable&lt;Float&gt; valueStack, StringBuilder sb) { int length = sb.toString().length(); if(length &gt; 0){ float value = Float.parseFloat(sb.toString()); valueStack.push(value); sb.delete(0, length); } } 如上例子，最终输出的结果是： result = 81.818184 这种计算存在一些缺陷： 需要左右括号包装算术表达式 在一个括号里，只能进行两个操作数的计算 小结到此，我们用自己造的栈，实现了任意长度下的四则算术运算，今天的天气也比昨天格外得好了。 参考资料 算法 Algorithms Fourth Edition By Robert Sedgewick &amp; Kevin Wayne]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓下的刮刮卡摸奖的另一种实现]]></title>
    <url>%2F2016%2F12%2F16%2F2016%2F2016-12-16%2F</url>
    <content type="text"><![CDATA[实现思路网上有使用Xfermode来实现刮刮卡，这里提供另一种思路简洁的实现 一张呱呱卡有三层，最底层我用一个TextView控件显示中奖内容，中间层是刮完之后的显示图样，最上面一层是刮刮卡的封面。手指刮除封面的过程就是把刮刮卡最上面一层裁剪的过程。 实现思路网上有使用Xfermode来实现刮刮卡，这里提供另一种思路简洁的实现 一张呱呱卡有三层，最底层我用一个TextView控件显示中奖内容，中间层是刮完之后的显示图样，最上面一层是刮刮卡的封面。手指刮除封面的过程就是把刮刮卡最上面一层裁剪的过程。 涉及的知识点 canvas.clipPath(),Path类，Region.Op类 onDraw方法和onTouchEvent方法的配合 核心代码如下： public class LotteryView extends View { public static final int STROKE_WIDTH = 15; private float mEventX; private float mEventY; /** * 呱呱卡封面 画笔 */ private Paint mOverlayPaint; private RectF mRectBorder; /** * 呱呱卡边缘 画笔 */ private Paint mStrokePaint; private RectF mRectFill; private Path mClipPath; public LotteryView(Context context) { this(context,null,0); } public LotteryView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public LotteryView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { Bitmap lotteryOverlay = BitmapFactory.decodeResource(getResources(), R.drawable.icon_lottery_overlay); mOverlayPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mOverlayPaint.setShader(new BitmapShader(lotteryOverlay, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); mStrokePaint = new Paint(); mStrokePaint.setAntiAlias(true); mStrokePaint.setStyle(Paint.Style.STROKE); mStrokePaint.setColor(Color.BLACK); mStrokePaint.setStrokeWidth(STROKE_WIDTH); mClipPath = new Path(); } @Override protected void onDraw(Canvas canvas) { if (mRectBorder == null) { mRectBorder = new RectF(0, 0, getWidth(), getHeight()); } if (mRectFill == null) { mRectFill = new RectF(0, 0, getWidth(), getHeight()); } canvas.drawRoundRect(mRectBorder, 10, 10, mStrokePaint); if (mEventX != 0 || mEventY != 0) { mClipPath.addCircle(mEventX, mEventY, 50, Path.Direction.CW); canvas.clipPath(mClipPath, Region.Op.DIFFERENCE); } canvas.drawRect(mRectFill, mOverlayPaint); } @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getAction(); switch (action) { case MotionEvent.ACTION_MOVE: mEventX = event.getX(); mEventY = event.getY(); invalidate(); break; } return true; } } 布局里的使用 &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; &gt; &lt;TextView android:id=&quot;@+id/tv_lottery_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerInParent=&quot;true&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@android:color/darker_gray&quot; android:text=&quot;恭喜您，荣获2016年年度最佳程序员&quot; /&gt; &lt;com.sugary.roundimageview.LotteryView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; /&gt; &lt;/RelativeLayout&gt; 小结 刮刮卡的中奖内容是放在TextView控件，作为最底层显示。 如果项目里需要有刮卡完成后回调，可以计算刮除的面积与刮刮卡总面积的比例，超过一定值，即认为呱卡完成。 后续的优化方向可以是，把底层的TextView放到LotteryView自定义控件里]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的Gradle打包安全么]]></title>
    <url>%2F2016%2F12%2F11%2F2016%2F2016-12-11%2F</url>
    <content type="text"><![CDATA[现在Android项目的构建几乎都使用Gradle，Gradle提供了命令行打包，通过执行任务的方式，操作起来很方便。 通常Gradle打包的方式比如通常我们会如下这般处理：现在Android项目的构建几乎都使用Gradle，Gradle提供了命令行打包，通过执行任务的方式，操作起来很方便。 通常Gradle打包的方式比如通常我们会如下这般处理： signingConfigs{ release{ storeFile file(&quot;/xxx.jks&quot;) storePassword &quot;111&quot; keyAlias &quot;demo&quot; keyPassword &quot;222&quot; } } productFlavors { yingyongbao { //根据渠道需要配置参数 } } 这里我假设需要打应用宝的渠道包，在命令行窗口，或者直接在AS的Terminal窗口，进入到项目根目录，使用Gradle命令行打包： ./gradlew assembleYingyongbaoRelease 如果团队里有人用了Window系统提交，第一次使用Mac系统提交，很可能会遇到Permission Denied问题，解决办法：我的上一篇博文当Window遇到Mac OS出现Permission Denied／Could not expand时 更安全Gradle打包的方式上述方式打包是成功的，但是这里存在安全性问题： 安全隐患一：签名文件jks默认放在模块目录里，连同代码一起提交到服务器上，如果团队使用第三方的提交后台，安全隐患明显 安全隐患二:签名的密码，别名等内容直接暴露在build.gradle文件里 基于上述的考虑，下面是更安全的打包签名配置： signingConfigs { release { storeFile file(RELEASE_SIGNING_FILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD } } 在项目根目录gradle.properties文件里，存放签名信息 RELEASE_SIGNING_FILE = ../../xxx.jks RELEASE_STORE_PASSWORD = 111 RELEASE_KEY_ALIAS = demo RELEASE_KEY_PASSWORD = 222 然后在.gitignore文件里添加一条语句（不提交gradle.properties文件到服务器） gradle.properties 安全分析通过相对路径，我们把签名文件放在模块目录上二级，即和项目目同级，解决了安全隐患一 利用了gradle.properties文件里的键值对信息能直接在build.gradle中引用的方式，解决了安全隐患二 其他团队成员第一次使用这种配置打包的时候，需要本地更新自己的gradle.properties内容。 小结上述安全的Gradle打包，有一个前提是允许项目里的gradle.properties文件不上传到服务器。有的团队，安卓项目因为一些特殊原因非得需要上传gradle.properties文件呢？那就只有自己新建一个.gradle文件存储签名信息了，详见kevin_nazgul的android签名文件存放的另一种方式 参考资料： Gradle for Android By Kevin Pelgrims stackoverflow：How to create a release signed apk file using Gradle?]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Window遇到Mac OS出现Permission Denied／Could not expand时]]></title>
    <url>%2F2016%2F12%2F09%2F2016%2F2016-12-09%2F</url>
    <content type="text"><![CDATA[12月8日，在北京国家会议中心（奥林匹克公园），一场谷歌技术狂欢，刚参加完，感觉很赞，简短纪录下。12月8日，在北京国家会议中心（奥林匹克公园），一场谷歌技术狂欢，刚参加完，感觉很赞，简短纪录下。 本次大会活动有三个部分： 开幕式和七个分会场的技术演讲。内容包含Android，Daydream，Tango，Firebase，Angular，TensorFlow等等。同一个时间段不小心出现了多个都想听的演讲主题，那就只好取舍了一番（会后看录像视频） 谷歌新技术体验馆。现在总结，感觉听演讲的时间没必要那么多，可以抽更多的时间在体验馆上感受谷歌产品和技术。 休息区，散落的小游戏小抽奖，免费自助午餐，下午茶，Party晚宴。这部分真心赞，明年继续参加。 开幕式之后，关注和听了如下专题： Android Studio2.0/2.1/2.2的新功能。会上我问了一个问题,Android应用开发，一直以来都用Java，谷歌会打算变动语言或者有这样的安排么？演讲嘉宾叫胡坤，他回答谷歌没有这样的安排。不过我想，即使有，这样的高层决定，估计也不是中国片区的人能最早知道的，即使知道了，也不会在不合适的时间点对外公布。 Android support library最新变化。讲的很快，更多是知道有什么变化，也漏说了一些，实际开发需要的很多细节，需要自己动手。还有，新版的Support Library拆成多个独立的模块板，开发者可以根据需要单独引用依赖。 Android电池和内存优化。这部分演讲嘉宾从Android 6.0/7.0电池和系统特性，给出了开发建议，具体的代码的实现和tips建议说得很快，但还是有干货。 Daydream介绍，入门说明和讲解。直接体验感觉更深刻 Tango简介，我的理解是谷歌开发的一套算法并提供了调用的API接口，提供给开发者增强现实技术所需的计算和分析结果。如何动手开发一款Tango应用，在谷歌开发文档上有仔细的讲解，文末给出链接了。当然前提是需要有一款支持Tango的手机。 WebApp的未来 在优酷谷歌开发频道和其微博能看到这次大会的视频，视频内容相当详尽了。 google／Android官方网站和资源：（推荐） Google Developers中国网站 优酷Google开发频道视频 谷歌中国的官方微博（新浪微博） 另外谷歌也开通了微信公众号，这个也是很好的渠道了解谷歌（尤其是在中国的）最新动态]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Window遇到Mac OS出现Permission Denied／Could not expand时]]></title>
    <url>%2F2016%2F11%2F30%2F2016%2F2016-11-30%2F</url>
    <content type="text"><![CDATA[最近用gradle打包安卓新项目时 ./gradlew assembleRelease 出现Permission Denied提示 错误场景最近用gradle打包安卓新项目时 ./gradlew assembleRelease 出现Permission Denied提示 在检查gradle配置信息无误后，使用管理员权限打包 sudo ./gradlew assembleRelease 这样能顺利打包，不过使用debug调试模式编译项目时，依然报错：Could not expand…我遇到的错误忘记记录了，大概类似如下的错误： Execution failed for task &apos;:app:prepareComAndroidSupportAppcompatV71901Library&apos;. Could not expand ZIP &apos;/opt/android-sdk/extras/android/m2repository/com/android/support/appcompat-v7/19.0.1/appcompat-v7-19.0.1.aar&apos;. 错误分析遇到这样的情况，十有八九因为团队成员用了不同的操作系统开发，特别是，有人用Window开发，有人用Mac开发，git版本管理下，这两个操作系统对文件权限的管理方式是不同。 解决该错误，涉及到的操作有： 查看项目目录权限ls -l yourFilePath 我对一个安卓项目的根目录查看了权限，显示结果如下： drwxr-xr-x 24 sugarya staff 816 11 3 16:12 Ferrari 这里第一个字母d表示文件类型，r表示可读，w表示可写，x表示可执行 修改项目目录权限Mac上鼠标操作右键要修改的目录，点击显示简介，底部有一栏共享与权限，列出了该目录的权限情况，手动修改之。 用文字设定法chmod [who] [+ | - | =] [mode] 文件名? ，详细情况可阅读参考资料 用数字设定法假定要修改的目录为当前路径下名为myDirectory的文件夹 sudo chmod -R 777 myDirectory 如此myDirectory目录的权限就改为drwxrwxrwx，即该用户，同组用户以及其他用户都具有写、读、执行的权限 小结权限修改完成后，再次使用gradle打包，一切变得顺利了 参考资料： mac os x 文件权限管理 如何设置文件夹权限为777 mac os x系统下 chmod +x comdfile StackOverFlow：gradlew:Permission Denied]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓App项目开发的几点认识]]></title>
    <url>%2F2016%2F11%2F22%2F2016%2F2016-11-22%2F</url>
    <content type="text"><![CDATA[团队多人开发下项目第一级目录按功能模块划分，二级分类按控件划分。这个原则对res目录下的values目录同样适用。也即：colors，strings，dimens，atrr，style文件要创建多个，用功能模块分类，这样提交代码时，方便审核，较少提交冲突。对需要相互依赖的文件，统一放在一个目录下集中体现 团队多人开发下项目第一级目录按功能模块划分，二级分类按控件划分。这个原则对res目录下的values目录同样适用。也即：colors，strings，dimens，atrr，style文件要创建多个，用功能模块分类，这样提交代码时，方便审核，较少提交冲突。对需要相互依赖的文件，统一放在一个目录下集中体现 跳转逻辑一部分放在Navigator静态类里，一部分逻辑封装到BaseActivity的Protect方法（如果所有逻辑都封装在父类，增加了父类负担，代码可读性降低） 约定思维接口定义，泛型的使用位置，方法入参，返回数据这些都体现着约定思想，谁调用我，就要按我的约定规则来。约定规则怎么写才能表示约定人的意图呢？这要用到约定规则的规则Java语法和使用。学好Java才能让程序员充分表达自己的逻辑和意图。 RxJava操作符：创建型： create,just,from, range,interval combineLatest concat(多个流按顺序串行发射),merge（多个流交叉合并成一个流发射）,zip（多个流合并成一个流后统一发射） 处理型： map,flatMap(交叉发射),concatMap（串行发射） repeat，take，takeLast first（只发射满足条件的第一个），single（只发射顺序为第一个的数据源） debounce(发射最后一次) concatWith skip（N） 抑制Observable发射的前N项数据 merge(count,skip)每接收到count个数据后，将该count的个数据打包，并跳过第skip个数据，发送给订阅者 RxLifecycle使用Github主页 RxJava 中 merge, contact,compose 区别 RxJava操作符之takeUntil 带你学开源项目：RxLifecycle-当Activity被destory时自动暂停网络请求 Java中，父类和子类如何配合，以实现一个完整逻辑父类盛放共有的，具体的，稳定的的变量和方法，子类相对于父类具有拓展能力和行为，不同子类有不同方法 明确谁是导演类（Director Class，顶层的导演类也称为客户端类，用这样的方式划分体现类与类的调用关系） 如果是父类是子类的导演，父类调用子类，则子类实现父类的抽象方法或者重写Protected方法。此时，站在父类角度看：模块逻辑的执行顺序在父类里规划，站在子类的角度看：子类是具体逻辑的战场，父类是援军，父类在调用是，把自己的变量（援军）通过方法参数传给子类，具体逻辑的实施（战场）在子类方法里。 如果子类是父类的导演，子类新的方法里调用父类的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 下]]></title>
    <url>%2F2016%2F10%2F30%2F2016%2F2016-10-30%2F</url>
    <content type="text"><![CDATA[现状无法马上摆脱人们往往低估环境的巨大能量。尽管天赋确实很重要，但一个人能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间，只要足够认真，努力，他的能力就会不停地积累。每一时刻的现状都是过去某一或者某些时刻的结果。而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。 现状无法马上摆脱人们往往低估环境的巨大能量。尽管天赋确实很重要，但一个人能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间，只要足够认真，努力，他的能力就会不停地积累。每一时刻的现状都是过去某一或者某些时刻的结果。而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。 对现状的不满，急于摆脱现状，是人们常常不知不觉落入的陷阱（尽管偶尔这也是少数人真正的动力）。接受现状才是最优策略：有什么做什么，有什么用什么；做什么都做好，用什么都用好。不要常常觉得苦（这会让人顾影自怜，浪费精力和时间），而要想办法在任何情况下找到情趣，快乐是一种本事。 优秀的年轻人几乎都有这样的特征：很少对现状不满，热爱自己的生活，相对更不在意外界的影响，更专注于做事而心无旁贷，身处良性循环之中。 怎样判断所做的事情是否正确？核心只有一个：看它是否现实。 把时间当作朋友 第三章传送门 侯世达定律：完成一个任务实际花费的时间总会超过计划花费的时间，就算制定计划的时候考虑到本法则。 要提高估算时间的能力，就要从现在开始养成习惯：做任何事情之前先判断其熟悉程度（或陌生程度），再据此判断估算完成任务所需要的时间。 及时行动所谓做事拖延，不是拖延着做事，而是拖延着不开始做事。 拖延的人为什么迟迟不开始行动？错误的估算所需的时间来自内部的恐惧只要开始做事，一个人就要面临做错，做不好的风险。拖延症患上一个简单的认知错误：认为哪些能够做对做好的人都是直接做对，做好的。很多人做事拖延不过是“不求有功，但求无过”的心态在作祟。而现实是：只要做事，就一定会出问题。 做事情的时候，肯定会遇到困难，事情越有价值，困难就越具规模。遇到困难的时候，心平气和地面对就好，因为这只不过是生活常态。 有时我们花费了很多时间和精力依然没能解决问题，却眼见别人轻松过关，这确实令人气馁。不过这也是生活常态：在任何一个特定领域，总会有一些人比另一些人表现更好，费力更少。 接受现实，勤能补拙。 来自外部的恐惧这段的描述太好了，忍不住要站立鼓掌。 过分在意外界的评价。人是一种很有趣的动物，在自己作对，做好之前，通常已经了解作对，做好是什么样子。于是，无论能否作对，做好，人都觉得自己有能力判断别人是否作对做好。所以，尽管自己不怎么样，却可以振振有词、理直气壮地评价别人做得对不对、好不好。因此，可以得出一个推论：一个人一旦开始认真做事，被嘲弄、被耻笑的几率将远远高于被夸奖、被鼓励的几率。 那些真正能够作对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走来，心理非常清楚作对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。 如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会像那些极少数已经做对、做好的人一样，给予别人真诚而非嘲弄。也有时候，那些能真正做对、做好的人也会给出负面评价，但那通常都是“建设性的负面评价”，并不是为了获得优越感而发出的嘲弄。 没有谁一开始就能做对、做好。所有做对，做好的人都是一路磕磕绊绊走过来的，这就是生活的常态 动辄给出非建设性负面评价的人，往往不是正经做事的人，他们和那些正经做事的人身处不一样的世界，这也是生活的常态。 为什么随着年龄的增加每个人都会觉得时间过得越来越快？对一个5岁的孩子来讲，未来的1年相当于他已经度过的人生的¹⁄₅，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的¹⁄₅₀，即2%。所以，随着年龄的增加，人们会觉得时间运动得越来越快。 小结几乎一切愚蠢的行为都来自否定现实，逃避现实。时间是现实的人的朋友，是不现实的人的敌人。 最后期限不是固定在将来某一个点，而是朝着你加速扑来。如果在起步晚了的情况下，问题不是“到时候能不能做好”，而是“到时候能做多好就做多好，总好过什么都不做”。所以，不管遇到什么任务，最好的开始时间就是：现在]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 上]]></title>
    <url>%2F2016%2F10%2F28%2F2016%2F2016-10-28%2F</url>
    <content type="text"><![CDATA[近来休息了一段时间，期间也看了几本闲书。比如魔天记，真灵九变这类网络小说；比如杨冰阳女士（ayawawavip）的完美关系的秘密，讲述两性关系的相处。原本希望通过这本书让自己不仅是能深耕的好码农，还能是把妹届的老司机。近来休息了一段时间，期间也看了几本闲书。比如魔天记，真灵九变这类网络小说；比如杨冰阳女士（ayawawavip）的完美关系的秘密，讲述两性关系的相处。原本希望通过这本书让自己不仅是能深耕的好码农，还能是把妹届的老司机。 最近在看的是，笑来老师的把时间当作朋友，大赞，是价值观的更新，我做了读书摘要和思考。 技术的速成是不可能的时间不可管理，为什么大家都想要速成呢？ 这是人们追求收获的欲望当达不到不劳而获的时候，少劳多获也是可以接受的。如果收获的可能性很大，我们就会想尽快看到结果；如果收获的可能性很小，我们就会想尽快知道结果。 很多时候我们不清楚某些“阶段”不可省略事物的成长需要时间，成驻败空，缘起性空，因缘和合，这些阶段是客观存在。怀胎十月，才有健康的宝宝诞生人间。接受这个客观的过程，技术的进步也是。 基于对“现状”的不满意有时候，我们意识里知道上诉两个道理，但是为什么还会想要尝试速成，去抓住那个万一成功了呢。源于对当下现状的不满意，想要去改变。 笑来老师书里引用了一位老外的的统计分析研究，对人一生各个阶段满意感的分布。发现，从15岁左右开始，人的满意感一直在下降，直到50，60岁后开始上升。这个挺有趣的想象，也可以用来解释某些人产生“中年危机”感的心里诱因。 完美永不存在。笑来老师如是说： 没有什么事情是一下子就能做好的。我们至多能做到接近完美，或者更接近完美。所以，不管做什么事情，都需要时刻忍耐各种的不完美，否则事情根本无法完成。最终完成的事情，结果也常常是不完美的。缺陷必然存在。再往大一点说，生活本省就不完美。谁的生活不是磕磕绊绊？谁死去的时候没有一丝遗憾？现实如此，只能接受。* 这段话的意思，我可以概括为：因上精进，果上随缘。没有结果是完美的，但是不妨碍我们在追求的路上努力做到最好。 未知永远存在笑来老师如是说： 我们害怕未知，害怕不确定的东西。我们希望一切都在自己的掌握之中，只是我们永远做不到。随着未知因素数量的增加，有序排列可知，这些因素所引发的结果的数量将以几何级数的方式飞速增加。* 在自学一项技能的时候，存在一种“牛角尖陷阱”，为此，我们必须忍受一定的未知。承认自己不可能全知全晓，因为客观存在一些情况，如：有些时候有些问题没有答案（先有鸡还是先有蛋），即便有些问题有了答案，其原因也不见得我们能够搞懂（顺序，分支，循环就能够完成任何流程控制）在这种情况下，暂时不去问为什么，可能更划算* 学习一门新课程，会发现，第一章的内容需要在掌握后面某一章知识之后才能深入了解。在学习第一章的时候，我们会有无数疑问以当时的知识是无法全部解答的，需要我们继续学习，用接下来的知识解答现在的疑问。* 我可以类比，推而广之。比如父母老师教导的行为，小时候不以为然，觉得枯燥，无聊无用，长大后，才恍然醒悟。因此，对于经典的，历来传颂的事物和行为，与其现阶段搞不明白的情况下非要弄明白好坏益处，还不如先行动起来。 焦虑的产生笑来老师如是说： 接受未知永远存在，不断尝试适应：在未知中不断前行。如果不接受这个现实，无法忍受未知的存在，会平添无数的焦虑。关于这一点，本人有过好多次体验。* 焦虑导致时间浪费，效率低下。处于焦虑状态下时，甚至可能出现一切理智都被清空的情况，会让人觉得“必须要做点什么”，但是，在这种缺乏理智状态下的任何决定和行为都可能带来灾难性的后果，陷入恶性循环。如何解决？一个有效的方法就是把问题先记录下来。* 小结上述仅仅是第一章的部分内容，把时间当做朋友一书和稻盛和夫先生活法里的观点（人生和工作的结果=思维方式(-100～+100)×热情(0～+100)×能力(0～+100)）不冲突，能感受到是另一种方式的阐述，有继续读下去的冲动。 时间不可管理，我们先学会接受：完美永不存在，未知永远存在。基于这样的接受去认识时间，把时间做为朋友相处。 传送门： 把时间当作朋友]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBus学习之旅－从入门到提高]]></title>
    <url>%2F2016%2F08%2F13%2F2016%2F2016-08-13%2F</url>
    <content type="text"><![CDATA[在公司的技术分享会上，做了关于RxBus的学习分享，记录如下： 一.RxBus与RxJava一次RxJava调用过程可以划分为以下环节： 创建观察内容 （片段1） 数据处理／映射（片段2） 选择线程（片段3） 订阅（片段4，片段5） 完成／错误处理（片段6） 在公司的技术分享会上，做了关于RxBus的学习分享，记录如下： 一.RxBus与RxJava一次RxJava调用过程可以划分为以下环节： 创建观察内容 （片段1） 数据处理／映射（片段2） 选择线程（片段3） 订阅（片段4，片段5） 完成／错误处理（片段6） 示例代码： Observable // 片段1 .create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String trim = mainEd.getText().toString().trim(); subscriber.onNext(trim); subscriber.onError(new Throwable()); subscriber.onCompleted(); } }) // 片段2 .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s + &quot; sugarya&quot;; } }) // 片段3 .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) // 片段4 .subscribe( // 片段5 new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } //片段6 @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv2.setText(s); } }); 二.RxBus与接口回调一次完整的接口回调，包括四个步骤： 接口定义 接口调用 接口实现 接口注入 RxBus的使用过程，就是一个接口回调的过程。 接口定义，在RxJava定义好了。 上面示例代码片段1里的suscriber.onNext(),onStart(),onError(),onComplete()对应接口调用。 代码片段5，片段6这些是接口实现 注入的过程是调用suscribe()方法订阅的过程 三.RxBus源码分析RxBus的代码实现如下： public class RxBus { private static volatile RxBus instance; private final Subject&lt;Object, Object&gt; _bus; private RxBus() { _bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); } public static RxBus getInstance() { if (null == instance) { synchronized (RxBus.class) { if (null == instance) { instance = new RxBus(); } } } return instance; } public void send(Object object) { try{ _bus.onNext(object); }catch (Exception e){ e.printStackTrace(); } } public boolean hasObservers() { return _bus.hasObservers(); } private &lt;T&gt; Observable&lt;T&gt; toObservable(final Class&lt;T&gt; type) { return _bus.ofType(type);//filter + cast } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Observer&lt;T&gt; observer) { return toObservable(type).subscribe(observer); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1) { return toObservable(type).subscribe(action1); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1, Action1&lt;Throwable&gt; errorAction1) { return toObservable(type).subscribe(action1,errorAction1); } } 接下来对上述代码做些简要分析： volatile 保证instance可见性 禁止指令重排 这里涉及到Java内存模型，相关资料： 传送门 SerializedSubject SerializedSubject extends Subject extends Observable implements Observer，既是观察内容，又是观察者，起到桥梁／数据转发的作用 保证多线程安全，Subject 当作一个 Subscriber 使用，从多个线程中调用它的onNext方法（包括其它的on系列方法） PublishSubject主题，RxJava里有四种主题 PublishSubject BehaviorSubject ReplaySubject AsyncSubject PublishSubject的含义是：在订阅者订阅的时间点之后的数据发送给观察者 ofType操作符 = filter操作符 + cast操作符 filter只有符合过滤条件的数据才会被“发射” cast将一个Observable转换成指定类型的Observable CompositeSubscription该对象作为subscription的容器，方便统一取消订阅 四.RxBus异常处理当RxBus在执行过程中，任意环节发生了错误异常，订阅关系就会被取消。之后再次发送，将无法执行订阅后的回调。 做了一个数组越界的错误来演示 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); onRxBus(); } private void onRxBus() { int[] array = new int[2]; RxBus.getInstance().toSubscription(Integer.class, new Subscriber&lt;Integer&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { //onRxBus(); Log.e(TAG, &quot;mSubscriber17 onError: &quot; + e.toString()); } @Override public void onNext(Integer integer) { array[integer] = integer; Log.e(TAG, &quot;mSubscriber17 onNext:&quot; + integer); } }); } @OnClick(R.id.btn_main17) void onClick17() { RxBus.getInstance().send(2); } 这时候点击button按钮，数组越界异常，第二次再点击Button发送消息，没有响应了。这里，RxBus，确切的说是RxJava捕获到错误异常，就会取消订阅关系。 E/MainActivity: mSubscriber17 onError: java.lang.ArrayIndexOutOfBoundsException: length=2; index=2 解决的思路： 使用try－catch捕获异常，不让异常被RxJava捕获 在onError里重新订阅。 接下来说说第二种方法，具体怎么操作，其实就是在onError方法里，重新执行一遍订阅，执行上述注释掉的代码onRxBus,就解决问题了。 五.小结上述其实是这次技术分享大纲，技术分享准备功课前，刷了下面的文章，要对RxBus有更细致的学习和了解，可以阅读：（推荐） 谢三弟系列RxBus简单实现 RxBus深入源码解析 RxJava里onError异常处理 Yokey系列RxJava实现事件总线 RxBus异常处理 RxBus实现Sticky事件（粘性订阅） 其他RxBus从基础实现到升级——打造属于自己的RxBus EventBus和RxBus实现和性能比较]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》之如何创造财富]]></title>
    <url>%2F2016%2F08%2F08%2F2016%2F2016-08-08%2F</url>
    <content type="text"><![CDATA[这本书有很多特别有趣，以前从来没有思考过的观点，在读第6章如何创造财富的时候，这种震撼非常强烈。记录如下： 创业就是一个压缩过程 这本书有很多特别有趣，以前从来没有思考过的观点，在读第6章如何创造财富的时候，这种震撼非常强烈。记录如下： 创业就是一个压缩过程你所有的工作年限被压缩成了短短几年,不再是低强度地工作四十年，而是以极限强度工作四年。伴随而来的是工作压力也压缩到三四年，承受如此大的压力，带给你额外的报酬。 金钱不等于财富，创造有价值的东西就是创造财富财富和金钱不是同义词。我们需要的东西就是财富，食品，服装，住房，汽车，生活用品，外出旅行等都是财富，即使你没有钱，你也能拥有财富。 要是你身处南极洲内陆，再多的钱对你也是无用的，因为没有东西可买，你真正需要的是财富。 如果财富这么重要，为什么大家都却把赚钱挂在嘴边而不是财富呢？因为金钱是财富的一种简便的表达方式，是专业化的副产品。 比如你本人能制作小提琴，而你需要土豆，附近的农民对小提琴不感兴趣，那么你怎么能交换到土豆呢？ 当社会分工越来越精细后，人们把贸易分为两步：不是直接用小提琴交换土豆，而是先用小提琴交换金钱，然后再用金钱交换需要的东西。所以让自己变的富有，就是制造出人需要的商品，让别人用金钱交换商品，你拿到金钱，你就可以拿着赚来的金钱向任何人交换自己需要的其他商品。 交换媒介的优点是，它使得交易可以进行下去，缺点是，它模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介（一般等价物），做生意直接原因是为了获取中介，出发点应该是创造供他人需求的商品，让大家可以获得自己想要的东西。大多数生意的目的是为了做出人们真正需要的东西，创造财富。 如果我们要大量获取一般等价物，就应该抱着特别怀疑的态度，去思考那些着眼于你自己感兴趣的东西的商业计划。对于自己感兴趣的东西，你会聚的它们很有价值，但是它们恰恰最不可能与他人眼中的有价值的东西发生重合。 世界上的财富总额不是固定不变的，财富一值在不停地增长比如，一台坏机器因为一个零部件松了而不能正常运转，你把零件拧紧，机器重新运转，那么你便创造了财富。 程序员是手工艺人，创造着大量的财富我们这个世界，向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。许许多多不创造财富的人，听到最富有的5%人口占有社会一半以上财富，往往认定这事不公平的，就像最顶级的程序员写出了全世界99%的优秀软件。 创造出来的财富不一定非要通过出售实现价值，人们需要的东西就是财富，极客经常开发开源软件让所有人免费试用，把自己的工作捐献给社会。 工作是什么财富就意味着人们需要的东西。公司的存在目的就是满足人们的某种需要。作为公司的一分子与许多人一起合作完成，感觉自己是为了公司的需要而工作，其实是为了满足顾客的某种需求而工作。一分子的贡献也许不是直接性的，但是公司作为一个整体必须提供某种人们需要的东西，否则不可能盈利。 当初刚毕业，我对自己说，我需要进入一家公司工作，好像成为某个组织成员是一件多么重要的事情。然而更确切的表达是：我需要去做一些人们需要的东西。即使不加入公司，我也能做到，公司不过是一群人在一起工作，共同作出某种人们需要的东西。 真正重要的是做出人们需要的东西，而不是加入某个公司]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《途客圈创业记》有感]]></title>
    <url>%2F2016%2F07%2F31%2F2016%2F2016-07-31%2F</url>
    <content type="text"><![CDATA[不知道去年因为什么缘故，阅读了MacTalk原编程一书，关注了池老师的公众号，于是连带的关注了小道消息，嘀嘀嗒嗒，程序人生等公众号，这本书的作者就是程序人生的Tyr Chen不知道去年因为什么缘故，阅读了MacTalk原编程一书，关注了池老师的公众号，于是连带的关注了小道消息，嘀嘀嗒嗒，程序人生等公众号，这本书的作者就是程序人生的Tyr Chen 上周周二到手，工作日读了一半，今天傍晚一口气读完剩下的一半。心中有沉沉的思绪，做个读书小结，整理记录下。 技术人员从公司组织架构上是不是不适合作为第一大股东呢？Tyr散发的气息真得就是大多数有追求的程序员共有的特质，大凡热带代码，热带技术的人都会相似的逻辑思维。即使我也创业，我想我的遭遇和因对和情绪表达也是差不多的，CTO对于公司的角色定位，在技术和管理上，要被赋予更多管理的职责。 因此，如果醉心于技术成长，醉心于成为一名酷范十足的极客，CTO不是极客状态下的程序员的职业追求，技术级别悠长的技术性导向的盈利公司会是个好选择之一，成长为技术合伙人。 技术合伙人是高级段位的职业，再上一层，我觉得，也有，但是已经不再是仅仅磨练技术就能达到的了。这是极客下一个阶段或者状态的事吧。而我要向通往极客道路上前进。 感谢途客圈创业记一书，让我知道创业的过程和注意事项，这些过程和事项是认真的，是真实的，是鲜活的。 本周六有Try Chen关于本书的读者见面会，充满期待。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用小结之入门篇]]></title>
    <url>%2F2016%2F07%2F21%2F2016%2F2016-07-21%2F</url>
    <content type="text"><![CDATA[在Java的世界里，接口是Java最强大的设计之一。笔者对接口的认识和理解包括： 实现一个接口需要四个步骤 接口定义：使用interface，可以外部定义，也可以在类中定义，根据实际需求来。 接口调用：接口定义好了，需要调用接口方法 接口实现：接口里的方法是抽象方法，需要开发人员具体的逻辑实现 接口注入：把接口实现的引用传给接口调用方。 在Java的世界里，接口是Java最强大的设计之一。笔者对接口的认识和理解包括： 实现一个接口需要四个步骤 接口定义：使用interface，可以外部定义，也可以在类中定义，根据实际需求来。 接口调用：接口定义好了，需要调用接口方法 接口实现：接口里的方法是抽象方法，需要开发人员具体的逻辑实现 接口注入：把接口实现的引用传给接口调用方。 接口的作用和意义： 通过入参，确定了一种数据流的流动方向，从接口调用方流向接口实现方。也即提供了一种代码执行的先后顺序。 降低代码的耦合。实现接口是java类与类之间的一种关系，比继承这样的强依赖的耦合度低。接口涉及Java六大设计原则里的依赖倒置原则和接口隔离原则，面向抽象编程，对调用者来说执行相同的行为（代码），却可以组织不同的逻辑。 作为静态常量的容器。可以在接口里定义各种常量。 在Android里的基本使用Rxjava每一次observable发出事件，让订阅者执行，都是一次使用接口的过程，满足上述分析的四个步骤。 Observable.create()使用EditText里输入内容，TextView显示 （1）Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String s = mainEd.getText().toString().trim(); subscriber.onNext(s); subscriber.onCompleted(); } }); （2）Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv.setText(s); } }; （3）observable.subscribe(subscriber); 分析： 代码段（1）Observable.create()方法里，new Observable.OnSubscribe(),完成了subscriber接口的调用。代码段（2）使用匿名内部类，完成了接口定义和接口实现。代码段（3）完成了接口注入。 因此说，一次Rxjava的操作，就是一次使用接口的过程。明白了这点，如果以后引入Lambda表达式，也就不再容易感到困惑和不解了。 Observable.Just()使用上述代码可以简化写成下面的样子 String trim = mainEd.getText().toString().trim(); Observable.just(trim).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { mainTv2.setText(s); } }); Just和Create生成Observable的关联和区别： just生成的Observable只调用了接口subscriber的onNext()和onComplited()。 just代码执行是在订阅subscribe()方法调用之前，通过create生成的observable在订阅subscribe()方法调用的时候执行 Observable.from()使用入参可以是集合或者数组，该集合或数组有多少个元素就会发送多少次事件。 StringBuilder sb = new StringBuilder(); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;step1&quot;); list.add(&quot;step2&quot;); list.add(&quot;step3&quot;); list.add(&quot;step4&quot;); Observable.from(list).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { sb.append(s+&quot; &quot;); } }); mainTv3.setText(sb.toString()); 上述代码返回的结果是：step1 step2 step3 step4 小结有了上述的认识和练习，相信对Rxjava有了一个入门的学习和使用了。 参考资料 深入浅出RxJava（一：基础篇） Github:RxJava]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当RecyclerView遇到Inconsistency detected崩溃时]]></title>
    <url>%2F2016%2F07%2F20%2F2016%2F2016-07-20%2F</url>
    <content type="text"><![CDATA[近来项目里，RecyclerView更新数据偶尔出现crash，错误日志如下：近来项目里，RecyclerView更新数据偶尔出现crash，错误日志如下： java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder{2064e5c6 position=2 id=-1, oldPos=2, pLpos:-1 scrap [attachedScrap] tmpDetached no parent} at android.support.v7.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition(RecyclerView.java:4505) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4636) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4617) at android.support.v7.widget.LinearLayoutManager$LayoutState.next(LinearLayoutManager.java:1994) at android.support.v7.widget.LinearLayoutManager.layoutChunk(LinearLayoutManager.java:1390) at android.support.v7.widget.LinearLayoutManager.fill(LinearLayoutManager.java:1353) at android.support.v7.widget.LinearLayoutManager.onLayoutChildren(LinearLayoutManager.java:574) at android.support.v7.widget.RecyclerView.dispatchLayoutStep1(RecyclerView.java:2979) at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:2904) at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3283) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutHorizontal(LinearLayout.java:1948) at android.widget.LinearLayout.onLayout(LinearLayout.java:1724) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.Line 遇到这类错误java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder，通过查阅Stackoverflow和资料，总结了如下情况和解决方法： 方法一自己写一个继承LinearLayoutManager的包装类，在onLayoutChildren()方法里try-catch捕获该异常。 @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { try { super.onLayoutChildren(recycler, state); } catch (IndexOutOfBoundsException e) { e.printStackTrace(); } } 方法二在进行数据移除和数据增加时，务必要保证RecyclerView的Adapter中的数据集和移除／添加等操作后的数据集保持一致！ 这里，前者是在该Adapter内部，不妨叫做内部数据集，后者是开发人员传过给Adapter的，不妨叫外部数据集。更新RecyclerView数据时，需要保证外部数据集和内部数据集实时保持一致。 外部数据集同步到内部数据集，使用如下的方法： notifyItemRangeRemoved(); notifyItemRangeInserted(); notifyItemRangeChanged(); notifyDataSetChanged(); 这里对notifyDataSetChange()做些说明： 使用该方法的更新内部数据集，没有默认的动画效果，同时更新数据的效率页不如上面的方法，官方不推荐使用这种方式更新数据集。 Don’t call notifyDataSetChanged if you don’t have to. RecyclerView的Adapter里，发生异常的错误代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null ) { mPoiItems.clear(); mPoiItems.addAll(poiItemList); notifyItemRangeChanged(0, poiItemList.size()); } } 错误分析： mPoiItems是外部数据集，对该外部数据集做了两个操作：先移除数据，然后添加数据，之后notify数据集。这里，添加数数据时（Adapter的内部数据集内容还处在外部数据集移除数据之前），造成了内部和外部数据集不一致。 这是一方面，另一方面，我使用了notifyItemRangeChanged()来更新数据，如果poiItemList传过来的新数据和原来mPoiItems的数据数量不一致，就会出现内部数据集和外部数据在同步后不一致，从而报错。 修复后，运行正常的代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null) { int previousSize = mPoiItems.size(); mPoiItems.clear(); notifyItemRangeRemoved(0, previousSize); mPoiItems.addAll(poiItemList); notifyItemRangeInserted(0, poiItemList.size()); } } 修复分析： 每一次对外部数据集做改动时，都需要紧接着主动对外部数据集和内部数据集做一次同步操作，动画效果也得到了保持（使用方法三，动画效果缺失） 方法三：使用notifyDataSetChanged同步外部数据集和内部数据集。该方法简单，但是失去了动画效果，并且更新数据的性能低。 use notifyDataSetChanged() will avoid this crash, but it will kill Animation and Performance. 另外，如果对外部数据集做了二次以上的操作，却只调用notifyDataSetChanged同步一次，也很有可能会报上文所示的错误。 ###参考文章: stackoverflow 1 RecyclerView Bug：IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter的解决方案 使用RecyclerView遇到的一些问题 Inconsistency detected]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 下]]></title>
    <url>%2F2016%2F07%2F10%2F2016%2F2016-07-10%2F</url>
    <content type="text"><![CDATA[在我之前的一篇博客Java内存模型 上一文里，对Java的内存做了一番简单的梳理。通过上述专题的阅读和学习，又有了新的认识和思考。 最近看到一个专题讲解Java内存模型的，感觉干货满满，现记录如下： 深入理解Java内存模型（一）——顺序 深入理解Java内存模型（二）——重排序 深入理解Java内存模型（三）——顺序一致性 深入理解Java内存模型（四）——volatile 深入理解Java内存模型（五）——锁 深入理解Java内存模型（六）——final 深入理解Java内存模型（七）——总结 在我之前的一篇博客Java内存模型 上一文里，对Java的内存做了一番简单的梳理。通过上述专题的阅读和学习，又有了新的认识和思考。 关于Java的锁当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。这一操作和volatile变量的写操作相同功效 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，这一操作和volatile变量的读操作相同共享 也即是文中总结的：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 由此也自然联想到，Java锁的内部实现，其实就是通过volatile来实现的。 这里还涉及到公平锁，和非公平锁，这两者的区别是： 公平的锁上，线程按照他们发出请求的顺序获取锁.当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。 关于Java的final对于final域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。 重排序重排序分为两大类： 编译器重排序 处理器重排序，该排序可细化为指令级并行的重排序和内存系统的重排序 内存屏障：对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止） 内存模型越是追求性能的处理器，内存模型设计的会越弱,模型由强变弱依次为： 顺序一致性内存模型 JMM 处理器内存模型 happens-before:如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间. 参考资料Java 理论与实践: JDK 5.0 中更灵活、更具可伸缩性的锁定机制]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动读取短信验证码LoaderManager／CursorLoader的使用]]></title>
    <url>%2F2016%2F07%2F06%2F2016%2F2016-07-06%2F</url>
    <content type="text"><![CDATA[Cursor用来直接读取安卓手机里的数据库记录，如何获取到Cursor ？ 可以通过SQLiteOpenHelper，打开SQLiteDatabase 通过ContentProvider/ContentResolver获取 Cursor用来直接读取安卓手机里的数据库记录，如何获取到Cursor？ 可以通过SQLiteOpenHelper，打开SQLiteDatabase 通过ContentProvider/ContentResolver获取 自动读取验证码实现思路： 当验证码的短信到来，能有个监听回调或者广播之类，告知开发人员 读取短信是危险权限，android6.0权限适配 获取验证码的短信内容 从短信内容里刷选出验证码 显示验证码 接下来针对每一个步骤，做些分析和代码分享 监听接收到新短信使用ContentResolver，引入内容观察者，监听短信内容的变化，代码如下： public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public void initReadSmsLoader(){ LoaderManager loaderManager = getLoaderManager(); if(loaderManager != null){ loaderManager.initLoader(0, null, new ReadSmsLoaderListener()); } } class ReadSmsContentObserver extends ContentObserver{ public ReadSmsContentObserver(Handler handler) { super(handler); } @Override public void onChange(boolean selfChange, Uri uri) { super.onChange(selfChange, uri); LOG.e(TAG,&quot;selfChange = &quot; + selfChange+&quot; uri = &quot; + uri); if(PermissionHelper.checkReadSmsPermission(mContext)){ initReadSmsLoader(); }else{ takeReadSmsPermission(); } } } 短信验证码，权限适配PermissionHelper是自己封装的工具类 PermissionHelper.takeReadSmsPermission(this,PermissionHelper.REQUEST_CODE_READ_SMS); 获取验证码的短信内容这里有多个方案，网上相当多技术文章使用contentResolver.query()方法。我认为这个方法不够好。 该方法在UI线程里操作的，当查询的数据库的记录很多时，会出现卡顿现象。 需要手动关闭Cursor，Cursor维护操作交给开发人员。 好在，安卓已经提供了异步的（子线程）数据库查询方式，使用LoaderManager和CursorLoader这两个类，不存在上述两个问题。代码如下更详细的LoaderManager.LoaderCallbacks各个回调方法的使用，可以参考android CursorLoader用法介绍 /** * 注册内容观察者 */ public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public class ReadSmsLoaderListener implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;{ private static Uri URI_SMS_INBOX = Uri.parse(&quot;content://sms/inbox&quot;); // &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;date&quot;, &quot;type&quot; private static final String[] READ_SMS_PROJECTION = new String[]{&quot;body&quot;}; private static final String READ_SMS_SORT_ORDER = &quot;date desc&quot;; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { //两分钟内，收到的短信，date降序排列 String readSmsWhere = &quot;date &gt;&quot; + (System.currentTimeMillis() - 2*60*1000); return new CursorLoader(mContext,URI_SMS_INBOX,READ_SMS_PROJECTION,readSmsWhere,null,READ_SMS_SORT_ORDER); } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { fetchSmsCodeFromCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } } /** * 从数据库获取短信并过滤出验证码 */ private void fetchSmsCodeFromCursor(Cursor cursor) { if(cursor != null) { while (cursor.moveToNext()) { String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;)); if (!TextUtils.isEmpty(body)) { //判断该短信是否是该App发送的 if (body.contains(&quot;走么&quot;)) { String verifyCode = getSmsCode(body); displayVerifyCode(verifyCode); break; } } } } } 从短信内容里刷选出验证码使用正则表达式筛选，按正则的使用套路走起 /** * 从短信中获取验证码 * @param smsContent 短信内容 * @return */ private String getSmsCode(String smsContent){ Pattern pattern = Pattern.compile(&quot;[0-9]{4,}&quot;); Matcher m = pattern.matcher(smsContent); while (m.find()) { String group = m.group(); if(group != null &amp;&amp; group.length() &gt;= VERIFY_CODE_LENGTH){ return group; } } return &quot;&quot;; } 显示验证码 /** * 显示验证码 * @param verifyCode 验证码 */ private void displayVerifyCode(String verifyCode) { mSmsCodeEt.setText(verifyCode); //获取焦点 mSmsCodeEt.setFocusable(true); mSmsCodeEt.setFocusableInTouchMode(true); mSmsCodeEt.requestFocus(); //设置光标位置 mSmsCodeEt.setSelection(verifyCode.length()); } ##总结至此，成功实现读取短信验证码。近来主流的App，并没有实现自动读取短信验证码，比如滴滴出行，钉钉。 ##参考资料 android CursorLoader用法介绍 CursorLoader LoaderManager]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CursorLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 上]]></title>
    <url>%2F2016%2F07%2F03%2F2016%2F2016-07-03%2F</url>
    <content type="text"><![CDATA[Java内存模型（Java Memory Model，JMM） 内存模型规定： 所有的变量都是存在主存当中（类似于物理内存） 每个线程都有自己的工作内存（类似于高速缓存） 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。 每个线程不能访问其他线程的工作内存。 Java内存模型（Java Memory Model，JMM） 内存模型规定： 所有的变量都是存在主存当中（类似于物理内存） 每个线程都有自己的工作内存（类似于高速缓存） 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。 每个线程不能访问其他线程的工作内存。 缓存一致性（Cache coherence）问题当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中 在一个系统中，当许多不同的设备共享一个共同存储器资源，在高速缓存中的数据不一致，就会产生问题。也就是说如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 缓存一致性可以分为三个层级： 在进行每个写入运算时都立刻采取措施保证数据一致性 每个独立的运算，假如它造成数据值的改变，所有进程都可以看到一致的改变结果 在每次运算之后，不同的进程可能会看到不同的值（这也就是没有一致性的行为） 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK锁的方式 通过缓存一致性协议 最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的 它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 ##参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析 海 子]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程]]></title>
    <url>%2F2016%2F07%2F01%2F2016%2F2016-07-01%2F</url>
    <content type="text"><![CDATA[并发编程的三个问题：原子性问题，可见性问题，有序性问题并发编程的三个问题：原子性问题，可见性问题，有序性问题 原子性概念简介 一个操作或者多个操作，要么全部执行，要么就都不执行 执行的过程不会被任何因素打断 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。Java内存模型只保证了基本读取和赋值是原子性操作。 Java语言提供的保证：通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 普通的共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值。 Java语言提供的保证 volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性程序执行的顺序按照代码的先后顺序执行。 指令重排序（Instruction Reorder）处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 处理器在进行重排序时是会考虑指令之间的数据依赖性。重排序会影响多个线程内程序执行的结果。换句话说，重排不会影响单个线程内程序执行的结果。 结论：指令重排的适用范围是线程，它不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 举个参考资料里的例子： 我相信，有经验的程序员，即使不懂的指令重排，本能上也不会用两个线程异步的执行下诉初始化操作。 //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingWithConfig(context); 计划执行：在线程1里执行语句1，初始化加载操作，完成后，标志位inited置为true，线程2，跳出睡眠，执行doSomethingWithConfig方法。 实际执行：由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 Java语言提供的保证：通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性 volatile关键字一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 volatile关键字的使用场景volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。因此，当保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 状态标记量 double check。 单例的最优写法: class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null){ instance = new Singleton(); } } } return instance; } } 参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/Protobuf之Protocol Buffers配置指南]]></title>
    <url>%2F2016%2F06%2F27%2F2016%2F2016-06-27%2F</url>
    <content type="text"><![CDATA[使用Protobuf，先配置环境，以下是配置Protobuf的步骤和编译Protobuf原文件的步骤使用Protobuf，先配置环境，以下是配置Protobuf的步骤和编译Protobuf原文件的步骤 Java:Compiled Environment Download:https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-java-3.0.0-beta-3.zip Install:$ ./configure $ make $ make check $ make install Check version:$ protoc --version Protocol Buffers Outputhttps://developers.google.com/protocol-buffers/ To Objective-C(.h .m)$ protoc --proto_path=src --objc_out=build/gen src/foo.proto src/bar/baz.proto To Java(.java)$ protoc --proto_path=src --java_out=build/gen src/foo.proto –proto_path可以缩写为： －I Objective-C:####Download: https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-objectivec-3.0.0-beta-3.zip Install:$ objectivec/DevTools/full_mac_build.sh Building:There are two ways to include the Runtime sources in your project: Add objectivec/\*.h &amp; objectivec/GPBProtocolBuffers.m to your project. or Add objectivec/\*.h &amp; objectivec/\*.m except forobjectivec/GPBProtocolBuffers.m to your project. If the target is using ARC, remember to turn off ARC (-fno-objc-arc) for the.m files. The files generated by protoc for the *.proto files (\*.pbobjc.h&#39; and*.pbobjc.m`) are then also added to the target.]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活法3－寻找你自己的人生王道]]></title>
    <url>%2F2016%2F05%2F23%2F2016%2F2016-05-23%2F</url>
    <content type="text"><![CDATA[早些时候，就有想写写随笔。这个类目当作我阅读好书的笔记思考。 2011年，第一次读稻盛和夫《活法（壹）》一书，犹如闪电于混沌中飞越，对我的价值观带来一次迄今为止最大的更新和改动。 早些时候，就有想写写随笔。这个类目当作我阅读好书的笔记思考。 2011年，第一次读稻盛和夫《活法（壹）》一书，犹如闪电于混沌中飞越，对我的价值观带来一次迄今为止最大的更新和改动。 今天重拾活法－－系列叁，书读过半，深感于语句散发出来的韵律和共鸣。摘要如下： 能力出众，满腔热情，干净十足，事业一开始就拼命努力，若再有好运相助，成功便几成定数。相较于成功，保持成功更为不易。不论经营，政治或治学领域，“成功”不足为奇。成为不骄，谦虚律己，生命不息，克己不止，方才为人杰。只是这样的人似乎太正派，旁者看来颇为无趣。然而，若非颇为无趣之人，则不可能实现持久的成功 考虑到这是译文，也就不必在意成功这词的随意滥用了。 再摘引如下： 克己，临于万事欲克而不得。故先修身养性而后成也。 只有将“克己”精神融入自己的品性，血肉之中，事到临头才不致想克制也克制不了。为此，需积以时日，不断在平时就训练努力克制自己，抑制自身的欲望。 都天下无二道，圣人无两心。自天子以至于庶人，皆是以修身为本，其本乱而末至者，否矣。《大学》里的观点：平天下，治国，齐家，当从修身开始。 这里稻盛和夫讲得于旁观者看来无趣和我们要做个有趣的人说的有趣，概念会冲突么？这值得思考]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件工程里解决问题的思维]]></title>
    <url>%2F2016%2F04%2F10%2F2016%2F2016-04-10%2F</url>
    <content type="text"><![CDATA[今天在项目开发中，遇到一个问题，在尝试解决无果后，对解决问题的思维产生一番思考。记录如下。 今天在项目开发中，遇到一个问题，在尝试解决无果后，对解决问题的思维产生一番思考，记录如下。 在我看来，解决一个项目问题的思维能拆分成若干个环节，这些若干个环节彼此相互互斥，解决问题的过程被映射为一环环固化思维的串接。问题得到解决存在一个最小思维量。当认知超过最小思维量时，就能推测、预判问题的变化。 思维量存在且不限于以下两个属性：思维复杂度和环节确定性。思维复杂度表示解决问题的可能性数量或方向多少。环节确定性指的是：互斥并且单一的指向下一个思维环节。互斥和单一指向两者缺一不可。当一个环节在这个思维过程中与其它环节形成互斥，即表示这个思维环节是解决问题的有效组成成分；单一指向的作用是能促成思维导向同一个结果：解决问题。一个方向而不是多个方向，这大大的降低思维复杂度。 另一方面，每个思维环节的确定性大小会影响下一个环节的确定性。如果一个环节不确定是对是错、正确程度未知，就会导致该环节的指向不再单一而是多个。所以，不高的环节确定性会造成较高的思维复杂度，这是不利于工程问题的顺利解决的。 结论：基于上述认知，工程能力提高的过程其实就是增加思维环节确定性和数量的过程。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年的年度小结]]></title>
    <url>%2F2015%2F12%2F31%2F2015%2F2015-12-31%2F</url>
    <content type="text"><![CDATA[2015年，于我是全新的一年。很多事情，从这一年才开始走上轨道，我感到开心和幸运。在写这篇小结之前，读完了糊糊老师的年度小结散文，杂感繁多，就摘录一小段文字吧，如下： 人如何能说服自己用当下去换一个未来的结果，将现在的自己当成工具一般，去为充满了无常的未来牺牲此刻。一个不够快乐的过程，如何得来圆满的结果？ 2015年，于我是全新的一年。很多事情，从这一年才开始走上轨道，我感到开心和幸运。在写这篇小结之前，读完了糊糊老师的年度小结散文，杂感繁多，就摘录一小段文字吧，如下： 人如何能说服自己用当下去换一个未来的结果，将现在的自己当成工具一般，去为充满了无常的未来牺牲此刻。一个不够快乐的过程，如何得来圆满的结果？ 我想，我不需要说服自己，在这过程中，本就是快乐多于痛苦，收获多于汗水的，所以我感到幸运。 做为安卓开发人员，这一年，我花大量的时间在安卓技艺的熟练和学习上。主要有以下方面： 1) 对安卓基本的控件做到了熟练使用。不再像去年那般书写代码要通过大脑思考反复验证生涩的写，而是可以主要通过手指记忆敲出大量常用的代码，包括ListVIew，RecyclerView，Notification，ViewPager，Fragment，WebView等等。 2) 多次获得了一些有效项目实践。体现在项目重构，减少App启动时间，代码重构优化，Android6. 0权限适配，UI多屏幕适配上。 3）年底开源了自己写的一个字母表控件到github上。虽然这个控件很小，和github上各位大牛相比不值一提，但却是某种新的开始。 4）其他杂项。如纸质设计，git使用，gradle的学习，大都只是入门。尤其是gradle的学习，我希望接下来抽一段时间，好好把这块深入进去。 今年入手了Macbook pro，Mac相比于Window对开发人员真友善了，我想吼一句相用恨晚啊。今年看的一些书籍，简单做了记录吧。 《Android开发艺术探索》，很赞，五星推荐。（还在阅读中） 《HTTP权威指南》 读完一遍，对代理服务器／缓存服务器，http 报文有了一个全面的了解。 《MacTalk 人生元编程》&amp;《MackTalk 跨越边界》，这两本是池建强老师的微信文章集文成册，一部分讲解Mac的使用，更多的是关于程序员生活状态／工作的人文内容。 通过这一年的学习，更清晰的是了解到接下来一年，我该在哪些地方提高自己的安卓水平。2016年对于我来说，是很重要的一年，是技术道路上需要我更多投入的，以期达到一种升华和质变的一年。 2016年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentTransition的replace，add，show，hide方法的使用差异]]></title>
    <url>%2F2015%2F12%2F26%2F2015%2F2015-12-26%2F</url>
    <content type="text"><![CDATA[android项目，使用Fragment来展示视图，替换Activity显示，能有效的提高响应的速度。结合在项目中的实践，接下来说说我对这些方法的使用感悟。 replace使用使用replace()替换后会将之前的fragment的view从viewtree中删除触发顺序:detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView() attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() android项目，使用Fragment来展示视图，替换Activity显示，能有效的提高响应的速度。结合在项目中的实践，接下来说说我对这些方法的使用感悟。 replace使用使用replace()替换后会将之前的fragment的view从viewtree中删除触发顺序:detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView() attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 使用该方法，每次都可以走一遍生命周期方法，让对象保持在最新的状态，同时也会带来频繁的数据请求，实例销毁和创建 replace时，通过FragmentTransition的addToBackStack(String name)方法，把被置换的fragment压入任务栈，放在新的fragment下。在replace时如果带上tag参数，那么就可以通过FragmentManager的findFragmentByTag（）找到被置换的fragment对象 这样，当按返回键时，被置换的Fragment就能重新显示出来，并执行对应的生命周期方法（如上显示的触发顺序） add使用使用该方法，常和show和hide配合，达到replace方法的显示效果。在使用过程中，有时候会出现视图重叠。原因有两种： 没有使用FrameLayout作为容器 第一次add把Fragment添加到容器后，第二次通过 FragmentManager.findFragmentByTag(“fragment” + position)找到Fragment而不是重新新建实例add进容器 一个MainActivity加上多个Fragment来构建android项目界面主体。用这种方式，底部每一个菜单就是一个fragment，暂且叫它一级操作界面，通常用add－show －hide方式显示Fragment，在每一个Tab里（二级以上操作界面），通过replace不同的fragment来展示不同的视图 使用这种方式，我在项目中遇到了一个问题。如果二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，那么这时候在一级操作界面里，调用了二级操作界面的对象的成员对象将变成null 原来，当二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，二级以上的界面通过replace来显示不同的界面，这时候二级操作界面的fragment将按上面的触发顺序重新走一遍生命周期方法，创建了新的实例，原来在一级目录里引用的二级界面上的Fragment的成员对象依然是旧实例里的 因此这时候解决的办法可以，在每次创建二级界面的fragment实例时，重新更新一遍（set方法）一级界面会用到的所有涉及二级界面fragment的成员变量]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少App的启动时间]]></title>
    <url>%2F2015%2F12%2F10%2F2015%2F2015-12-10%2F</url>
    <content type="text"><![CDATA[这几天在做App的启动时间优化，减少了将近一半的启动时间。先把一些感悟分享如下： 如何查看App的启动时间？通过android自带的工具adb，使用命令行查看adb shell am start -W -n 包名/.启动Activity例如：adb shell am start -W -n com.adb.xyz/.view.LaunchActivity这几天在做App的启动时间优化，减少了将近一半的启动时间。先把一些感悟分享如下： 如何查看App的启动时间通过android自带的工具adb，使用命令行查看adb shell am start -W -n 包名/.启动Activity例如：adb shell am start -W -n com.adb.xyz/.view.LaunchActivity 优化思路：打开App，程序首先运行Application 的onCreate方法，多数App接下来会进入扉页，最后是主页的Activity。如果在onCreate方法里，运行过多代码以及做了耗时操作，App在启动的时候就会出现一片白屏或黑屏。 而我门要做的就是把运行在onCreate的方法里的代码尽量的移到扉页中运行。 这里还有三个注意事项：Android6.0后权限的适配。如果在Application里执行代码有需要用户授权，那么需要在BaseActivity里，权限请求回调函数中，从新执行Application里的代码。 同时还要关注，上述变动对主页Activity带来的影响，有些在主页里执行的代码要做异常处理，然后在请求授权的回调里重新执行一遍。 项目工程里，如果引用的第三方库使用到了.so文件，这些.so文件的执行速度跟手机的硬件内核有关。因此，会看到，不同的手机，相同的优化方案，减少的App启动时间会不同。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓三种动画小结]]></title>
    <url>%2F2015%2F11%2F24%2F2015%2F2015-11-24%2F</url>
    <content type="text"><![CDATA[安卓中，动画可以分为三类。逐帧动画，补间动画，属性动画。稍微小结下，我对这三个动画的认识。 逐帧动画AnimationDrawble,所以逐帧动画，其实是一种图像。通过设置ImageView类的background好或者src从代码和xml两个方式上载入。安卓中，动画可以分为三类。逐帧动画，补间动画，属性动画。稍微小结下，我对这三个动画的认识。 逐帧动画AnimationDrawble,所以逐帧动画，其实是一种图像。通过设置ImageView类的background好或者src从代码和xml两个方式上载入。 ####纯代码 AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground(); frameAnimation.start(); xml定义&lt;animation-list android:id=&quot;@+id/selected&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/ wheel0&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel1&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel2&quot; android:duration=&quot;50&quot; /&gt; &lt;/animation-list&gt; 补间动画补间：开发者只需要给出动画的起始和结束帧状态，中间的帧交由安卓系统计算和补齐。抽象类Animation是补间动画的基类。同样可以分为xml和纯代码两种方式显示。补间动画无法实现动画无限重复播放。 涉及的APIAlphaAnimation,ScaleAnimation,RotateAnimation,TranslateAnimation,AnimationSet，Interpolator(差值接口),TimeInterpolator,Transformation,Camera（三维图形变换，类似Matrix） Animation animation = AnimationUtils.loadAnimation(Context context,int id) 实现自定义补间动画继承Animation，重写initalize()方法和applyTransformation(float interpolatedTime,Transformation t)方法 interpolatedTime:代表了动画的时间进行比，不管动画实际的持续时间如何，当动画播放时，该参数总是自动从0变化到1. Transformation 该参数代表了补间动画在不同时刻对图形或组件的变形程度。 applyTransformation方法的参考代码：camera.save(); camera.rotateY(360 *interpolatedTime); Matrix matrix = transformation.getMatrix(); camera.getMatrix(matrix); matrix.preTranslate(-centerX,-centerY); camera.restore(); 属性动画属性动画主要有两方面组成：1计算各帧的相关属性值 2为指定对象设置这些计算后的值。对象的属性名称有：rotationX,rotationY,scaleX,scaleY,alpha,translationX,translationY监听事件 ValueAnimator.AnimatorUpdateListener , Animator.AnimatorListener 涉及的APIAnimator:属性动画的基类。 ValueAnimator: 负责第一方面的内容。因此第二方面，为指定对象设置属性值须由程序员通过监听来完成。 ObjectAnimator,是ValueAnimator的子类，使用起来更简单。 AnimatorSet（属性动画组合），它是Animator的子类，用于组合多个Animator,指定播放顺序。 Evaluator和TypeEvaluatorEvaluator 计算器，控制属性动画如何计算属性值。TypeEvaluator 计算器接口，通过实现该接口来实现自定义计算器。 IntEvaluator FloatEvaluator ArgbEvaluator PointFEvaluator RectEvaluator ValueAnimator的使用基本用法 调用ValueAnimator的ofInt(),ofFloat()或ofObject静态方法创建 设置持续时间，插值方式，动画模式等属性 注册监听器AnimationUpdateListerner，在监听方法里，通过getAnimatedValue()方法，把当前帧的值应用到所需要的对象上。 start()启动动画 如果getAnimatedValue()返回的不是系统默认的值，借助TypeEvaluator接口，用系统自带的实现类，如PointFEvaluator,FloatArrayEvaluator,或者自己实现TypeEvaluetor,重写evaluator方法。 代码如下： valueAnimator.setObjectValues(new PointF(0, 0)); valueAnimator.setEvaluator(new TypeEvaluator&lt;PointF&gt;() { @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) { Log.e(&quot;evaluate&quot;,&quot;fraction=&quot;+fraction + &quot; startValue=&quot;+startValue +&quot; endValue=&quot; + endValue); PointF pointF = new PointF(); pointF.x = 200 * fraction * 3; pointF.y = (float) (0.5 * 10 * 200 * fraction * fraction); return pointF; } }); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { PointF pointF = (PointF) animation.getAnimatedValue(); ball.setTranslationX(pointF.x); ball.setTranslationY(pointF.y); } }); ObjectAnimator的使用继承自ValueAnimator，完成了属性动画的两个方面，所以可以直接把动画应用到对象上。 注意事项 该对象存在对应属性的setter方法。 如果只提供一个值，则该值被认为是结束值，此时需要提供getter方法。 如果该对象的setter方法不会自动调用invalidate()方法，则需要在onAnimationUpdate()监听方法里调用invalidate()刷新屏幕。 xml定义属性动画&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;objectAnimator android:duration=&quot;600&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:propertyName=&quot;alpha&quot; android:repeatCount=&quot;infinite&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot; /&gt; Animator animator = AnimatorInflator.loadAnimator(Context context,int resId); 多个属性动画同时播放的实现通过AnimatorSetAnimatorSet s = new Animatorset(); s.play(animator1).before(animator2); s.paly(animator2).befor(animator3); 2、ValueAnimator,ObjectAnimater的AnimatorUpdateListener监听方法onAnimationUpdate里，调用对象的多个属性setter即可 3、借助PropertyValuesHolder PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;,1f,0f); PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0f); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0f); ObjectAnimator animator1 = ObjectAnimator.ofPropertyValuesHolder(txt,holder1, holder2, holder3); animator1.setDuration(800); animator1.setInterpolator(new AccelerateDecelerateInterpolator()); animator1.setRepeatMode(ValueAnimator.REVERSE); animator1.setRepeatCount(ValueAnimator.INFINITE); animator1.setStartDelay(1000); animator1.start(); 借助ViewPropertyAnimator实现同时播放动画//need API12 mBlueBall.animate()// .alpha(0)// .y(mScreenHeight / 2).setDuration(1000) // need API 12 .withStartAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;START&quot;); } // need API 16 }).withEndAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;END&quot;); runOnUiThread(new Runnable() { @Override public void run() { mBlueBall.setY(0); mBlueBall.setAlpha(1.0f); } }); } }).start(); 等效于： PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(“alpha”, 1f, 0f, 1f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(“y”, 0, mScreenHeight / 2, 0); ObjectAnimator.ofPropertyValuesHolder(mBlueBall, pvhX, pvhY).setDuration(1000).start(); 参考资料 《疯狂安卓讲义》 Android 属性动画（Property Animation） 完全解析 （下）]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对变量范围转换引发的思考]]></title>
    <url>%2F2015%2F10%2F07%2F2015%2F2015-10-07%2F</url>
    <content type="text"><![CDATA[程序中，变量活动范围有：方法/函数（局部）里的，成员变量（全局变量） 当一个变量从局部变量升级到全局变量，该变量可以跨方法使用，因此在一个方法里对该变量赋值，在另一个方法里就能马上感知到并获取变量的值，体现着监听设计思想。程序中，变量活动范围有：方法/函数（局部）里的，成员变量（全局变量）。 当一个变量从局部变量升级到全局变量，该变量可以跨方法使用，因此在一个方法里对该变量赋值，在另一个方法里就能马上感知到并获取变量的值，体现着监听设计思想。 变量升级，并不是都带来了好的方面。一个变量升级后，就要求程序员考虑是否需要对这个变量进行维护。（所谓维护就是该变量是否处在一个循环中）如果需要维护，即变量处在循环中，则要考虑是否需要对该变量进行初始化和善后处理（因为全局变量是和其他变量或方法相互联系的）如果需要，则进一步考虑变量在循环中从0次，到1次，到2次的变化过程，并从这三次变化过程中提取规律。如果获取规律？程序员的经验以及一些更底层的规律。 把一个变量从局部编程全局的途径有如下方法： 1）利用java语言的特性，从方法变量编程成员变量 2）java语言特性，编程静态变量 3）通过单例，存储在手机内存中 4）放在Application中（严格说，这种方法其实也属于3）中的单例法） 5）存储在本地，需要用到的时候，再从本地获取。比如SharedPeference，IO流写入和读取。 变量从全局变量降级成局部变量，带来的好处就是降低了变量维护难度。只需要在该方法作用范围内考虑，同时对变量个体而言，作用范围的缩小，自然增加了变量作用的安全性。 由此，还可以推广到逻辑思考切入点事宜。 一个问题，肯定是处在特定的范围或事件中的。澄清前提，划清界限很有必要。解决一个问题，修复一个bug，首先需要把这个bug产生的起始点找到，这个起始点有时候是浮动的，可以往前多些，也可以往后移些。找到bug的起始点后，还要清楚这个bug的结束点。在这起始点和结束点之间的这一段范围里，我们去修改这个bug。为了定位bug，有时候当第一直觉和感知还无法定位bug的时候，就需要对这一段范围进行切割分段。如何切割？切割的依据是什么？这里涉及到责任链，可以选取一个范围大小的责任链作为参考进行分割，其实也即是业务逻辑功能模块来分割。然后定位到某一段时，再次分割。 这种循序渐进的方式，带来了逻辑的严密，bug就不容易被我们漏过。面对问题，只要有严密的思路和逻辑对bug和问题进行分解、拆分，加上有效时间的累积实践和反馈，就一定能找到解决和修复的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
