<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android原生项目集成ReactNative混合开发]]></title>
    <url>%2F2018%2F08%2F03%2F2018%2FAndroid%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90React-Native%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：搭建开发环境 以下是 本篇的正文: 初始化React Native 生成package.json文件，该文件用于记录react native版本信息和依赖包 加入React，React Native类库 生成flowconfig文件 12345678910npm init&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;&#125;npm install --save react react-native@版本号curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig 配置原生安卓项目的Gradle12345678910111213141516171819202122232425allprojects &#123; repositories &#123; maven &#123; url &quot;$rootDir/node_modules/react-native/android&quot; &#125; jcenter() &#125;&#125;dependencies &#123; implementation &apos;com.facebook.react:react-native:版本号&apos;&#125;android &#123; defaultConfig &#123; ndk &#123; //选择要添加的对应cpu类型的.so库。 abiFilters &apos;armeabi&apos;, &quot;armeabi-v7a&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot; &#125; &#125; configurations.all &#123; resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos; &#125;&#125; 添加权限12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;/&gt;&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt; 添加React native入口在项目根目录下，新建index.js文件作为React Native控件配置页 Hello World示例 12345678910111213141516171819202122232425import React from &apos;react&apos;;import &#123;AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, &#125;, hello: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;,&#125;);AppRegistry.registerComponent(&apos;AndroidRnDemoApp&apos;, () =&gt; HelloWorld); 编译运行到安卓真机12adb reverse tcp:8081 tcp:8081npm start 打包新建assert资产文件 1react-native bundle --platform android --dev false --entry-file index.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/ 小结 本次Android集成了React Native0.51.0版本的环境（最新为0.56.0），采取了原生项目为主，编译和打包仍走安卓项目的Gradle流程 React Native集成过程中，由于Kotlin改写了模块iml文件里的某处标签信息，使得项目无法正常编译，往文件里手动添加如下标签得以修复： 1&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第七讲-泛型在Java和Kotlin上的横向比较]]></title>
    <url>%2F2018%2F07%2F16%2F2018%2FKotlin%E7%AC%AC%E4%B8%83%E8%AE%B2-%E6%B3%9B%E5%9E%8B%E5%9C%A8Java%E5%92%8CKotlin%E4%B8%8A%E7%9A%84%E6%A8%AA%E5%90%91%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 阅读本文前，如果对Java泛型不够了解，不妨先阅读我之前写的两篇说Java泛型的文章 重拾Java泛型 上篇 重拾Java泛型 下篇 语法比较泛型方法Java 1234567891011public static&lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)&#123; Iterator&lt;? extends T&gt; iterator = list.iterator(); T result = iterator.next(); while (iterator.hasNext())&#123; T t = iterator.next(); if(t.compareTo(result) &gt; 0)&#123; result = t; &#125; &#125; return result; &#125; Kotlin1234567891011fun &lt;T : Comparable&lt;in T&gt;&gt; max(list: List&lt;out T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 查看Kotlin里的Comparable类和List类源码，Comparable类定义，List类定义，所以可以不必重复表明Comparable的逆变能力和List的协变能力。 1234567891011fun &lt;T : Comparable&lt;T&gt;&gt; max(list: List&lt;T&gt;): T &#123; val iterator = list.iterator() var result: T = iterator.next() while (iterator.hasNext()) &#123; val t = iterator.next() if (t.compareTo(result) &gt; 0) &#123; result = t &#125; &#125; return result&#125; 不管是泛型类还是泛型方法，泛型的使用分为两个步骤 第一步，声明泛型参数 第二步，才是使用泛型参数 上面的泛型方法，以Java泛型方法为例，泛型声明部分是： 1&lt;T extends Comparable&lt;? super T&gt;&gt; 引入泛型类型名称为T，这个数据类型的关系是实现Comparable的类。 使用泛型的部分如下： 1List&lt;? extends T&gt; 入参的集合具有对类型T的协变能力。 所以，有些书或者网上资料，会出现两个概念：声明点变型，使用点变型。这个概念说的就是这件事 再来看下in位置，和out位置的概念 所以，类型参数T上的关键字out有两方面含义： 具有协变的能力 T只能用在out位置 我们再看一个有趣的例子 我有一个方法，入参的一个集合，我希望入参集合元素是EditText的子类的集合，如何构建满足这个关系的方法呢？至少有下面的两种方式： 1234567fun test2(list: MutableList&lt;out EditText&gt;)&#123;&#125;fun &lt;T: EditText&gt;test3(list: MutableList&lt;T&gt;)&#123;&#125; 上面test2， test3方法都能实现预期的效果。不同的是，test2使用协变来实现，也意味着只能读不能写操作，test2不是泛型方法。test3方法通过在声明表明泛型参数的类型关系来实现，可读可写，它是泛型方法。 对应的Java代码如下 private void test2(List&lt;? extends EditText&gt; list){ } private &lt;T extends EditText&gt; void test3(List&lt;T&gt; list){ } 实现泛型参数多约束Java 123private &lt;T extends Serializable &amp; CharSequence&gt; void ensureTrailingPeriod(T seq)&#123; &#125; kotlin 123fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T: Serializable, T: CharSequence&#123; &#125; 这是Java语法上很大的不同，Kotlin要实现多约束，使用到where关键词，这是全新的表示法。 实化类型参数来看一段Java代码： private &lt;T&gt; void test(T t){ if(t instanceof String){ String s = (String)t; }else if(t instanceof Integer){ Integer i = (Integer)t; } } 入参是泛型的，通过instanceof来判断泛型具体是哪个类型。再看一段代码 private &lt;T&gt; void test2(Object o){ //编译不通过 if(o instanceof T){ } } 泛型作为参数类型时，编译不通过。如果要完成上述的逻辑，要怎么实现？可以通过class近似等效实现 class ClassJudge&lt;T&gt;{ Class&lt;T&gt; kind; public ClassJudge(Class&lt;T&gt; kind) { this.kind = kind; } public boolean isInstance(Object o){ return kind.isInstance(o); } } 调用 Integer a = 12; boolean instance = new ClassJudge&lt;String&gt;(String.class).isInstance(a); System.out.println(&quot;instance = &quot; + instance); Kotlin在语言层面作出了支持，对上述Java代码test2方法，kotlin代码如下： 12345inline fun&lt;reified T&gt; test2(any: Any)&#123; if(any is T)&#123; &#125;&#125; 因此需要具备两个条件： 是内联函数 inline 关键词 reified 集合协变在Kotlin里，非空类型是可空类型的子类型。 Java实现的协变 1List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;(); Kotlin实现的协变 1val list: MutableList&lt;out Number&gt; = arrayListOf&lt;Int&gt;() 集合逆变Java实现的逆变 1List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;(); 对应的Kotlin逆变的实现： 1val list: MutableList&lt;in Int&gt; = arrayListOf&lt;Number&gt;() 变型（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。 由此可见，在泛型里，extends 不全等于 ：。extends代表子类型关系和协变，而Kotlin的 ：只代表子类型关系。 12&lt;out T&gt; = &lt;? extends T&gt;&lt;in T&gt; = &lt;? super T&gt; 星投影和Java无限制通配符？差异星投影如何使用 12&lt;*&gt; = &lt;out Any?&gt;&lt;*&gt; = &lt;in nothing&gt; 投影一词，顾名思义，是对Any？的投影，获得了Any？部分的能力—Any？协变的能力，即失去写操作，只能读操作。 12345fun printFirst(list: List&lt;*&gt;)&#123; if(list.isNotEmpty())&#123; println(list.first()) &#125;&#125; 场景二：泛型类存储所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化到一个分开的位置，预防了误用，保证了它不会被错误地使用。 其他非空性与泛型Java和Kotlin默认，泛型参数都是可空的，以Kotlin为例 12345class Processor&lt;T&gt; &#123; fun process(value: T)&#123; value?.hashCode() &#125;&#125; 泛型参数是可空类型，可以理解为默认实现&lt;T: Any?&gt;，因此要实现非空类型，只需&lt;T: Any&gt;，如下 12345class Processor2&lt;T: Any&gt; &#123; fun process(value: T)&#123; value.hashCode() &#125;&#125; 所以，泛型 和&lt;T: Any&gt;是有区别的，前者是可空类型，后者是非空类型，确切说，和&lt;T:Any?&gt;等效 小结Kotlin和Java的差异，体现在语法和功能两个方面 语法上 Kotlin使用：替代 extends； 用星投影 * 替代？ 用out, in来体现协变和逆变； 泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示 功能上： 新增了实化参数类型 ##参考资料 仔细说说Java中的泛型 Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ Java 泛型进阶 Java为什么要添加运行时获取泛型的方法 Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第六讲-委托类和属性]]></title>
    <url>%2F2018%2F06%2F12%2F2018%2FKotlin%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%A7%94%E6%89%98%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 委托类实现一个接口，可以使用by关键字将接口实现委托给另一个对象。 1234567891011121314151617181920212223interface OnClickListener&#123; fun onClick() fun onLongClick()&#125;class ViewClickDelegate : OnClickListener&#123; override fun onClick()&#123; println(&quot;ViewClickDelegate onClick&quot;) &#125; override fun onLongClick() &#123; println(&quot;ViewClickDelegate onLongClick&quot;) &#125;&#125;class View(val name: String, onClickListener: OnClickListener) : OnClickListener by onClickListener&#123; override fun onLongClick() &#123; println(&quot;$name onLongClick&quot;) &#125;&#125; 类委托后我们依然可以通过重写的方式来覆盖委托类的实现，这里View实现onLongClick方法，覆盖重写了ViewClickDelegate类里的onLongClick方法。 类委托的本质是：把抽象方法的实现交给了by后的委托对象 延迟初始化和委托属性延迟初始化属性不在对象创建的时候初始化，而是在第一次使用时初始化。完成后像普通属性一样使用 123456789101112open class Food(val name: String) &#123; override fun toString(): String &#123; return &quot;[$name]&quot; &#125;&#125;class Container(val name: String) &#123; lateinit var foodList: List&lt;Food&gt;&#125; 惰性初始化属性第一次使用该属性时才初始化，且只初始化一次。用旗号标示是否初始化过，旗号有多种选择和实现方式。 在代码定义处执行初始化，有助于代码维护。 对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。 普通实现12345678910class Container2(val name: String) &#123; private var _foodList: List&lt;Food&gt;? = null val foodList: List&lt;Food&gt; get() &#123; if (_foodList == null) &#123; _foodList = arrayListOf(Food(&quot;米糊&quot;)) &#125; return _foodList!! &#125;&#125; by lazy(){}实现惰性初始化1234567891011121314151617181920class Container4(val name: String) &#123; val food: Food by lazy&#123; Food(&quot;米糊&quot;) &#125;&#125;//指定锁class Container5(val name: String) &#123; val food: Food by lazy(Container5::class)&#123; Food(&quot;米糊&quot;) &#125;&#125;//默认 线程安全 SYNCHRONIZED//PUBLICATION，同步锁不是必需的，允许多个线程同时执行class Container6(val name: String) &#123; val food: Food by lazy(LazyThreadSafetyMode.SYNCHRONIZED)&#123; Food(&quot;米糊&quot;) &#125;&#125; 在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性，索引属性；关联属性，限制属性。接下来看下Kotlin如何实现关联属性和限制属性的 关联属性（可观察属性）通过PropertyChangeSupport代码实现属性监听12345678910111213141516171819class Shelf(val name: String, _book: Book) &#123; private val propertyChange: PropertyChangeSupport = PropertyChangeSupport(this) var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把逻辑封装，抽取出基类 123456789101112131415161718192021222324252627282930open class BasePropertyChange &#123; val propertyChange = PropertyChangeSupport(this) protected fun addChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.addPropertyChangeListener(key, propertyChangeListener) &#125; protected fun removeChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123; propertyChange.removePropertyChangeListener(key, propertyChangeListener) &#125;&#125;class Shelf_2(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book = _book set(value) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125; fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 把book里的set访问器的逻辑封装成一个类 123456789101112131415161718192021222324252627282930class BookDelegate(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book fun getValue(): Book = field fun setValue(value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf2(val name: String, _book: Book) : BasePropertyChange() &#123; val _bookDelegate: BookDelegate = BookDelegate(_book, propertyChange) var book: Book set(value) &#123; _bookDelegate.setValue(value) &#125; get() = _bookDelegate.getValue() fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 至此，我们用Kotlin手工实现了可观察属性变化的功能，测试下 12345678910111213fun testObserverField() &#123; val shelf = Shelf2(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt.newValue as Book println(&quot;old book = $oldBook , new book = $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行上述代码结果如下： old book = Book(name=Think in java) , new book = Book(name=Kotlin in action) 使用Kotlin委托实现Kotlin的委托属性在语言层面提供了在属性的读访问器里调用委托类里operator修饰的两参数getValue方法，属性写访问器调用operator修饰setValue三个参数方法 12345678910111213141516171819202122232425class BookDelegate2(_book: Book, val propertyChange: PropertyChangeSupport) &#123; var field: Book = _book operator fun getValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;): Book = field operator fun setValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;, newValue: Book) &#123; val oldBook = field field = newValue propertyChange.firePropertyChange(&quot;book&quot;, oldBook, newValue) &#125;&#125;class Shelf3(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate2(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 通常借助ReadWriteProperty接口能方便我们实现委托 12345678910111213141516171819202122232425class BookDelegate3(var field: Book, val propertyChange: PropertyChangeSupport) : ReadWriteProperty&lt;Shelf3_1, Book&gt; &#123; override fun getValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;): Book &#123; return field &#125; override fun setValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;, value: Book) &#123; val oldBook = field field = value propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value) &#125;&#125;class Shelf3_1(val name: String, _book: Book) : BasePropertyChange() &#123; var book: Book by BookDelegate3(_book, propertyChange) fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; addChangeListener(&quot;book&quot;, propertyChangeListener) &#125; fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123; removeChangeListener(&quot;book&quot;, propertyChangeListener) &#125;&#125; 测试上述代码： 1234567891011121314fun testDelegateFieldForKotlin() &#123; val shelf = Shelf3_1(&quot;书架&quot;, Book(&quot;Think in java&quot;)) shelf.addBookChangeListener(object : PropertyChangeListener &#123; override fun propertyChange(evt: PropertyChangeEvent?) &#123; val oldBook = evt?.oldValue as Book val newBook = evt?.newValue as Book println(&quot;Kotlin委托 old book is $oldBook, and new book is $newBook&quot;) &#125; &#125;) shelf.book = Book(&quot;Kotlin in action!&quot;)&#125; 运行结果如下： Kotlin委托 old book is Book(name=Think in java), and new book is Book(name=Kotlin in action!) 委托属性的本质：把属性访问器的实现交给了by后的委托对象 使用Kotlin的自带的实现可观察属性其实，Delegate.observable()类实现了上面提到的所有逻辑了。 我们看下Delegate.observable方法的源码 1234public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit): ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123; override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue) &#125; 该方法返回ObservableProperty对象，看下ObservableProperty对象源码 1234567891011121314151617181920public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value = initialValue protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125; public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value &#125; public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; val oldValue = this.value if (!beforeChange(property, oldValue, value)) &#123; return &#125; this.value = value afterChange(property, oldValue, value) &#125;&#125; 该对象有getValue和setValue方法，这和我们自己实现的BookDelegate3类里的getValue和setValue方法逻辑几乎相同。不同之处是，官方还多了beforeChange()控制，和afterChange()供实现类覆盖重写。 Kotlin标准库已经提供了可观察属性的属性委托实现了 123456class Shelf4(val name: String, _book: Book) &#123; var book: Book by Delegates.observable(_book, &#123;property, oldValue, newValue -&gt; println(&quot;The old book&apos;s name is \&quot;$&#123;oldValue.name&#125;\&quot;, and the new book&apos;s name is \&quot;$&#123;newValue.name&#125;\&quot;&quot;) &#125;)&#125; 测试下上述的代码 1234fun testObserverFieldForKotlin()&#123; val shelf = Shelf4(&quot;书架&quot;, Book(&quot;think in java&quot;)) shelf.book = Book(&quot;Kotlin in action&quot;)&#125; 运行结果如下 The old book’s name is “think in java”, and the new book’s name is “Kotlin in action” 限制属性Kotlin也为我们提供了现成的委托类来实现限制属性 12345class Shelf5(val name: String, val book: Book ,_year: Int) &#123; var year: Int by Delegates.vetoable(_year, &#123;property, oldValue, newValue -&gt; newValue &lt;= 99 &#125;)&#125; 测试上述代码 12345678fun testVetoableFieldForKotlin()&#123; val shelf = Shelf5(&quot;书架&quot;, Book(&quot;think in java&quot;), 0) shelf.year = 200 println(&quot;current book is $&#123;shelf.year&#125;&quot;) shelf.year = 20 println(&quot;current book is $&#123;shelf.year&#125;&quot;)&#125; 运行结果如下： current book is 0current book is 20 注意：上述用的是成员函数，事实上，扩展函数也能实现委托属性 使用Map实现委托属性MapAccessors.kt文件里，有如下扩展函数源码 1234567891011@kotlin.jvm.JvmName(&quot;getVarContravariant&quot;)@kotlin.internal.LowPriorityInOverloadResolution@kotlin.internal.InlineOnlypublic inline fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V = @Suppress(&quot;UNCHECKED_CAST&quot;) (getOrImplicitDefault(property.name) as V)@kotlin.internal.InlineOnlypublic inline operator fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) &#123; this.put(property.name, value)&#125; 由此可见， MutableMap存在getValue方法和setValue方法，那么就可以用于委托，事实上，也确实如此。 举个例子: 123456789101112131415161718192021class Fruit(name: String) : Food(name)&#123; private val attributeMap = HashMap&lt;String, String&gt;() val color: String by attributeMap val size: String by attributeMap fun setAttributeMap(name: String, value: String)&#123; attributeMap.put(name, value) &#125;&#125;fun testDelegateMap()&#123; val fruit = Fruit(&quot;西瓜&quot;) fruit.setAttributeMap(&quot;color&quot;, &quot;绿色&quot;) fruit.setAttributeMap(&quot;size&quot;, &quot;2kg&quot;) println(&quot;color = $&#123;fruit.color&#125;, size = $&#123;fruit.size&#125;&quot;)&#125; 运行结果 color = 绿色, size = 2kg 小结类委托的本质是：把抽象方法的实现交给了by后的委托对象 属性委托的本质是：把属性访问器的实现交给了by后的委托对象 扩展函数也能实现属性委托 参考资料维基百科：惰性初始化模式 维基百科：惰性求值]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第五讲-Kotlin的类型和空处理]]></title>
    <url>%2F2018%2F06%2F03%2F2018%2FKotlin%E7%AC%AC%E4%BA%94%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 ##Kotlin的类型类型就是数据的分类，不同类型代表不同种类的数据。 Kotlin里类型分为：可空类型，非空类型，平台类型 ####对平台类型的理解平台类型：Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。 以字符串类型举例，字符串平台类型如下： String！ 程序员不能使用这种语法，Java代码转Kotlin代码的时候会出现，表示可控性未知，也可以理解为己有肯能是非空类型也有可能是可空类型 ####非空类型和可空类型的理解可空类型 = 非空类型 + null Type? = Type + null 因此，String？，String是两种不同的数据类型，就像Int和String是两种数据类型那般。 ###基本数据类型Kotlin不区分基本数据类型和包装类型，都是使用一种基本类型： 下面是非空基本类型 Char, Boolean, Byte, Short, Int，Long, Float, Double 可空基本类型 Char？, Boolean?, Byte?, Short?, Int?，Long?, Float?, Double? Kotlin的基本类型如果转成Java基本数据类型，要怎么办？ 对于变量、属性、参数和返回类型，Kotlin的基本类型会被编译成Java的基本数据类型。用作泛型类型参数的基本数据类型会被编译成对应的Java包装类型。 注意： 和Java不同，小范围的值不能自动转化为大范围的值，而是看成两种不同的类型 下面的代码演示了数据类型的表示，各类型转化，数据类型智能推断，字符串类型转成基本数据类型 1234567891011121314151617181920212223242526272829303132333435fun testBasicType() &#123; val bb: Byte = 127 val boolean = false val aa: Char = &apos;a&apos; var i: Int = 21_4748_3647 //10位 var l: Long = 922_3372_0368_5477_5807L //19位 //不存在小写的l val f: Float = 123f val f2: Float = 124F val a16 = 0x123ef3 val b16 = 0XcCCef3 val c2 = 0b1010 val cc2 = 0B11001 val b: Byte = 1 val eas = b + 1L //Long + Byte =&gt; Long , eas为Long类型 fun foo(l: Long) &#123; println(l) &#125; foo(44) //单独写44可能是byte，int long，这里智能推断44会被认为是long //字符串转基本数据类型 val p = &quot;44&quot;.toInt() val p2 = &quot;44&quot;.toLong() val p3 = &quot;44&quot;.toFloatOrNull() val p4 = &quot;44&quot;.toDouble() val translate = l.toInt().toLong().toFloat().toDouble().toInt()&#125; ###Any，Unit，Nothing类型 Any 相当于 Object，不同点：是非空类型，缺少Object的wait，notify方法 Unit相当于Java的Void；不同点：Unit是一个完备的类型，可以作为类型参数。Unit是Any的子类 Nothong表明函数不会有返回类型（没有返回类型），该函数不会正常终止，Nothing是Unit的子类 1234567891011121314151617181920212223242526272829303132fun getStrinLenght(s: String?): Int &#123; if (s == null) &#123; throw IllegalArgumentException() &#125; else &#123; return s.length &#125;&#125;fun fail(): Nothing = throw IllegalArgumentException()fun getStrinLenght2(s: String?): Int = if (s == null) &#123; fail() &#125; else &#123; s.length &#125;fun testAnyAndNothing(o: Any?): View &#123; val filterO = o ?: fail() return when (filterO) &#123; is View -&gt; &#123; View(&quot;View&quot;) &#125; is TextView -&gt; &#123; TextView(&quot;TextView&quot;, &quot;&quot;) &#125; else -&gt; &#123; fail() &#125; &#125;&#125; 可以认为：throw IllegalArgumentException()返回的类型是Nothing，nothing是Int的子类型。 ####小结Any，Unit和Nothing三者关系： A Whirlwind Tour of the Kotlin Type Hierarchy ##空安全相关的运算符 ###安全调用？.如果值是null，整个表达式的值为null。 12345678open class Company(val name: String, val address: String?)fun testNullType()&#123; val company = Company(&quot;京东&quot;, null) val length = company.address?.length println(&quot;length = $length&quot;)&#125; ###Elvis运算符 ？： 12345678910fun testElvis(list: List&lt;Company?&gt;?, defaultAddress: String?)&#123; val defaultAdd = defaultAddress ?: &quot;&quot; val length = defaultAddress?.length ?: 0 //.?为空调用，表达式返回null，遇到了？： println(&quot;defaultAdd = $defaultAdd, length = $length&quot;) val companyList = list ?: throw IllegalArgumentException(&quot;null list&quot;) val address = companyList[0]?.address?.toUpperCase() ?: defaultAddress //多重空安全调用和Elvis联合使用 println(&quot;address = $address&quot;)&#125; ###安全转换as?as？运算法尝试把值转换成制定的类型，如果值不是合适的类型就返回null。 1234567891011121314151617181920212223open class View(val name: String)class TextView(name: String, val text: String) : View(name)fun testAsClient()&#123; val company = Company(&quot;JD&quot;, &quot;亦庄&quot;) testAs(company) testAs2(company) val tv = TextView(&quot;TextView&quot;, &quot;I am a message content&quot;) testAs2(tv)&#125;fun testAs(o: Any)&#123; val tv = o as TextView println(&quot;name = $&#123;tv.name&#125;&quot;)&#125;fun testAs2(o: Any)&#123; val tv = o as? TextView ?: TextView(&quot;Default TextView&quot;, &quot;&quot;) println(&quot;The content of $&#123;tv.name&#125; is = $&#123;tv.text&#125;&quot;)&#125; ###非空断言 !! 把任何值转换成非空类型 12345678910fun testNoNullClient()&#123; val result = testNoNull(&quot;Kotlin&quot;) println(&quot;result = $result&quot;)&#125;fun testNoNull(s: String?) : String&#123; val length = s!!.length println(&quot;$s&apos;s length is $length&quot;) return s!!.toUpperCase()&#125; ###let函数 把可空值作为实参传递一个只接收非空值的函数 1234567891011121314151617fun testLet()&#123; val length = getTheBigCompanyInTheWorld().address?.length val upperCase = getTheBigCompanyInTheWorld().address?.toUpperCase() val letter = getTheBigCompanyInTheWorld().address?.get(0) println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;)&#125;fun testLet2()&#123; getTheBigCompanyInTheWorld().address?.let &#123; val upperCase = it.toUpperCase() val length = it.length val letter = it[0] println(&quot;address&apos;s length is $length , uppercase = $upperCase, letter = $letter&quot;) &#125;&#125;fun getTheBigCompanyInTheWorld(): Company = Company(&quot;JD&quot;, &quot;Beijing&quot;) ###可空类型的扩展函数 允许接收者为null的调用，在扩展函数内部处理null。不需要安全调用了 看几个Kotlin标准库，String定义的扩展函数isNullOrEmpty 123public inline fun CharSequence?.isNullOrEmpty(): Boolean &#123; return this == null || this.length == 0&#125; 注意： 在Java中，this永远是非空的，在Kotlin中，this可以为null。 因此在定义扩展函数时，需要考虑扩展是否需要为可空类型定义。本质上是对null在哪个环节处理的思考，是要在调用时使用空安全调用处理呢，还是在调用的函数内部处理。 ###泛型参数默认是可空类型 1234567fun &lt;T&gt; myPrintln(t: T)&#123; println(t.toString())&#125;fun testGenericityClient()&#123; myPrintln(null)&#125; ###转Java代码为Kotlin代码时，对空的处理 ####带注解的Java变量翻译到Kotlin时被认为是可空类型或者非空类型 Javax.annotation包下 android.support.annotation包下 org.jetbrains.annotations下 @Nullable + Type = Type?@NotNull + Type = Type ##参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第四讲-Kotlin的类、对象和接口]]></title>
    <url>%2F2018%2F05%2F27%2F2018%2FKotlin%E7%AC%AC%E5%9B%9B%E8%AE%B2-Kotlin%E7%9A%84%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 类类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等 类的构造方法的完整逻辑过程先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。 为了简化，Kotlin支持步骤2和步骤1合并操作，在主构造函数参数前加var/val； 支持步骤3和步骤2合并，对定义的属性直接赋值。支持步骤3和步骤2和步骤1合并操作，使用主构造函数的默认参数表达。 当然这些合并带来简便的同时，降低了构造的能力。 最初的状态（步骤1，步骤2，步骤3都存在） 123456789class User(_sickName: String)&#123; val sickName: String init &#123; println(&quot;init&quot;) sickName = _sickName &#125;&#125; 步骤2和步骤1的合并，在主构造函数里传参和定义类的属性 123456class User(val sickName: String)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 步骤3，步骤2和步骤1的合并 123456open class User private constructor(val sickName: String = &quot;Kotlin&quot;, var age: Int)&#123; init &#123; println(&quot;init&quot;) &#125;&#125; 注意：Java中需要重载构造方法的场景大多数都被Kotlin参数默认值和参数命名的语法特性涵盖了 子类的构造方法 123456789101112131415 open class AirBook(name: String, val year: Int, val size: Int) &#123; constructor(name: String, year: Int) : this(name, year, 22)&#123; println(&quot;constructor&quot;) &#125;&#125; class MacBookPro: AirBook&#123; public constructor(name: String, year: Int) : super(name, year) &#123; &#125; public constructor(name: String, year: Int, size: Int) : super(name, year, size)&#123; &#125;&#125; 子类在创建的时候，必须调用父类的构造函数，如果其父类还有父类，仍然要调用父类的父类的构造函数，直至顶层的基类。 12345678open class AirBook(name: String, val year: Int, val size: Int)&#123; init &#123; &#125; constructor(name: String, year: Int) : this(name, year, 22)&#123; &#125;&#125; 构造函数可以调用当前自身的构造函数，因为自身的构造函数必然有至少一个调用了父类的构造函数。 属性访问器在kotlin里，一个属性 = 字段 + 属性访问器；这里的字段是Java里的成员变量 属性访问器分为读访问器getter，和写访问器setter 访问器里存在field字段，用来连接写访问器和读访问器，作为两者的通信桥梁 val修饰的属性只有读访问器，var修饰的属性既有有读也有写访问器 Kotlin引入属性访问器后，凡事对属性进行赋值操作，就会调用属性的写访问器setter；读取值的操作对应调用的是属性的读访问器 那么如果我们要自定义一个类似Java里的setter方法，要怎么做呢？ 通过var变量的私有setter来实行 代码如下: 12345678910class TableLamp(val name: String, lightness: Int)&#123; var lightness: Int = 1 private set fun setupLightness(lightness: Int)&#123; this.lightness = lightness println(&quot;setupLightness lightness = $lightness&quot;) &#125;&#125; 这样对属性lightness的修改，只能通过setupLightness方法。 修饰词final, open, abstract相互影响和使用Kotlin的函数，类默认是final的，如果想重写函数，类有子类，则需使用open修饰。abstract修饰的函数和类，意味着有open的特性。这和Java的用法是一致的。 Kotlin自带的特殊类数据类，嵌套类，内部类，密封类的基本写法这里就略去不谈。 数据类datadata修饰的类，必须有主构造函数，且主构造每个入参必须都val或var修饰 data修饰补充的方法里的所用的变量取决于主构造函数的入参 嵌套类和内部类定义在某个类内部并用inner修饰的类称为内部类 嵌套类可以类比Java的静态内部类，Kotlin的内部类类比Java的内部类，他们含有外部类的引用。与Java内部类不同的是，Kotlin的内部类能对外部类的变量进行写操作。 举个例子 123456789class TextView&#123; var counter: Int= 0 inner class Operator&#123; fun calculate()&#123; counter ++ &#125; &#125;&#125; 内部类Operator的成员函数可以写外部类的counter属性，这在Java里是做不到的。 密封类sealed关键词修饰的类，表达有限个子类。 123456789sealed class Color constructor(val name: String)class Red : Color(&quot;Red&quot;)class Green : Color(&quot;Green&quot;)class Blue : Color(&quot;Blue&quot;)class Gray : Color(&quot;Gray&quot;) 上述写法，编译器就会知道，Color的子类的数量，此例Color一共只有四个子类，分别是：Red，Green， Blue， Gray。如果增加或删除Color的子类，编译器是能感知到的。密封类的子类可以作为嵌套类，也可以写在密封类所在的文件里，但是不能写在其他文件里。 举个和When搭配的应用例子： 12345678910111213141516171819fun testSealed(color: Color): Int = when (color) &#123; is Red -&gt; &#123; println(&quot;Red&quot;) 1 &#125; is Green -&gt; &#123; println(&quot;Green&quot;) 2 &#125; is Blue -&gt; &#123; println(&quot;Blue&quot;) 3 &#125; is GRAY -&gt;&#123; println(&quot;GRAY&quot;) 4 &#125; &#125; 密封类的意义：如果不用密封类，使用when总是不得不添加一个默认分支。更重要的是，如果你添加了一个新的子类，编译器并不能发现有地方改变了。如果你忘记了添加一个分支，就会选择默认的选项，这可能导致潜在的bug。 使用密封类就能解决上述的问题。 Object的使用声明一个类并创建一个对应的实例。与类一样，对象可以包含属性，方法，初始化语句块等的声明。对象声明可以继承类和实现接口，尤其不包含状态的时候很适用，也可以有扩展函数。 对象声明创建单一的实例，对象声明在定义的时候就创建了，不需要在代码的其他地方调用构造方法。 因此，对象声明不允许有构造函数。 123456object NameComparator : Comparator&lt;String&gt;&#123; override fun compare(o1: String, o2: String): Int &#123; return o1.compareTo(o2, true) &#125;&#125; Java调用上述代码，则需要通过INSTANCE来调用，如下 1CaseInsensitiveFileComparator.INSTANCE.compare(&quot;abc&quot;, &quot;abe&quot;); 伴生对象创建单一的实例，可以实现Java里访问类的私有成员的静态方法 在对象声明的基础上，使用companion关键字来标记，这样做就获得了直接通过容器类名称来访问这个对象的方法和属性的能力。 举个例子，实现CarFactory工厂 通过对象声明的实现 1234567891011class CarFactory&#123; object Instance&#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.Instance.newCar(&quot;Mini Cooper&quot;) 通过伴生对象的实现 1234567891011class CarFactory&#123; companion object &#123; fun newCar(name: String): Car&#123; return Car(name) &#125; fun newRedCar(name: String): Car&#123; return Car(name, Red()) &#125; &#125;&#125; 调用 CarFactory.newCar(&quot;Mini Cooper&quot;) 对象表达式既然是表达式，就意味着有返回值 与Java的匿名内部类只能扩展一个类或者实现一个接口不同，Kotlin的匿名对象可以实现多个接口或者不实现接口。 与对象声明不通，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。在对象表达式里不经可以访问创建它的函数中的变量，还可以修改变量的值 举个例子 12345678910fun countClick(view: View)&#123; var clickCount = 0 view.addClick(object : IClick&#123; override fun onClick() &#123; clickCount ++ &#125; &#125;)&#125; 小结object对象在Kotlin中的意义： 实现Java里静态的功能，等效实现静态调用 代替Java匿名内部类书写 接口123456789interface IFocus &#123; val focusName: String fun showOff()&#123; println(&quot;IFocus foucusName length = $&#123;focusName.length&#125;&quot;) &#125; fun onFocus()&#125; IFocus接口声明函数，让子类实现，默认方法showOff，和抽象方法onFucus 123456789class View : IFocus&#123; override val focusName: String get() = &quot;View&quot; override fun onFocus() &#123; showOff() &#125; &#125; View实现IFocus接口，focusName由View来确定，获取focusName逻辑写在IFocus的默认方法里。调用如下 val view = View() view.onFocus() 调用返回内容 IFocus foucusName length = 4 其他访问权限修饰词protected在Kotlin和Java的区别kotlin中protected只能是其子类和自身才能访问；Java中则是同包下所有文件和不同包的子类能访问 Kotiln访问权限由小到大排列依次是：private, protected, internal, public Kotlin函数和属性默认是public的，Java的默认是包级访问范围，即同一个包下的类能访问。Kotlin缺少包级别访问控制，而多了一个模块访问范围internal。internal表示同一个项目模块下的类都能访问 参考资料Kotlin实战]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第三讲-拓展函数及其他]]></title>
    <url>%2F2018%2F05%2F07%2F2018%2FKotlin%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 集合的创建与遍历Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。 创建集合Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。 1234567891011121314151617181920212223242526public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123; override fun add(element: E): Boolean override fun remove(element: E): Boolean override fun addAll(elements: Collection&lt;E&gt;): Boolean public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean override fun removeAll(elements: Collection&lt;E&gt;): Boolean override fun retainAll(elements: Collection&lt;E&gt;): Boolean override fun clear(): Unit public operator fun set(index: Int, element: E): E public fun add(index: Int, element: E): Unit public fun removeAt(index: Int): E override fun listIterator(): MutableListIterator&lt;E&gt; override fun listIterator(index: Int): MutableListIterator&lt;E&gt; override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;&#125; MutableList接口提供了增加和删除集合元素的能力。 创建不可变集合val list = listOf&lt;String&gt;(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val letter = list[0] var list1 = listOfNotNull&lt;Int&gt;(1, 4, 8) 创建可变集合val list2 = arrayListOf&lt;Int&gt;(1, 2, 3, 4) list2.set(0, 10) list2[0] = 10 list2.add(5) println(&quot;list2 = $list2&quot;) val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.add(&quot;d&quot;) println(&quot;e = $list3&quot;) println(&quot;last element = ${list3.last()}&quot;) val list4 = mutableMapOf&lt;String, String&gt;(&quot;1&quot; to &quot;A&quot;, &quot;2&quot; to &quot;B&quot;) val list5 = mutableSetOf&lt;String&gt;(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;) 参数Kotlin的函数比Java函数强大的地方之一是入参可以有默认值，即默认参数； 在Kotlin调用函数时，可以指定入参的名称，即命名参数； 与Java不同，Koltin表示可变参数，不是参数后面加三个点，，而是在入参前加vararg关键词即可。Kotlin中存在一个展开运算符 – *（星号），它和可变参数搭配使用；作用是把一个数组展开成可变参数传入 详细说明，可看这篇文章Kotlin里的输入参数 顶层函数与属性 很多代码并不能归属到任何一个类中，有时一个操作对应两个不同的类的对象，而且重要性相差无几。 有时存在一个基本的对象，但不想通过实例函数来添加操作，让它的API继续膨胀。 在Java里，我们使用静态方法。Kotlin里没有static修饰词，它一种方式，使用顶层函数来实现相同的效果。 顶层函数实现一个功能，把集合中元素添加前缀，后缀，用分隔符间隔展示 在kt类里直接写 12345678910111213141516171819const val counter: Int = 0fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String ): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 顶层函数是包内成员，包内直接访问。若包外访问，需要import（IDEA等开发工具会为你自动import） 顶层函数是都是静态函数，默认函数所在的文件名加KT作为容器类，比如上述joinToString方法是在Example3_2文件名下的顶层函数，在Java里调用是时 Example3_2Kt.joinToString(collection, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;); 如果我想更改调用静态方法的容器类的类名为StringUtils，则需要在kotlin文件里添加 @file:JvmName(&quot;StringUtils&quot;) 这时候调用形式如下： StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 顶层属性counter就是顶层属性，等效于容器类的静态成员变量，即Java里如下写法 public static final int counter = 0; 拓展函数与属性拓展函数基本使用StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;); 每次调用上述实现的joinToString方法传入四个参数，有点多，我希望减少入参数量。StringUtils是工具类类名，工具类类名在整个调用过程中是不够高效的。达到优雅的途径之一就是做到高效而简洁。这个工具类具体是什么名字并不会影响这个函数的输入和输出，这个类名的意义是作为joinToString容器的标示，如果能把其中一个入参名作为类名，这个入参同时做两件事：传入自身到函数体里，作为调用的句柄名。 强大的Kotlin为我们实现了这样的能力：扩展函数。把上述方法生命为一个拓展函数，如下所示： 1234567891011fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;)&#123; val sb = StringBuilder() sb.append(prefix) for((index, element) in this.withIndex())&#123; if(index &gt; 0)&#123; sb.append(separator) &#125; sb.append(element.toString()) &#125; sb.append(postfix)&#125; 接收者类型：函数名前的类，上例Collection就是该扩展函数的接收者类型 接收者对象：接收者类的实例，上例this.withIndex方法的this指代的就是Collection对象，是该扩展函数接收者对象 这时候我们要使用joinToString方法，变成这样用了 val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) list3.joinToString(&quot;_&quot;, &quot;[&quot;, &quot;]&quot;) 导入范围需要进行导入扩展函数才能生效，好在开发工具为我们自动导入了。如果定义的扩展函数所在的类和其接收者类型的类在一个包下，可以不需要显式导入。 有一种情况，如果你定义的扩展函数名和其他包里定义的函数名相同，你需要导入全类名以示区分。还有另一种方式，通过as在导入的地方重命名扩展函数名 import sugarya.chapter3.joinToString as jts 这时候，就可以调用jts就相当于调用joinToString方法 扩展函数的本质和特性其实，Kotlin把上述代码翻译到JVM上运行时。拓展函数的本质是：把接收者对象作为第一个入参的函数。通常我们在顶层位置定义扩展函数，这样扩展函数就能被其他包的文件调用。因此，扩展函数并没有改变接收者类里的代码，扩展函数并不是类的一部分，它是声明在类之外的，却能像成员变量那般使用。 像成员变量那般使用，扩展函数和成员变量不是一回事，它们之间是有区别的 扩展函数不能访问私有或者受保护的成员，因为接收者对象只是静态方法的一个入参，这个入参有大的访问能力，扩展函数就是多大访问能力。 扩展函数不能被接收者类的子类重写／继承。前面说了，扩展函数只是静态方法，并不是真实的接收者里的成员，自然也就无法重写了。 对于第2点的理解，我们举一个例子 12345678910111213class Person(name: String, var age: Int) : Animal(name)//拓展定义是写在Example2_4.Kt文件里fun Animal.move()&#123; println(&quot;animal move&quot;)&#125;fun Person.move()&#123; println(&quot;Person move&quot;)&#125;val animal: Animal = Person(&quot;Kotlin&quot;, 5)animal.move() 输出结果： animal move animal.move是拓展函数，转化为静态方法是Example2_4.move(animal),所以，move方法调用的就是Animal类下的move。 扩展属性扩展属性是对扩展函数能力的弱化／简化使用。相当于Java里第一个参数是接收者对象的静态getter方法和setter方法。扩展函数和扩展属性搭配使用，在扩展函数里访问扩展属性。举个例子 val Animal.length: Int get() = this.name.length * 10 fun Animal.move(){ println(&quot;animal move ${this.length}&quot;) } 扩展函数的应用看几个扩展函数的应用例子 分割字符串有一个字符串“ab.cd12.ef”，需要分割成三部分：ab, cd12, ef 使用Java，我们很容易写成这样 String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;.&quot;); java里split（）方法入参的字符串表示的正则表达式，在正则表达式里“.”表示任意字符，所以，如果照上面所写，返回为空，找不到字符。 使用Java正确实现是： String msg = &quot;ab.cd12.ef&quot;; String[] strings = msg.split(&quot;\\.&quot;); Kotlin在此基础上，通过扩展函数扩展字符串方法，通过默认参数实现重载效果。 123456789101112131415161718192021/** * Splits this char sequence to a list of strings around occurrences of the specified [delimiters]. * * @param delimiters One or more strings to be used as delimiters. * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`. * @param limit The maximum number of substrings to return. Zero by default means no limit is set. * * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from * the beginning to the end of this string, and matches at each position the first element in [delimiters] * that is equal to a delimiter in this instance at that position. */public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123; if (delimiters.size == 1) &#123; val delimiter = delimiters[0] if (!delimiter.isEmpty()) &#123; return split(delimiter, ignoreCase, limit) &#125; &#125; return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map &#123; substring(it) &#125;&#125; Kotlin实现 &quot;ab.cd12.ef&quot;split(&quot;.&quot;) Kotlin里用Regex类表示正则，使用正则实现如下 val regex = Regex(&quot;\\.&quot;) val result = &quot;ab.cd12.ef&quot;.split(regex.toPattern()) 解析字符串在Kotlin变得更容易了，除了split，Kotlin还提供了其他方法，再看一个例子 解析文件路径解析一个文件路径：“/Users/mine/Documents/MyDocument/Photoes／546294_308008399296566_779316797_n.jpg”,获取目录路径，文件名，文件拓展名 Kotlin代码实现 val msg = &quot;/Users/mine/Documents/MyDocument/Photoes/546294_308008399296566_779316797_n.jpg&quot; val dirPath = msg.substringBeforeLast(&quot;/&quot;) val filePath = msg.substringAfterLast(&quot;/&quot;) val fileName = filePath.substringBeforeLast(&quot;.&quot;) val extendName = filePath.substringAfterLast(&quot;.&quot;) println(&quot;directory path = $dirPath, fileName = $fileName, extendName = $extendName&quot;) 输出： directory path = /Users/mine/Documents/MyDocument/Photoes, fileName = 546294_308008399296566_779316797_n, extendName = jpg 局部属性在Java里，函数的最小的作用域是在一个类里（private修饰的方法），而Kotlin引入局部函数–允许在函数里定义一个函数，让函数（方法）的最小作用域降到一个函数体里。提供更小粒度的复用，这样有什么意义呢？ 这样是有意义的。 没有局部函数的特性的Java语言里，对方法最小作用域的组织方式是这样的：一个复杂的类里有很多方法，当方法A里的代码行数很多时，通常拆分出几个新的方法a1，a2，a3等等，这些新的方法之间如果存在整体的逻辑关系，就能组合成一个内部类，a1，a2，a3是该内部类的方法。直接在A里新建内部类并调用即可。外部类的其他方法比如方法B也能方便的调用。 Kotlin局部函数提供了比上述Java更细致的代码组织方式：如果我们只在一个方法A里多次用到，这时候在方法A里，定义a1，a2，a3，在方法A里多次使用方法a1，a2，a3。这种方式相较于上面的内部类组织方式，带来的益处是降低定义内部类带来的语法开销。 对于什么时候引入局部函数，我们有了下述认识：当需要在方法粒度上多次调用一段逻辑时。具体的场景有，登录验证，表单数据校验。 中缀调用 对只有一个参数的函数使用中缀调用 中缀调用的函数，需要对其使用inflix修饰符 中缀不仅适用于成员函数也适用于扩展函数 举个中缀的例子 val pair: Pair&lt;String, String&gt; = &quot;a&quot; to2 &quot;A&quot; 上面的中缀调用是怎么定义呢？ infix fun &lt;T, V&gt; T.to2(v: V): Pair&lt;T, V&gt; = Pair(this, v) 三重引号的字符串三重引号字符串不仅在于避免转义符，而且可以包含任何字符，包括换行符。 看一个佛祖镇楼的例子 1234567891011121314151617181920212223 val bless = &quot;&quot;&quot; _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG &quot;&quot;&quot; println(bless) 这样控制台按原样格式输出佛祖图 小结这是Kotlin实战第三章涉及的所有知识点，结合自己的理解整理归纳成本篇文章。]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第二讲-初出茅庐]]></title>
    <url>%2F2018%2F04%2F05%2F2018%2FKotlin%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90%2F</url>
    <content type="text"><![CDATA[年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？ 年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。 同样表示变量var与val有什么区别？val = 加了final的变量 val message = &quot;Kotlin&quot; // final String message = &quot;Kotlin&quot;; var count = 0 val msg: String = &quot;Kotlin&quot; //value var count2: Int = 0 // variant val p = Person(&quot;Kotlin&quot;) p.name /* Q1 var与val什么区别？ val = 加了final变量 */ val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;) languageList.add(&quot;Go&quot;) 字符串模板类比Java Web JSP里的EL表达式 println(&quot;message = &quot; + message) println(&quot;message = $message&quot;) println(&quot;count = ${count}&quot;) println(&quot;language list size = ${languageList.size}&quot;) println(&quot;\$: ${count2}&quot;) 函数fun max(a: Int, b: Int): Int { if (a &gt; b) { return a } return b } fun max2(a: Int, b: Int) = if (a &gt; b) a else b 问题：表达式和语句有什么区别？ 表达式有返回值，语句没有。表达式可以包含在语句或表达式里。语句与语句之间是并列的 Kotlin常见的表达式有：if，when，try{}catch 关于Whenfun filter(a: Int) { when (a) { 0 -&gt; println(&quot;0&quot;) 1 -&gt; println(&quot;1&quot;) in 2..10 -&gt; println(&quot;in 2..10&quot;) !in 11..20 -&gt; println(&quot;! in 11..20&quot;) Integer.parseInt(&quot;21&quot;) -&gt; println(&quot;21&quot;) 22, 23 -&gt; println(&quot;22 , 23&quot;) else -&gt; println(&quot;else&quot;) } } fun filter2(x: Any) { when (x) { is Int -&gt; println(&quot;Int&quot;) is String -&gt; println(&quot;String&quot;) is Person -&gt; print(&quot;JavaPerson&quot;) } } fun filter3(x: Any) = when (x) { is Int -&gt; { val a = 3 &quot;Int&quot; } is String -&gt; { val b = &quot;&quot; &quot;String&quot; } else -&gt; { &quot;else&quot; } } fun filter4(x: Any) = when { x is Int -&gt; &quot;Int&quot; x is String -&gt; &quot;String&quot; else -&gt; &quot;else&quot; } } 关于Kotlin里的循环和迭代for (i in 0..5) { println(&quot;i : $i&quot;) } for(j in 0 until 5){ println(&quot;j : $j&quot;) } for(k in 5 downTo 0){ println(&quot;k : $k&quot;) } val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;, &quot;Go&quot;) for((index, value) in languageList.withIndex()){ println(&quot;index = $index, value = $value&quot;) } val languageMap = hashMapOf&lt;String, String&gt;(&quot;j&quot; to &quot;Java&quot;, &quot;k&quot; to &quot;Kotlin&quot;, &quot;g&quot; to &quot;Go&quot;) for((key, v) in languageMap){ println(&quot;$key : map value = $v&quot;) } 异常处理背景知识： Java异常继承自Throwable，分为两种 运行时异常RuntimeException，也叫非受检异常 受检异常 CheckedException Java处理异常有两种方式： try catch 捕获异常 throws抛出异常 先看下Java的例子 //非受检异常 private static void testRuntimeException() { int i = Integer.parseInt(&quot;!&quot;); } //受检异常 private void testCheckedException() { try { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } catch (FileNotFoundException e) { e.printStackTrace(); } } private void testCheckedException2() throws FileNotFoundException { FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;); } 从上面程序可知：Java强制要求开发人员处理受检异常. 常见的受检异常： Exception, FileNotFoundException, IOException, SQLException 常见的未检查异常： NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException 上述Kotlin下的代码如下： fun testRuntimeException(){ val i = Integer.parseInt(&quot;!&quot;) } fun testCheckedException(){ val fis = FileInputStream(&quot;/temp&quot;) throw IllegalArgumentException(&quot;&quot;) } 可知：与Java不同，对受检异常，Kotlin不强制开发人员处理。 小结对于异常，Kotlin与Java的不同之处如下： Kotlin不区分受检异常和非受检异常, 都不强制处理异常 Kotlin不存在throws，不允许抛出异常 当try{}catch{}作为表达式的使用时fun readNumber(){ val a = try { val c = &quot;&quot; Integer.parseInt(&quot;!&quot;) }catch (e: Exception){ e.printStackTrace() 0 } println(&quot;a = $a&quot;) } 关于枚举1234567891011121314enum class Season&#123; SPRING, SUMMER, AUTUMN, WINTER&#125;enum class Color(val r: Int, val g: Int, val b: Int)&#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0,0,255); fun rgb() = r * 255 * 255 + g * 255 + b&#125; 关于类和属性我们看下Java的 123456789101112131415161718192021222324252627public class Rectangle &#123; private final int width; private final int height; private final boolean isSquare; public Rectangle(int width, int height, boolean isSquare) &#123; this.width = width; this.height = height; this.isSquare = isSquare; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public boolean isSquare() &#123; return isSquare; &#125;&#125;``` 等效Kotlin实现 class Rectangle(val width: Int, val height: Int){ val isSquare get() = width == height}` Java中，成员变量就是一个字段，访问成员变量通过setter或者getter方法，相当于变量的访问器。Kotlin把这个概念作为语言层面的支持了。kotlin中每个属性，如果是val变量就自带访问器get(),如果是var属性则自带get()和set() 因此Kotlin中，一个属性 = 字段 + 访问器；这是Kotlin对Java语言的进化。 小结该文是对Kotlin实战一书第二章知识点代码的梳理和总结，完整代码，已上传到GitHub上，KotlinInActionExample 传送门]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin第一讲-输入参数]]></title>
    <url>%2F2018%2F03%2F22%2F2018%2F%20Kotlin%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下：本专栏的第一篇，分享下Kotlin里输入参数的特性 命名参数我们先来看一个需求：把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go） 我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下： 1234567891011121314151617181920212223242526272829public class SeparatorUtils &#123; /** * * @param collections 集合 * @param prefix 前缀 * @param separator 分隔符 * @param postfix 后缀 * @param &lt;T&gt; 集合泛型 * @return 分隔后的结果 */ public static &lt;T&gt; String separator(Collection&lt;T&gt; collections, String prefix, String separator, String postfix) &#123; Objects.requireNonNull(collections); StringBuilder sb = new StringBuilder(); sb.append(prefix); int size = collections.size(); int index = 0; for (T t : collections) &#123; sb.append(t.toString()); if(index &lt; size - 1)&#123; sb.append(separator); &#125; index ++; &#125; sb.append(postfix); return sb.toString(); &#125;&#125; private static void testSeparator(){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Java&quot;); list.add(&quot;Kotlin&quot;); list.add(&quot;Python&quot;); list.add(&quot;JavaScript&quot;); list.add(&quot;Ruby&quot;); list.add(&quot;Go&quot;); String separator = SeparatorUtils.separator(list, &quot;(&quot;, &quot;,&quot;, &quot;)&quot;); System.out.println(&quot;separator result = &quot; + separator); } 输出结果： separator result = (Java,Kotlin,Python,JavaScript,Ruby,Go) 这是一个完整的编码过程，来了一个需求，通过新增类和方法，在需要的地方，调用实现。需求被解决了，代码默默地在角落发挥着作用。 转眼三个月过去，团队里来了新人，他阅读到testSeparator方法；当读到SeparatorUtils.separator（）方法，对于传的四个参数代表什么含义，乍看之下他并不清楚，需要点进去读实现代码或者看注释说明才确切明白。那么还有没有更易于阅读的方式呢？Kotlin的命名参数能做到。 SeparatorUtils.separator方法用Kotlin重写如下： 123456789101112131415161718fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 调用joinToString方法可以这样 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) val s = joinToString(list, postfix = &quot;)&quot;, separator = &quot;,&quot;, prefix = &quot;(&quot;) println(&quot;s = $s&quot;) 上述即是命名参数，在调用处使用，形式为：参数名=参数值；这样的入参带来了两个便利： 便于阅读，按顺序阅读代码就能知晓方法参数的含义 调用时入参的位置可以任意（调用的入参顺序和定义的入参的顺序允许不一致） 这样看起来真不错的 默认参数定义函数时，给入参提供默认值，在调用处，如果不传入实参，则该参数使用默认值，可用于方法重载。例如对上述Kotlin代码的joinToString方法改变入参 12345678910111213141516171819@JvmOverloadsfun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;): String &#123; val sb = StringBuffer(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) &#123; sb.append(separator) &#125; sb.append(element) &#125; sb.append(postfix) return sb.toString()&#125; 在Kotlin调用joinToString（）支持如下，最后一个我们同时使用了Kotlin的命名参数和默认参数的特性。 val list = arrayListOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;Ruby&quot;, &quot;Go&quot;) val s = joinToString(list) val s2 = joinToString(list,&quot;,&quot;) val s3 = joinToString(list,&quot;,&quot;,&quot;[&quot;) val s4 = joinToString(list,&quot;,&quot;,&quot;[&quot;,&quot;]&quot;) val s5 = joinToString(list, prefix = &quot;[&quot;, postfix = &quot;]&quot;) 上述调用体现了方法重载，默认参数可提供方法重载的效果 上面出现的@JvmOverloads注解是用来做什么的呢？ 默认参数特性，使用是有前提的：用Kotlin定义函数，并在Kotlin代码里调用该函数。因此，如果在Java文件里调用Kotlin定义的joinToString方法，默认不支持默认参数特性的，也即方法重载失效。 @JvmOverloads提供了让默认参数特性在Java环境也得到支持。原理是：kotlin代码编译成java代码时，会增加增加下面的方法，这些正是Java方法重载。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class StringUtils &#123; public static final int count = 11; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix, @NotNull String postfix) &#123; Intrinsics.checkParameterIsNotNull(collection, &quot;collection&quot;); Intrinsics.checkParameterIsNotNull(separator, &quot;separator&quot;); Intrinsics.checkParameterIsNotNull(prefix, &quot;prefix&quot;); Intrinsics.checkParameterIsNotNull(postfix, &quot;postfix&quot;); StringBuffer sb = new StringBuffer(prefix); Object element; for(Iterator var6 = CollectionsKt.withIndex((Iterable)collection).iterator(); var6.hasNext(); sb.append(element)) &#123; IndexedValue var5 = (IndexedValue)var6.next(); int index = var5.component1(); element = var5.component2(); if (index &gt; 0) &#123; sb.append(separator); &#125; &#125; sb.append(postfix); String var10000 = sb.toString(); Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;sb.toString()&quot;); return var10000; &#125; // $FF: synthetic method // $FF: bridge method @JvmOverloads @NotNull public static String joinToString$default(Collection var0, String var1, String var2, String var3, int var4, Object var5) &#123; if ((var4 &amp; 2) != 0) &#123; var1 = &quot;,&quot;; &#125; if ((var4 &amp; 4) != 0) &#123; var2 = &quot;(&quot;; &#125; if ((var4 &amp; 8) != 0) &#123; var3 = &quot;)&quot;; &#125; return joinToString(var0, var1, var2, var3); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix) &#123; return joinToString$default(collection, separator, prefix, (String)null, 8, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection, @NotNull String separator) &#123; return joinToString$default(collection, separator, (String)null, (String)null, 12, (Object)null); &#125; @JvmOverloads @NotNull public static final String joinToString(@NotNull Collection collection) &#123; return joinToString$default(collection, (String)null, (String)null, (String)null, 14, (Object)null); &#125; public static final void testExtend(@NotNull Container $receiver) &#123; Intrinsics.checkParameterIsNotNull($receiver, &quot;$receiver&quot;); String var1 = &quot;call the container testExtend method&quot;; System.out.println(var1); &#125;&#125; 可变参数可变参数关键词：vararg(分别取variate和arguments前三个字母) 来看一个Kotlin的Collections类里的一个方法 123456/** * Returns a new [ArrayList] with the given elements. * @sample samples.collections.Collections.Lists.arrayList */public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt; = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true)) 调用 val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) arrayListOf入参数量可以任意多个 Java实现可变参数，在数据类型后面加三个点：… ，看下Java里的Arrays里的一个方法 12345@SafeVarargs@SuppressWarnings(&quot;varargs&quot;)public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 展开运算符 *把数组展开成一个一个元素。展开运算符常与可变运算符联合使用。比如这样： 12val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)val list = arrayListOf(*array) 我得到了一个ArrayList集合，集合里的元素是”a”, “b”, “c”]]></content>
      <categories>
        <category>Kotlin编程之旅</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对2016年的年度小结]]></title>
    <url>%2F2017%2F01%2F03%2F2016%2F2017-01-03%2F</url>
    <content type="text"><![CDATA[尽管这篇年度小结有点迟，但是却是非常必要的。 和去年相似，在写这篇小结之前，刚看完李笑来老师的书《把时间当作朋友》，书本里很多观点发人深省，醍醐灌顶，茅塞顿开。就我最后看的部分，做个简单的摘抄：尽管这篇年度小结有点迟，但是却是非常必要的。 和去年相似，在写这篇小结之前，刚看完李笑来老师的书《把时间当作朋友》，书本里很多观点发人深省，醍醐灌顶，茅塞顿开。就我最后看的部分，做个简单的摘抄： 从整体上看，人脉当然重要。不过针对个体来说，比人脉更重要的是他所拥有的资源。 翻看2015年年度小结，顺利完成了《Android开发艺术探索》一书的阅读，加深了对Gradle的使用和认知。 2016年安卓方面，有了如下更新： 进一步理解了MVC，MPV和MVVM的区别和使用，在android App中使用Clean－Architecture项目架构，在项目里使用RxJava（RxBus），Retrofit2.0， Dagger2.0。 在Google发布App，Material Design在App中的使用。 加入了一家一线互联网公司 2016年阅读了如下书籍： 操作系统－精髓与设计原理 第七版（半本） 黑客与画家（五星推荐） Android开发艺术探索 安卓设计模式－源码解析与实战（抽章节着看，目测不到半本） Gradle For Android 中文版 把时间当作朋友（李笑来著） 2016年上半年最大的收获是对当下热门的开源库的实践，下半年最大的变化就是加入了一家愿景远大的一线互联网公司，非常期待在这个广阔的平台上发挥自己的技术能力。 基于思考，接下来2017年的安卓学习重点和主题是：提高计算机基础素养。为此，计划阅读和学习的书籍（按时间顺序）如下： 深入理解计算机系统 &amp; 操作系统－精髓与设计原理 算法 第四版 Java编程思想 &amp; Effective Java 一本关于函数式 Java8学习的书 鸟哥的Linux私房菜基础学习篇 因此我把2017年度的学习分成三个阶段： 前四月学习计算机基础 5月到8月学习Java 后四月学习Linux 注：如果时间不够，就依次顺延到2018年上半年 2017年将是为以后进一步成长打好基础的一年，非常重要。2017年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用数组和链表实现自制的栈和队列]]></title>
    <url>%2F2016%2F12%2F22%2F2016%2F2016-12-22%2F</url>
    <content type="text"><![CDATA[数组和链表是常用的两种数据结构，在翻看了Stack类，Iterable接口，Iterator接口，Queue的Java源码后，尝试用数组和链表来自己实现一下栈和队列。 自己造过轮子后，实实在在的理解了轮子，才能真正深入的使用轮子。代码如下：数组和链表是常用的两种数据结构，在翻看了Stack类，Iterable接口，Iterator接口，Queue的Java源码后，尝试用数组和链表来自己实现一下栈和队列。 自己造过轮子后，实实在在的理解了轮子，才能真正深入的使用轮子。代码如下： 说明：Stackable是我自己写的接口 数组实现栈public class SugarArrayStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private static final int DEFAULT_CAPACITY = 2; private int N = 0; private E[] a; public SugarArrayStack() { resize(DEFAULT_CAPACITY); } public SugarArrayStack(int size){ resize(size); } private void resize(int size){ E[] temp = (E[])new Object[size]; for(int i = 0; i &lt; N; i++){ temp[i] = a[i]; } a = temp; } @Override public void push(E e){ if(N &gt;= a.length - 1){ resize(a.length * 2); } a[N++] = e; } @Override public E pop(){ E temp = peek(); a[--N] = null; if(N &gt;= 0 &amp;&amp; N == a.length / 4){ resize(a.length / 2); } return temp; } @Override public E peek(){ int index = N - 1; return a[index]; } @Override public int size(){ return N; } @Override public boolean isEmpty(){ return N == 0; } @Override public Iterator&lt;E&gt; iterator() { return new ArrayIterator(N); } private class ArrayIterator implements Iterator&lt;E&gt;{ private int currentIndex; public ArrayIterator(int currentIndex) { this.currentIndex = currentIndex; } @Override public boolean hasNext() { return currentIndex &gt; 0; } @Override public E next() { currentIndex--; return a[currentIndex]; } } } 链表实现栈队列public class SugarLinkedQueue&lt;E&gt; implements Iterable&lt;E&gt;{ private Node&lt;E&gt; mHeadNode; private Node&lt;E&gt; mTailNode; private int mCount = 0; public void enqueue(E e){ Node&lt;E&gt; newTailNode = new Node&lt;&gt;(e,null); if(mCount == 0){ mTailNode = newTailNode; mHeadNode = newTailNode; }else{ Node&lt;E&gt; oldTailNode = mTailNode; mTailNode = newTailNode; oldTailNode.nextNode = newTailNode; } mCount ++; } public E dequeue(){ if(isEmpty()){ throw new IllegalStateException(&quot;Please enqueue an element firstly&quot;); } mCount --; E tempE = mHeadNode.e; mHeadNode = mHeadNode.nextNode; return tempE; } public int size(){ return mCount; } public boolean isEmpty(){ return mCount == 0; } @Override public Iterator&lt;E&gt; iterator() { return new QueueIterator(mHeadNode); } private class QueueIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public QueueIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E currentE = currentNode.e; currentNode = currentNode.nextNode; return currentE; } } private class Node&lt;E&gt;{ private E e; private Node&lt;E&gt; nextNode; public Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 链表实现栈public class SugarLinkedStack&lt;E&gt; implements Stackable&lt;E&gt; ,Iterable&lt;E&gt;{ private Node&lt;E&gt; headNode; private int count = 0; @Override public boolean isEmpty() { return count == 0; } @Override public int size() { return count; } @Override public void push(E e) { count++; headNode = new Node&lt;&gt;(e, headNode); } @Override public E pop() { if(count &lt;= 0){ throw new IllegalStateException(&quot;please push an element firstly&quot;); } count --; E e = headNode.e; headNode = headNode.nextNode; return e; } @Override public E peek() { return headNode.e; } @Override public Iterator&lt;E&gt; iterator() { return new LinkedIterator(headNode); } private class LinkedIterator implements Iterator&lt;E&gt;{ private Node&lt;E&gt; currentNode; public LinkedIterator(Node&lt;E&gt; currentNode) { this.currentNode = currentNode; } @Override public boolean hasNext() { return currentNode != null; } @Override public E next() { E tempE = currentNode.e; currentNode = currentNode.nextNode; return tempE; } } private class Node&lt;E&gt; { private E e; private Node&lt;E&gt; nextNode; private Node(E e, Node&lt;E&gt; nextNode) { this.e = e; this.nextNode = nextNode; } } } 小结在实现过程中，产生了一些心得和感受，如下： 新建一个Java类，顺序是：先初始化成员变量，然后再调用它的构造方法。因此，某些场景上，一些操作是放在成员变量上还是放在构造方法里是有选择和考量的 链表这种数据结构天生包含迭代的编程思想，用递归来解决遇到的问题 数组这种数据结构使用索引访问元素（指针的使用感），操作数组序号来解决遇到的问题 用链表的实现，插入和删除元素的操作和元素数量多少没有关系。 深刻理解Iterator遍历原理，这个接口提供了集合遍历的逻辑封装，逻辑分为两个部分：hasNext方法和next方法。这两个方法合在一起产生出递归的效果，从而实现集合遍历 自制栈实践是时候使用自己造的轮子了 问题表述：给出一个字符串的算术表达式，求其值。比如“((( 10 + (34 - 24))*5)-(200/11))” 思路分析：用两个栈，一个保存运算符，一个保存操作数。将操作数压入操作数栈，将运算符压入运算符栈，忽略左括号，每遇到右括号，弹出一个运算符，弹出所需数量的操作数，计算后所得结果再压入操作数栈。 代码如下： public static void main(String[] args) { String expression = &quot;((( 10 + (34 - 24))*5)-(200/11))&quot;; float result = calculate(expression); System.out.println(&quot;result = &quot;+result); } private static float calculate(String expression) { if (expression != null &amp;&amp; expression.length() &gt; 0) { Stackable&lt;Character&gt; operatorsStack = new SugarArrayStack&lt;&gt;(); Stackable&lt;Float&gt; valueStack = new SugarLinkedStack&lt;&gt;(); StringBuilder sb = new StringBuilder(); char[] charArray = expression.toCharArray(); for (char c : charArray) { switch (c) { case &apos;(&apos;: case &apos; &apos;: break; case &apos;+&apos;: case &apos;-&apos;: case &apos;*&apos;: case &apos;/&apos;: pushNumberValue(valueStack, sb); operatorsStack.push(c); break; case &apos;)&apos;: pushNumberValue(valueStack, sb); Float firstPop = valueStack.pop(); Character operation = operatorsStack.pop(); float f; switch (operation) { case &apos;+&apos;: f = valueStack.pop() + firstPop; break; case &apos;-&apos;: f = valueStack.pop() - firstPop; break; case &apos;*&apos;: f = valueStack.pop() * firstPop; break; case &apos;/&apos;: f = valueStack.pop() / firstPop; break; default: throw new IllegalArgumentException(&quot;this operator haven&apos;t been supported now&quot;); } valueStack.push(f); break; default: sb.append(c); } } return valueStack.peek(); } return -1; } private static void pushNumberValue(Stackable&lt;Float&gt; valueStack, StringBuilder sb) { int length = sb.toString().length(); if(length &gt; 0){ float value = Float.parseFloat(sb.toString()); valueStack.push(value); sb.delete(0, length); } } 如上例子，最终输出的结果是： result = 81.818184 这种计算存在一些缺陷： 需要左右括号包装算术表达式 在一个括号里，只能进行两个操作数的计算 小结到此，我们用自己造的栈，实现了任意长度下的四则算术运算，今天的天气也比昨天格外得好了。 参考资料 算法 Algorithms Fourth Edition By Robert Sedgewick &amp; Kevin Wayne]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓下的刮刮卡摸奖的另一种实现]]></title>
    <url>%2F2016%2F12%2F16%2F2016%2F2016-12-16%2F</url>
    <content type="text"><![CDATA[实现思路网上有使用Xfermode来实现刮刮卡，这里提供另一种思路简洁的实现 一张呱呱卡有三层，最底层我用一个TextView控件显示中奖内容，中间层是刮完之后的显示图样，最上面一层是刮刮卡的封面。手指刮除封面的过程就是把刮刮卡最上面一层裁剪的过程。 实现思路网上有使用Xfermode来实现刮刮卡，这里提供另一种思路简洁的实现 一张呱呱卡有三层，最底层我用一个TextView控件显示中奖内容，中间层是刮完之后的显示图样，最上面一层是刮刮卡的封面。手指刮除封面的过程就是把刮刮卡最上面一层裁剪的过程。 涉及的知识点 canvas.clipPath(),Path类，Region.Op类 onDraw方法和onTouchEvent方法的配合 核心代码如下： public class LotteryView extends View { public static final int STROKE_WIDTH = 15; private float mEventX; private float mEventY; /** * 呱呱卡封面 画笔 */ private Paint mOverlayPaint; private RectF mRectBorder; /** * 呱呱卡边缘 画笔 */ private Paint mStrokePaint; private RectF mRectFill; private Path mClipPath; public LotteryView(Context context) { this(context,null,0); } public LotteryView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public LotteryView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { Bitmap lotteryOverlay = BitmapFactory.decodeResource(getResources(), R.drawable.icon_lottery_overlay); mOverlayPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mOverlayPaint.setShader(new BitmapShader(lotteryOverlay, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); mStrokePaint = new Paint(); mStrokePaint.setAntiAlias(true); mStrokePaint.setStyle(Paint.Style.STROKE); mStrokePaint.setColor(Color.BLACK); mStrokePaint.setStrokeWidth(STROKE_WIDTH); mClipPath = new Path(); } @Override protected void onDraw(Canvas canvas) { if (mRectBorder == null) { mRectBorder = new RectF(0, 0, getWidth(), getHeight()); } if (mRectFill == null) { mRectFill = new RectF(0, 0, getWidth(), getHeight()); } canvas.drawRoundRect(mRectBorder, 10, 10, mStrokePaint); if (mEventX != 0 || mEventY != 0) { mClipPath.addCircle(mEventX, mEventY, 50, Path.Direction.CW); canvas.clipPath(mClipPath, Region.Op.DIFFERENCE); } canvas.drawRect(mRectFill, mOverlayPaint); } @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getAction(); switch (action) { case MotionEvent.ACTION_MOVE: mEventX = event.getX(); mEventY = event.getY(); invalidate(); break; } return true; } } 布局里的使用 &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; &gt; &lt;TextView android:id=&quot;@+id/tv_lottery_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_centerInParent=&quot;true&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@android:color/darker_gray&quot; android:text=&quot;恭喜您，荣获2016年年度最佳程序员&quot; /&gt; &lt;com.sugary.roundimageview.LotteryView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; /&gt; &lt;/RelativeLayout&gt; 小结 刮刮卡的中奖内容是放在TextView控件，作为最底层显示。 如果项目里需要有刮卡完成后回调，可以计算刮除的面积与刮刮卡总面积的比例，超过一定值，即认为呱卡完成。 后续的优化方向可以是，把底层的TextView放到LotteryView自定义控件里]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的Gradle打包安全么]]></title>
    <url>%2F2016%2F12%2F11%2F2016%2F2016-12-11%2F</url>
    <content type="text"><![CDATA[现在Android项目的构建几乎都使用Gradle，Gradle提供了命令行打包，通过执行任务的方式，操作起来很方便。 通常Gradle打包的方式比如通常我们会如下这般处理：现在Android项目的构建几乎都使用Gradle，Gradle提供了命令行打包，通过执行任务的方式，操作起来很方便。 通常Gradle打包的方式比如通常我们会如下这般处理： signingConfigs{ release{ storeFile file(&quot;/xxx.jks&quot;) storePassword &quot;111&quot; keyAlias &quot;demo&quot; keyPassword &quot;222&quot; } } productFlavors { yingyongbao { //根据渠道需要配置参数 } } 这里我假设需要打应用宝的渠道包，在命令行窗口，或者直接在AS的Terminal窗口，进入到项目根目录，使用Gradle命令行打包： ./gradlew assembleYingyongbaoRelease 如果团队里有人用了Window系统提交，第一次使用Mac系统提交，很可能会遇到Permission Denied问题，解决办法：我的上一篇博文当Window遇到Mac OS出现Permission Denied／Could not expand时 更安全Gradle打包的方式上述方式打包是成功的，但是这里存在安全性问题： 安全隐患一：签名文件jks默认放在模块目录里，连同代码一起提交到服务器上，如果团队使用第三方的提交后台，安全隐患明显 安全隐患二:签名的密码，别名等内容直接暴露在build.gradle文件里 基于上述的考虑，下面是更安全的打包签名配置： signingConfigs { release { storeFile file(RELEASE_SIGNING_FILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD } } 在项目根目录gradle.properties文件里，存放签名信息 RELEASE_SIGNING_FILE = ../../xxx.jks RELEASE_STORE_PASSWORD = 111 RELEASE_KEY_ALIAS = demo RELEASE_KEY_PASSWORD = 222 然后在.gitignore文件里添加一条语句（不提交gradle.properties文件到服务器） gradle.properties 安全分析通过相对路径，我们把签名文件放在模块目录上二级，即和项目目同级，解决了安全隐患一 利用了gradle.properties文件里的键值对信息能直接在build.gradle中引用的方式，解决了安全隐患二 其他团队成员第一次使用这种配置打包的时候，需要本地更新自己的gradle.properties内容。 小结上述安全的Gradle打包，有一个前提是允许项目里的gradle.properties文件不上传到服务器。有的团队，安卓项目因为一些特殊原因非得需要上传gradle.properties文件呢？那就只有自己新建一个.gradle文件存储签名信息了，详见kevin_nazgul的android签名文件存放的另一种方式 参考资料： Gradle for Android By Kevin Pelgrims stackoverflow：How to create a release signed apk file using Gradle?]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Window遇到Mac OS出现Permission Denied／Could not expand时]]></title>
    <url>%2F2016%2F12%2F09%2F2016%2F2016-12-09%2F</url>
    <content type="text"><![CDATA[12月8日，在北京国家会议中心（奥林匹克公园），一场谷歌技术狂欢，刚参加完，感觉很赞，简短纪录下。12月8日，在北京国家会议中心（奥林匹克公园），一场谷歌技术狂欢，刚参加完，感觉很赞，简短纪录下。 本次大会活动有三个部分： 开幕式和七个分会场的技术演讲。内容包含Android，Daydream，Tango，Firebase，Angular，TensorFlow等等。同一个时间段不小心出现了多个都想听的演讲主题，那就只好取舍了一番（会后看录像视频） 谷歌新技术体验馆。现在总结，感觉听演讲的时间没必要那么多，可以抽更多的时间在体验馆上感受谷歌产品和技术。 休息区，散落的小游戏小抽奖，免费自助午餐，下午茶，Party晚宴。这部分真心赞，明年继续参加。 开幕式之后，关注和听了如下专题： Android Studio2.0/2.1/2.2的新功能。会上我问了一个问题,Android应用开发，一直以来都用Java，谷歌会打算变动语言或者有这样的安排么？演讲嘉宾叫胡坤，他回答谷歌没有这样的安排。不过我想，即使有，这样的高层决定，估计也不是中国片区的人能最早知道的，即使知道了，也不会在不合适的时间点对外公布。 Android support library最新变化。讲的很快，更多是知道有什么变化，也漏说了一些，实际开发需要的很多细节，需要自己动手。还有，新版的Support Library拆成多个独立的模块板，开发者可以根据需要单独引用依赖。 Android电池和内存优化。这部分演讲嘉宾从Android 6.0/7.0电池和系统特性，给出了开发建议，具体的代码的实现和tips建议说得很快，但还是有干货。 Daydream介绍，入门说明和讲解。直接体验感觉更深刻 Tango简介，我的理解是谷歌开发的一套算法并提供了调用的API接口，提供给开发者增强现实技术所需的计算和分析结果。如何动手开发一款Tango应用，在谷歌开发文档上有仔细的讲解，文末给出链接了。当然前提是需要有一款支持Tango的手机。 WebApp的未来 在优酷谷歌开发频道和其微博能看到这次大会的视频，视频内容相当详尽了。 google／Android官方网站和资源：（推荐） Google Developers中国网站 优酷Google开发频道视频 谷歌中国的官方微博（新浪微博） 另外谷歌也开通了微信公众号，这个也是很好的渠道了解谷歌（尤其是在中国的）最新动态]]></content>
      <categories>
        <category>技术活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Window遇到Mac OS出现Permission Denied／Could not expand时]]></title>
    <url>%2F2016%2F11%2F30%2F2016%2F2016-11-30%2F</url>
    <content type="text"><![CDATA[最近用gradle打包安卓新项目时 ./gradlew assembleRelease 出现Permission Denied提示 错误场景最近用gradle打包安卓新项目时 ./gradlew assembleRelease 出现Permission Denied提示 在检查gradle配置信息无误后，使用管理员权限打包 sudo ./gradlew assembleRelease 这样能顺利打包，不过使用debug调试模式编译项目时，依然报错：Could not expand…我遇到的错误忘记记录了，大概类似如下的错误： Execution failed for task &apos;:app:prepareComAndroidSupportAppcompatV71901Library&apos;. Could not expand ZIP &apos;/opt/android-sdk/extras/android/m2repository/com/android/support/appcompat-v7/19.0.1/appcompat-v7-19.0.1.aar&apos;. 错误分析遇到这样的情况，十有八九因为团队成员用了不同的操作系统开发，特别是，有人用Window开发，有人用Mac开发，git版本管理下，这两个操作系统对文件权限的管理方式是不同。 解决该错误，涉及到的操作有： 查看项目目录权限ls -l yourFilePath 我对一个安卓项目的根目录查看了权限，显示结果如下： drwxr-xr-x 24 sugarya staff 816 11 3 16:12 Ferrari 这里第一个字母d表示文件类型，r表示可读，w表示可写，x表示可执行 修改项目目录权限Mac上鼠标操作右键要修改的目录，点击显示简介，底部有一栏共享与权限，列出了该目录的权限情况，手动修改之。 用文字设定法chmod [who] [+ | - | =] [mode] 文件名? ，详细情况可阅读参考资料 用数字设定法假定要修改的目录为当前路径下名为myDirectory的文件夹 sudo chmod -R 777 myDirectory 如此myDirectory目录的权限就改为drwxrwxrwx，即该用户，同组用户以及其他用户都具有写、读、执行的权限 小结权限修改完成后，再次使用gradle打包，一切变得顺利了 参考资料： mac os x 文件权限管理 如何设置文件夹权限为777 mac os x系统下 chmod +x comdfile StackOverFlow：gradlew:Permission Denied]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓App项目开发的几点认识]]></title>
    <url>%2F2016%2F11%2F22%2F2016%2F2016-11-22%2F</url>
    <content type="text"><![CDATA[团队多人开发下项目第一级目录按功能模块划分，二级分类按控件划分。这个原则对res目录下的values目录同样适用。也即：colors，strings，dimens，atrr，style文件要创建多个，用功能模块分类，这样提交代码时，方便审核，较少提交冲突。对需要相互依赖的文件，统一放在一个目录下集中体现 团队多人开发下项目第一级目录按功能模块划分，二级分类按控件划分。这个原则对res目录下的values目录同样适用。也即：colors，strings，dimens，atrr，style文件要创建多个，用功能模块分类，这样提交代码时，方便审核，较少提交冲突。对需要相互依赖的文件，统一放在一个目录下集中体现 跳转逻辑一部分放在Navigator静态类里，一部分逻辑封装到BaseActivity的Protect方法（如果所有逻辑都封装在父类，增加了父类负担，代码可读性降低） 约定思维接口定义，泛型的使用位置，方法入参，返回数据这些都体现着约定思想，谁调用我，就要按我的约定规则来。约定规则怎么写才能表示约定人的意图呢？这要用到约定规则的规则Java语法和使用。学好Java才能让程序员充分表达自己的逻辑和意图。 RxJava操作符：创建型： create,just,from, range,interval combineLatest concat(多个流按顺序串行发射),merge（多个流交叉合并成一个流发射）,zip（多个流合并成一个流后统一发射） 处理型： map,flatMap(交叉发射),concatMap（串行发射） repeat，take，takeLast first（只发射满足条件的第一个），single（只发射顺序为第一个的数据源） debounce(发射最后一次) concatWith skip（N） 抑制Observable发射的前N项数据 merge(count,skip)每接收到count个数据后，将该count的个数据打包，并跳过第skip个数据，发送给订阅者 RxLifecycle使用Github主页 RxJava 中 merge, contact,compose 区别 RxJava操作符之takeUntil 带你学开源项目：RxLifecycle-当Activity被destory时自动暂停网络请求 Java中，父类和子类如何配合，以实现一个完整逻辑父类盛放共有的，具体的，稳定的的变量和方法，子类相对于父类具有拓展能力和行为，不同子类有不同方法 明确谁是导演类（Director Class，顶层的导演类也称为客户端类，用这样的方式划分体现类与类的调用关系） 如果是父类是子类的导演，父类调用子类，则子类实现父类的抽象方法或者重写Protected方法。此时，站在父类角度看：模块逻辑的执行顺序在父类里规划，站在子类的角度看：子类是具体逻辑的战场，父类是援军，父类在调用是，把自己的变量（援军）通过方法参数传给子类，具体逻辑的实施（战场）在子类方法里。 如果子类是父类的导演，子类新的方法里调用父类的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 下]]></title>
    <url>%2F2016%2F10%2F30%2F2016%2F2016-10-30%2F</url>
    <content type="text"><![CDATA[现状无法马上摆脱人们往往低估环境的巨大能量。尽管天赋确实很重要，但一个人能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间，只要足够认真，努力，他的能力就会不停地积累。每一时刻的现状都是过去某一或者某些时刻的结果。而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。 现状无法马上摆脱人们往往低估环境的巨大能量。尽管天赋确实很重要，但一个人能力主要靠积累获得。从一个人开始从事一个职业的那一瞬间，只要足够认真，努力，他的能力就会不停地积累。每一时刻的现状都是过去某一或者某些时刻的结果。而每一时刻的现状都是未来某一或者某些时刻的原因。没有人能够逃脱现实的束缚。 对现状的不满，急于摆脱现状，是人们常常不知不觉落入的陷阱（尽管偶尔这也是少数人真正的动力）。接受现状才是最优策略：有什么做什么，有什么用什么；做什么都做好，用什么都用好。不要常常觉得苦（这会让人顾影自怜，浪费精力和时间），而要想办法在任何情况下找到情趣，快乐是一种本事。 优秀的年轻人几乎都有这样的特征：很少对现状不满，热爱自己的生活，相对更不在意外界的影响，更专注于做事而心无旁贷，身处良性循环之中。 怎样判断所做的事情是否正确？核心只有一个：看它是否现实。 把时间当作朋友 第三章传送门 侯世达定律：完成一个任务实际花费的时间总会超过计划花费的时间，就算制定计划的时候考虑到本法则。 要提高估算时间的能力，就要从现在开始养成习惯：做任何事情之前先判断其熟悉程度（或陌生程度），再据此判断估算完成任务所需要的时间。 及时行动所谓做事拖延，不是拖延着做事，而是拖延着不开始做事。 拖延的人为什么迟迟不开始行动？错误的估算所需的时间来自内部的恐惧只要开始做事，一个人就要面临做错，做不好的风险。拖延症患上一个简单的认知错误：认为哪些能够做对做好的人都是直接做对，做好的。很多人做事拖延不过是“不求有功，但求无过”的心态在作祟。而现实是：只要做事，就一定会出问题。 做事情的时候，肯定会遇到困难，事情越有价值，困难就越具规模。遇到困难的时候，心平气和地面对就好，因为这只不过是生活常态。 有时我们花费了很多时间和精力依然没能解决问题，却眼见别人轻松过关，这确实令人气馁。不过这也是生活常态：在任何一个特定领域，总会有一些人比另一些人表现更好，费力更少。 接受现实，勤能补拙。 来自外部的恐惧这段的描述太好了，忍不住要站立鼓掌。 过分在意外界的评价。人是一种很有趣的动物，在自己作对，做好之前，通常已经了解作对，做好是什么样子。于是，无论能否作对，做好，人都觉得自己有能力判断别人是否作对做好。所以，尽管自己不怎么样，却可以振振有词、理直气壮地评价别人做得对不对、好不好。因此，可以得出一个推论：一个人一旦开始认真做事，被嘲弄、被耻笑的几率将远远高于被夸奖、被鼓励的几率。 那些真正能够作对、做好的人，绝不会随意嘲弄、打击别人，因为他们是做对过、做好过的人，他们一路走来，心理非常清楚作对、做好有多么不易，所以，他们会不吝一切机会去鼓励那些尝试做事情的人。 如果一个人经常嘲弄他人，那只能说明他自己不怎么样；否则，他会像那些极少数已经做对、做好的人一样，给予别人真诚而非嘲弄。也有时候，那些能真正做对、做好的人也会给出负面评价，但那通常都是“建设性的负面评价”，并不是为了获得优越感而发出的嘲弄。 没有谁一开始就能做对、做好。所有做对，做好的人都是一路磕磕绊绊走过来的，这就是生活的常态 动辄给出非建设性负面评价的人，往往不是正经做事的人，他们和那些正经做事的人身处不一样的世界，这也是生活的常态。 为什么随着年龄的增加每个人都会觉得时间过得越来越快？对一个5岁的孩子来讲，未来的1年相当于他已经度过的人生的¹⁄₅，即20%；而对一个50岁的成年人来讲，未来的1年只相当于他已经度过的人生的¹⁄₅₀，即2%。所以，随着年龄的增加，人们会觉得时间运动得越来越快。 小结几乎一切愚蠢的行为都来自否定现实，逃避现实。时间是现实的人的朋友，是不现实的人的敌人。 最后期限不是固定在将来某一个点，而是朝着你加速扑来。如果在起步晚了的情况下，问题不是“到时候能不能做好”，而是“到时候能做多好就做多好，总好过什么都不做”。所以，不管遇到什么任务，最好的开始时间就是：现在]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当作朋友 上]]></title>
    <url>%2F2016%2F10%2F28%2F2016%2F2016-10-28%2F</url>
    <content type="text"><![CDATA[近来休息了一段时间，期间也看了几本闲书。比如魔天记，真灵九变这类网络小说；比如杨冰阳女士（ayawawavip）的完美关系的秘密，讲述两性关系的相处。原本希望通过这本书让自己不仅是能深耕的好码农，还能是把妹届的老司机。近来休息了一段时间，期间也看了几本闲书。比如魔天记，真灵九变这类网络小说；比如杨冰阳女士（ayawawavip）的完美关系的秘密，讲述两性关系的相处。原本希望通过这本书让自己不仅是能深耕的好码农，还能是把妹届的老司机。 最近在看的是，笑来老师的把时间当作朋友，大赞，是价值观的更新，我做了读书摘要和思考。 技术的速成是不可能的时间不可管理，为什么大家都想要速成呢？ 这是人们追求收获的欲望当达不到不劳而获的时候，少劳多获也是可以接受的。如果收获的可能性很大，我们就会想尽快看到结果；如果收获的可能性很小，我们就会想尽快知道结果。 很多时候我们不清楚某些“阶段”不可省略事物的成长需要时间，成驻败空，缘起性空，因缘和合，这些阶段是客观存在。怀胎十月，才有健康的宝宝诞生人间。接受这个客观的过程，技术的进步也是。 基于对“现状”的不满意有时候，我们意识里知道上诉两个道理，但是为什么还会想要尝试速成，去抓住那个万一成功了呢。源于对当下现状的不满意，想要去改变。 笑来老师书里引用了一位老外的的统计分析研究，对人一生各个阶段满意感的分布。发现，从15岁左右开始，人的满意感一直在下降，直到50，60岁后开始上升。这个挺有趣的想象，也可以用来解释某些人产生“中年危机”感的心里诱因。 完美永不存在。笑来老师如是说： 没有什么事情是一下子就能做好的。我们至多能做到接近完美，或者更接近完美。所以，不管做什么事情，都需要时刻忍耐各种的不完美，否则事情根本无法完成。最终完成的事情，结果也常常是不完美的。缺陷必然存在。再往大一点说，生活本省就不完美。谁的生活不是磕磕绊绊？谁死去的时候没有一丝遗憾？现实如此，只能接受。* 这段话的意思，我可以概括为：因上精进，果上随缘。没有结果是完美的，但是不妨碍我们在追求的路上努力做到最好。 未知永远存在笑来老师如是说： 我们害怕未知，害怕不确定的东西。我们希望一切都在自己的掌握之中，只是我们永远做不到。随着未知因素数量的增加，有序排列可知，这些因素所引发的结果的数量将以几何级数的方式飞速增加。* 在自学一项技能的时候，存在一种“牛角尖陷阱”，为此，我们必须忍受一定的未知。承认自己不可能全知全晓，因为客观存在一些情况，如：有些时候有些问题没有答案（先有鸡还是先有蛋），即便有些问题有了答案，其原因也不见得我们能够搞懂（顺序，分支，循环就能够完成任何流程控制）在这种情况下，暂时不去问为什么，可能更划算* 学习一门新课程，会发现，第一章的内容需要在掌握后面某一章知识之后才能深入了解。在学习第一章的时候，我们会有无数疑问以当时的知识是无法全部解答的，需要我们继续学习，用接下来的知识解答现在的疑问。* 我可以类比，推而广之。比如父母老师教导的行为，小时候不以为然，觉得枯燥，无聊无用，长大后，才恍然醒悟。因此，对于经典的，历来传颂的事物和行为，与其现阶段搞不明白的情况下非要弄明白好坏益处，还不如先行动起来。 焦虑的产生笑来老师如是说： 接受未知永远存在，不断尝试适应：在未知中不断前行。如果不接受这个现实，无法忍受未知的存在，会平添无数的焦虑。关于这一点，本人有过好多次体验。* 焦虑导致时间浪费，效率低下。处于焦虑状态下时，甚至可能出现一切理智都被清空的情况，会让人觉得“必须要做点什么”，但是，在这种缺乏理智状态下的任何决定和行为都可能带来灾难性的后果，陷入恶性循环。如何解决？一个有效的方法就是把问题先记录下来。* 小结上述仅仅是第一章的部分内容，把时间当做朋友一书和稻盛和夫先生活法里的观点（人生和工作的结果=思维方式(-100～+100)×热情(0～+100)×能力(0～+100)）不冲突，能感受到是另一种方式的阐述，有继续读下去的冲动。 时间不可管理，我们先学会接受：完美永不存在，未知永远存在。基于这样的接受去认识时间，把时间做为朋友相处。 传送门： 把时间当作朋友]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBus学习之旅－从入门到提高]]></title>
    <url>%2F2016%2F08%2F13%2F2016%2F2016-08-13%2F</url>
    <content type="text"><![CDATA[在公司的技术分享会上，做了关于RxBus的学习分享，记录如下： 一.RxBus与RxJava一次RxJava调用过程可以划分为以下环节： 创建观察内容 （片段1） 数据处理／映射（片段2） 选择线程（片段3） 订阅（片段4，片段5） 完成／错误处理（片段6） 在公司的技术分享会上，做了关于RxBus的学习分享，记录如下： 一.RxBus与RxJava一次RxJava调用过程可以划分为以下环节： 创建观察内容 （片段1） 数据处理／映射（片段2） 选择线程（片段3） 订阅（片段4，片段5） 完成／错误处理（片段6） 示例代码： Observable // 片段1 .create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String trim = mainEd.getText().toString().trim(); subscriber.onNext(trim); subscriber.onError(new Throwable()); subscriber.onCompleted(); } }) // 片段2 .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s + &quot; sugarya&quot;; } }) // 片段3 .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) // 片段4 .subscribe( // 片段5 new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } //片段6 @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv2.setText(s); } }); 二.RxBus与接口回调一次完整的接口回调，包括四个步骤： 接口定义 接口调用 接口实现 接口注入 RxBus的使用过程，就是一个接口回调的过程。 接口定义，在RxJava定义好了。 上面示例代码片段1里的suscriber.onNext(),onStart(),onError(),onComplete()对应接口调用。 代码片段5，片段6这些是接口实现 注入的过程是调用suscribe()方法订阅的过程 三.RxBus源码分析RxBus的代码实现如下： public class RxBus { private static volatile RxBus instance; private final Subject&lt;Object, Object&gt; _bus; private RxBus() { _bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); } public static RxBus getInstance() { if (null == instance) { synchronized (RxBus.class) { if (null == instance) { instance = new RxBus(); } } } return instance; } public void send(Object object) { try{ _bus.onNext(object); }catch (Exception e){ e.printStackTrace(); } } public boolean hasObservers() { return _bus.hasObservers(); } private &lt;T&gt; Observable&lt;T&gt; toObservable(final Class&lt;T&gt; type) { return _bus.ofType(type);//filter + cast } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Observer&lt;T&gt; observer) { return toObservable(type).subscribe(observer); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1) { return toObservable(type).subscribe(action1); } public &lt;T&gt; Subscription toSubscription(final Class&lt;T&gt; type, Action1&lt;T&gt; action1, Action1&lt;Throwable&gt; errorAction1) { return toObservable(type).subscribe(action1,errorAction1); } } 接下来对上述代码做些简要分析： volatile 保证instance可见性 禁止指令重排 这里涉及到Java内存模型，相关资料： 传送门 SerializedSubject SerializedSubject extends Subject extends Observable implements Observer，既是观察内容，又是观察者，起到桥梁／数据转发的作用 保证多线程安全，Subject 当作一个 Subscriber 使用，从多个线程中调用它的onNext方法（包括其它的on系列方法） PublishSubject主题，RxJava里有四种主题 PublishSubject BehaviorSubject ReplaySubject AsyncSubject PublishSubject的含义是：在订阅者订阅的时间点之后的数据发送给观察者 ofType操作符 = filter操作符 + cast操作符 filter只有符合过滤条件的数据才会被“发射” cast将一个Observable转换成指定类型的Observable CompositeSubscription该对象作为subscription的容器，方便统一取消订阅 四.RxBus异常处理当RxBus在执行过程中，任意环节发生了错误异常，订阅关系就会被取消。之后再次发送，将无法执行订阅后的回调。 做了一个数组越界的错误来演示 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); onRxBus(); } private void onRxBus() { int[] array = new int[2]; RxBus.getInstance().toSubscription(Integer.class, new Subscriber&lt;Integer&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { //onRxBus(); Log.e(TAG, &quot;mSubscriber17 onError: &quot; + e.toString()); } @Override public void onNext(Integer integer) { array[integer] = integer; Log.e(TAG, &quot;mSubscriber17 onNext:&quot; + integer); } }); } @OnClick(R.id.btn_main17) void onClick17() { RxBus.getInstance().send(2); } 这时候点击button按钮，数组越界异常，第二次再点击Button发送消息，没有响应了。这里，RxBus，确切的说是RxJava捕获到错误异常，就会取消订阅关系。 E/MainActivity: mSubscriber17 onError: java.lang.ArrayIndexOutOfBoundsException: length=2; index=2 解决的思路： 使用try－catch捕获异常，不让异常被RxJava捕获 在onError里重新订阅。 接下来说说第二种方法，具体怎么操作，其实就是在onError方法里，重新执行一遍订阅，执行上述注释掉的代码onRxBus,就解决问题了。 五.小结上述其实是这次技术分享大纲，技术分享准备功课前，刷了下面的文章，要对RxBus有更细致的学习和了解，可以阅读：（推荐） 谢三弟系列RxBus简单实现 RxBus深入源码解析 RxJava里onError异常处理 Yokey系列RxJava实现事件总线 RxBus异常处理 RxBus实现Sticky事件（粘性订阅） 其他RxBus从基础实现到升级——打造属于自己的RxBus EventBus和RxBus实现和性能比较]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》之如何创造财富]]></title>
    <url>%2F2016%2F08%2F08%2F2016%2F2016-08-08%2F</url>
    <content type="text"><![CDATA[这本书有很多特别有趣，以前从来没有思考过的观点，在读第6章如何创造财富的时候，这种震撼非常强烈。记录如下： 创业就是一个压缩过程 这本书有很多特别有趣，以前从来没有思考过的观点，在读第6章如何创造财富的时候，这种震撼非常强烈。记录如下： 创业就是一个压缩过程你所有的工作年限被压缩成了短短几年,不再是低强度地工作四十年，而是以极限强度工作四年。伴随而来的是工作压力也压缩到三四年，承受如此大的压力，带给你额外的报酬。 金钱不等于财富，创造有价值的东西就是创造财富财富和金钱不是同义词。我们需要的东西就是财富，食品，服装，住房，汽车，生活用品，外出旅行等都是财富，即使你没有钱，你也能拥有财富。 要是你身处南极洲内陆，再多的钱对你也是无用的，因为没有东西可买，你真正需要的是财富。 如果财富这么重要，为什么大家都却把赚钱挂在嘴边而不是财富呢？因为金钱是财富的一种简便的表达方式，是专业化的副产品。 比如你本人能制作小提琴，而你需要土豆，附近的农民对小提琴不感兴趣，那么你怎么能交换到土豆呢？ 当社会分工越来越精细后，人们把贸易分为两步：不是直接用小提琴交换土豆，而是先用小提琴交换金钱，然后再用金钱交换需要的东西。所以让自己变的富有，就是制造出人需要的商品，让别人用金钱交换商品，你拿到金钱，你就可以拿着赚来的金钱向任何人交换自己需要的其他商品。 交换媒介的优点是，它使得交易可以进行下去，缺点是，它模糊了交易的实质。人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介（一般等价物），做生意直接原因是为了获取中介，出发点应该是创造供他人需求的商品，让大家可以获得自己想要的东西。大多数生意的目的是为了做出人们真正需要的东西，创造财富。 如果我们要大量获取一般等价物，就应该抱着特别怀疑的态度，去思考那些着眼于你自己感兴趣的东西的商业计划。对于自己感兴趣的东西，你会聚的它们很有价值，但是它们恰恰最不可能与他人眼中的有价值的东西发生重合。 世界上的财富总额不是固定不变的，财富一值在不停地增长比如，一台坏机器因为一个零部件松了而不能正常运转，你把零件拧紧，机器重新运转，那么你便创造了财富。 程序员是手工艺人，创造着大量的财富我们这个世界，向下沉沦或者向上奋进都取决于你自己，不能把原因推给外界。许许多多不创造财富的人，听到最富有的5%人口占有社会一半以上财富，往往认定这事不公平的，就像最顶级的程序员写出了全世界99%的优秀软件。 创造出来的财富不一定非要通过出售实现价值，人们需要的东西就是财富，极客经常开发开源软件让所有人免费试用，把自己的工作捐献给社会。 工作是什么财富就意味着人们需要的东西。公司的存在目的就是满足人们的某种需要。作为公司的一分子与许多人一起合作完成，感觉自己是为了公司的需要而工作，其实是为了满足顾客的某种需求而工作。一分子的贡献也许不是直接性的，但是公司作为一个整体必须提供某种人们需要的东西，否则不可能盈利。 当初刚毕业，我对自己说，我需要进入一家公司工作，好像成为某个组织成员是一件多么重要的事情。然而更确切的表达是：我需要去做一些人们需要的东西。即使不加入公司，我也能做到，公司不过是一群人在一起工作，共同作出某种人们需要的东西。 真正重要的是做出人们需要的东西，而不是加入某个公司]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《途客圈创业记》有感]]></title>
    <url>%2F2016%2F07%2F31%2F2016%2F2016-07-31%2F</url>
    <content type="text"><![CDATA[不知道去年因为什么缘故，阅读了MacTalk原编程一书，关注了池老师的公众号，于是连带的关注了小道消息，嘀嘀嗒嗒，程序人生等公众号，这本书的作者就是程序人生的Tyr Chen不知道去年因为什么缘故，阅读了MacTalk原编程一书，关注了池老师的公众号，于是连带的关注了小道消息，嘀嘀嗒嗒，程序人生等公众号，这本书的作者就是程序人生的Tyr Chen 上周周二到手，工作日读了一半，今天傍晚一口气读完剩下的一半。心中有沉沉的思绪，做个读书小结，整理记录下。 技术人员从公司组织架构上是不是不适合作为第一大股东呢？Tyr散发的气息真得就是大多数有追求的程序员共有的特质，大凡热带代码，热带技术的人都会相似的逻辑思维。即使我也创业，我想我的遭遇和因对和情绪表达也是差不多的，CTO对于公司的角色定位，在技术和管理上，要被赋予更多管理的职责。 因此，如果醉心于技术成长，醉心于成为一名酷范十足的极客，CTO不是极客状态下的程序员的职业追求，技术级别悠长的技术性导向的盈利公司会是个好选择之一，成长为技术合伙人。 技术合伙人是高级段位的职业，再上一层，我觉得，也有，但是已经不再是仅仅磨练技术就能达到的了。这是极客下一个阶段或者状态的事吧。而我要向通往极客道路上前进。 感谢途客圈创业记一书，让我知道创业的过程和注意事项，这些过程和事项是认真的，是真实的，是鲜活的。 本周六有Try Chen关于本书的读者见面会，充满期待。]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用小结之入门篇]]></title>
    <url>%2F2016%2F07%2F21%2F2016%2F2016-07-21%2F</url>
    <content type="text"><![CDATA[在Java的世界里，接口是Java最强大的设计之一。笔者对接口的认识和理解包括： 实现一个接口需要四个步骤 接口定义：使用interface，可以外部定义，也可以在类中定义，根据实际需求来。 接口调用：接口定义好了，需要调用接口方法 接口实现：接口里的方法是抽象方法，需要开发人员具体的逻辑实现 接口注入：把接口实现的引用传给接口调用方。 在Java的世界里，接口是Java最强大的设计之一。笔者对接口的认识和理解包括： 实现一个接口需要四个步骤 接口定义：使用interface，可以外部定义，也可以在类中定义，根据实际需求来。 接口调用：接口定义好了，需要调用接口方法 接口实现：接口里的方法是抽象方法，需要开发人员具体的逻辑实现 接口注入：把接口实现的引用传给接口调用方。 接口的作用和意义： 通过入参，确定了一种数据流的流动方向，从接口调用方流向接口实现方。也即提供了一种代码执行的先后顺序。 降低代码的耦合。实现接口是java类与类之间的一种关系，比继承这样的强依赖的耦合度低。接口涉及Java六大设计原则里的依赖倒置原则和接口隔离原则，面向抽象编程，对调用者来说执行相同的行为（代码），却可以组织不同的逻辑。 作为静态常量的容器。可以在接口里定义各种常量。 在Android里的基本使用Rxjava每一次observable发出事件，让订阅者执行，都是一次使用接口的过程，满足上述分析的四个步骤。 Observable.create()使用EditText里输入内容，TextView显示 （1）Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onStart(); String s = mainEd.getText().toString().trim(); subscriber.onNext(s); subscriber.onCompleted(); } }); （2）Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { mainTv.setText(s); } }; （3）observable.subscribe(subscriber); 分析： 代码段（1）Observable.create()方法里，new Observable.OnSubscribe(),完成了subscriber接口的调用。代码段（2）使用匿名内部类，完成了接口定义和接口实现。代码段（3）完成了接口注入。 因此说，一次Rxjava的操作，就是一次使用接口的过程。明白了这点，如果以后引入Lambda表达式，也就不再容易感到困惑和不解了。 Observable.Just()使用上述代码可以简化写成下面的样子 String trim = mainEd.getText().toString().trim(); Observable.just(trim).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { mainTv2.setText(s); } }); Just和Create生成Observable的关联和区别： just生成的Observable只调用了接口subscriber的onNext()和onComplited()。 just代码执行是在订阅subscribe()方法调用之前，通过create生成的observable在订阅subscribe()方法调用的时候执行 Observable.from()使用入参可以是集合或者数组，该集合或数组有多少个元素就会发送多少次事件。 StringBuilder sb = new StringBuilder(); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;step1&quot;); list.add(&quot;step2&quot;); list.add(&quot;step3&quot;); list.add(&quot;step4&quot;); Observable.from(list).subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { sb.append(s+&quot; &quot;); } }); mainTv3.setText(sb.toString()); 上述代码返回的结果是：step1 step2 step3 step4 小结有了上述的认识和练习，相信对Rxjava有了一个入门的学习和使用了。 参考资料 深入浅出RxJava（一：基础篇） Github:RxJava]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当RecyclerView遇到Inconsistency detected崩溃时]]></title>
    <url>%2F2016%2F07%2F20%2F2016%2F2016-07-20%2F</url>
    <content type="text"><![CDATA[近来项目里，RecyclerView更新数据偶尔出现crash，错误日志如下：近来项目里，RecyclerView更新数据偶尔出现crash，错误日志如下： java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder{2064e5c6 position=2 id=-1, oldPos=2, pLpos:-1 scrap [attachedScrap] tmpDetached no parent} at android.support.v7.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition(RecyclerView.java:4505) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4636) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4617) at android.support.v7.widget.LinearLayoutManager$LayoutState.next(LinearLayoutManager.java:1994) at android.support.v7.widget.LinearLayoutManager.layoutChunk(LinearLayoutManager.java:1390) at android.support.v7.widget.LinearLayoutManager.fill(LinearLayoutManager.java:1353) at android.support.v7.widget.LinearLayoutManager.onLayoutChildren(LinearLayoutManager.java:574) at android.support.v7.widget.RecyclerView.dispatchLayoutStep1(RecyclerView.java:2979) at android.support.v7.widget.RecyclerView.dispatchLayout(RecyclerView.java:2904) at android.support.v7.widget.RecyclerView.onLayout(RecyclerView.java:3283) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutHorizontal(LinearLayout.java:1948) at android.widget.LinearLayout.onLayout(LinearLayout.java:1724) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.LinearLayout.onLayout(LinearLayout.java:1722) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.FrameLayout.layoutChildren(FrameLayout.java:633) at android.widget.FrameLayout.onLayout(FrameLayout.java:568) at android.view.View.layout(View.java:15912) at android.view.ViewGroup.layout(ViewGroup.java:5108) at android.widget.LinearLayout.setChildFrame(LinearLayout.java:1959) at android.widget.LinearLayout.layoutVertical(LinearLayout.java:1813) at android.widget.Line 遇到这类错误java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder，通过查阅Stackoverflow和资料，总结了如下情况和解决方法： 方法一自己写一个继承LinearLayoutManager的包装类，在onLayoutChildren()方法里try-catch捕获该异常。 @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { try { super.onLayoutChildren(recycler, state); } catch (IndexOutOfBoundsException e) { e.printStackTrace(); } } 方法二在进行数据移除和数据增加时，务必要保证RecyclerView的Adapter中的数据集和移除／添加等操作后的数据集保持一致！ 这里，前者是在该Adapter内部，不妨叫做内部数据集，后者是开发人员传过给Adapter的，不妨叫外部数据集。更新RecyclerView数据时，需要保证外部数据集和内部数据集实时保持一致。 外部数据集同步到内部数据集，使用如下的方法： notifyItemRangeRemoved(); notifyItemRangeInserted(); notifyItemRangeChanged(); notifyDataSetChanged(); 这里对notifyDataSetChange()做些说明： 使用该方法的更新内部数据集，没有默认的动画效果，同时更新数据的效率页不如上面的方法，官方不推荐使用这种方式更新数据集。 Don’t call notifyDataSetChanged if you don’t have to. RecyclerView的Adapter里，发生异常的错误代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null ) { mPoiItems.clear(); mPoiItems.addAll(poiItemList); notifyItemRangeChanged(0, poiItemList.size()); } } 错误分析： mPoiItems是外部数据集，对该外部数据集做了两个操作：先移除数据，然后添加数据，之后notify数据集。这里，添加数数据时（Adapter的内部数据集内容还处在外部数据集移除数据之前），造成了内部和外部数据集不一致。 这是一方面，另一方面，我使用了notifyItemRangeChanged()来更新数据，如果poiItemList传过来的新数据和原来mPoiItems的数据数量不一致，就会出现内部数据集和外部数据在同步后不一致，从而报错。 修复后，运行正常的代码如下： public void notifyData(List&lt;PoiItem&gt; poiItemList) { if (poiItemList != null) { int previousSize = mPoiItems.size(); mPoiItems.clear(); notifyItemRangeRemoved(0, previousSize); mPoiItems.addAll(poiItemList); notifyItemRangeInserted(0, poiItemList.size()); } } 修复分析： 每一次对外部数据集做改动时，都需要紧接着主动对外部数据集和内部数据集做一次同步操作，动画效果也得到了保持（使用方法三，动画效果缺失） 方法三：使用notifyDataSetChanged同步外部数据集和内部数据集。该方法简单，但是失去了动画效果，并且更新数据的性能低。 use notifyDataSetChanged() will avoid this crash, but it will kill Animation and Performance. 另外，如果对外部数据集做了二次以上的操作，却只调用notifyDataSetChanged同步一次，也很有可能会报上文所示的错误。 ###参考文章: stackoverflow 1 RecyclerView Bug：IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter的解决方案 使用RecyclerView遇到的一些问题 Inconsistency detected]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 下]]></title>
    <url>%2F2016%2F07%2F10%2F2016%2F2016-07-10%2F</url>
    <content type="text"><![CDATA[在我之前的一篇博客Java内存模型 上一文里，对Java的内存做了一番简单的梳理。通过上述专题的阅读和学习，又有了新的认识和思考。 最近看到一个专题讲解Java内存模型的，感觉干货满满，现记录如下： 深入理解Java内存模型（一）——顺序 深入理解Java内存模型（二）——重排序 深入理解Java内存模型（三）——顺序一致性 深入理解Java内存模型（四）——volatile 深入理解Java内存模型（五）——锁 深入理解Java内存模型（六）——final 深入理解Java内存模型（七）——总结 在我之前的一篇博客Java内存模型 上一文里，对Java的内存做了一番简单的梳理。通过上述专题的阅读和学习，又有了新的认识和思考。 关于Java的锁当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。这一操作和volatile变量的写操作相同功效 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，这一操作和volatile变量的读操作相同共享 也即是文中总结的：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 由此也自然联想到，Java锁的内部实现，其实就是通过volatile来实现的。 这里还涉及到公平锁，和非公平锁，这两者的区别是： 公平的锁上，线程按照他们发出请求的顺序获取锁.当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。 关于Java的final对于final域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。 重排序重排序分为两大类： 编译器重排序 处理器重排序，该排序可细化为指令级并行的重排序和内存系统的重排序 内存屏障：对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止） 内存模型越是追求性能的处理器，内存模型设计的会越弱,模型由强变弱依次为： 顺序一致性内存模型 JMM 处理器内存模型 happens-before:如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间. 参考资料Java 理论与实践: JDK 5.0 中更灵活、更具可伸缩性的锁定机制]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动读取短信验证码LoaderManager／CursorLoader的使用]]></title>
    <url>%2F2016%2F07%2F06%2F2016%2F2016-07-06%2F</url>
    <content type="text"><![CDATA[Cursor用来直接读取安卓手机里的数据库记录，如何获取到Cursor ？ 可以通过SQLiteOpenHelper，打开SQLiteDatabase 通过ContentProvider/ContentResolver获取 Cursor用来直接读取安卓手机里的数据库记录，如何获取到Cursor？ 可以通过SQLiteOpenHelper，打开SQLiteDatabase 通过ContentProvider/ContentResolver获取 自动读取验证码实现思路： 当验证码的短信到来，能有个监听回调或者广播之类，告知开发人员 读取短信是危险权限，android6.0权限适配 获取验证码的短信内容 从短信内容里刷选出验证码 显示验证码 接下来针对每一个步骤，做些分析和代码分享 监听接收到新短信使用ContentResolver，引入内容观察者，监听短信内容的变化，代码如下： public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public void initReadSmsLoader(){ LoaderManager loaderManager = getLoaderManager(); if(loaderManager != null){ loaderManager.initLoader(0, null, new ReadSmsLoaderListener()); } } class ReadSmsContentObserver extends ContentObserver{ public ReadSmsContentObserver(Handler handler) { super(handler); } @Override public void onChange(boolean selfChange, Uri uri) { super.onChange(selfChange, uri); LOG.e(TAG,&quot;selfChange = &quot; + selfChange+&quot; uri = &quot; + uri); if(PermissionHelper.checkReadSmsPermission(mContext)){ initReadSmsLoader(); }else{ takeReadSmsPermission(); } } } 短信验证码，权限适配PermissionHelper是自己封装的工具类 PermissionHelper.takeReadSmsPermission(this,PermissionHelper.REQUEST_CODE_READ_SMS); 获取验证码的短信内容这里有多个方案，网上相当多技术文章使用contentResolver.query()方法。我认为这个方法不够好。 该方法在UI线程里操作的，当查询的数据库的记录很多时，会出现卡顿现象。 需要手动关闭Cursor，Cursor维护操作交给开发人员。 好在，安卓已经提供了异步的（子线程）数据库查询方式，使用LoaderManager和CursorLoader这两个类，不存在上述两个问题。代码如下更详细的LoaderManager.LoaderCallbacks各个回调方法的使用，可以参考android CursorLoader用法介绍 /** * 注册内容观察者 */ public void register(){ mReadSmsContentObserver = new ReadSmsContentObserver(new Handler()); mContext.getContentResolver().registerContentObserver(URI_SMS,true,mReadSmsContentObserver); } public class ReadSmsLoaderListener implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;{ private static Uri URI_SMS_INBOX = Uri.parse(&quot;content://sms/inbox&quot;); // &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;date&quot;, &quot;type&quot; private static final String[] READ_SMS_PROJECTION = new String[]{&quot;body&quot;}; private static final String READ_SMS_SORT_ORDER = &quot;date desc&quot;; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) { //两分钟内，收到的短信，date降序排列 String readSmsWhere = &quot;date &gt;&quot; + (System.currentTimeMillis() - 2*60*1000); return new CursorLoader(mContext,URI_SMS_INBOX,READ_SMS_PROJECTION,readSmsWhere,null,READ_SMS_SORT_ORDER); } @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) { fetchSmsCodeFromCursor(data); } @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) { } } /** * 从数据库获取短信并过滤出验证码 */ private void fetchSmsCodeFromCursor(Cursor cursor) { if(cursor != null) { while (cursor.moveToNext()) { String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;)); if (!TextUtils.isEmpty(body)) { //判断该短信是否是该App发送的 if (body.contains(&quot;走么&quot;)) { String verifyCode = getSmsCode(body); displayVerifyCode(verifyCode); break; } } } } } 从短信内容里刷选出验证码使用正则表达式筛选，按正则的使用套路走起 /** * 从短信中获取验证码 * @param smsContent 短信内容 * @return */ private String getSmsCode(String smsContent){ Pattern pattern = Pattern.compile(&quot;[0-9]{4,}&quot;); Matcher m = pattern.matcher(smsContent); while (m.find()) { String group = m.group(); if(group != null &amp;&amp; group.length() &gt;= VERIFY_CODE_LENGTH){ return group; } } return &quot;&quot;; } 显示验证码 /** * 显示验证码 * @param verifyCode 验证码 */ private void displayVerifyCode(String verifyCode) { mSmsCodeEt.setText(verifyCode); //获取焦点 mSmsCodeEt.setFocusable(true); mSmsCodeEt.setFocusableInTouchMode(true); mSmsCodeEt.requestFocus(); //设置光标位置 mSmsCodeEt.setSelection(verifyCode.length()); } ##总结至此，成功实现读取短信验证码。近来主流的App，并没有实现自动读取短信验证码，比如滴滴出行，钉钉。 ##参考资料 android CursorLoader用法介绍 CursorLoader LoaderManager]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CursorLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型 上]]></title>
    <url>%2F2016%2F07%2F03%2F2016%2F2016-07-03%2F</url>
    <content type="text"><![CDATA[Java内存模型（Java Memory Model，JMM） 内存模型规定： 所有的变量都是存在主存当中（类似于物理内存） 每个线程都有自己的工作内存（类似于高速缓存） 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。 每个线程不能访问其他线程的工作内存。 Java内存模型（Java Memory Model，JMM） 内存模型规定： 所有的变量都是存在主存当中（类似于物理内存） 每个线程都有自己的工作内存（类似于高速缓存） 线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。 每个线程不能访问其他线程的工作内存。 缓存一致性（Cache coherence）问题当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中 在一个系统中，当许多不同的设备共享一个共同存储器资源，在高速缓存中的数据不一致，就会产生问题。也就是说如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 缓存一致性可以分为三个层级： 在进行每个写入运算时都立刻采取措施保证数据一致性 每个独立的运算，假如它造成数据值的改变，所有进程都可以看到一致的改变结果 在每次运算之后，不同的进程可能会看到不同的值（这也就是没有一致性的行为） 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK锁的方式 通过缓存一致性协议 最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的 它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 ##参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析 海 子]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程]]></title>
    <url>%2F2016%2F07%2F01%2F2016%2F2016-07-01%2F</url>
    <content type="text"><![CDATA[并发编程的三个问题：原子性问题，可见性问题，有序性问题并发编程的三个问题：原子性问题，可见性问题，有序性问题 原子性概念简介 一个操作或者多个操作，要么全部执行，要么就都不执行 执行的过程不会被任何因素打断 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。Java内存模型只保证了基本读取和赋值是原子性操作。 Java语言提供的保证：通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 普通的共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值。 Java语言提供的保证 volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性程序执行的顺序按照代码的先后顺序执行。 指令重排序（Instruction Reorder）处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 处理器在进行重排序时是会考虑指令之间的数据依赖性。重排序会影响多个线程内程序执行的结果。换句话说，重排不会影响单个线程内程序执行的结果。 结论：指令重排的适用范围是线程，它不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 举个参考资料里的例子： 我相信，有经验的程序员，即使不懂的指令重排，本能上也不会用两个线程异步的执行下诉初始化操作。 //线程1: context = loadContext(); //语句1 inited = true; //语句2 //线程2: while(!inited ){ sleep() } doSomethingWithConfig(context); 计划执行：在线程1里执行语句1，初始化加载操作，完成后，标志位inited置为true，线程2，跳出睡眠，执行doSomethingWithConfig方法。 实际执行：由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 Java语言提供的保证：通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性 volatile关键字一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 volatile关键字的使用场景volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。因此，当保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 状态标记量 double check。 单例的最优写法: class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null){ instance = new Singleton(); } } } return instance; } } 参考资料 百度百科：缓存一致性 Java并发编程：volatile关键字解析]]></content>
      <categories>
        <category>Java专题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/Protobuf之Protocol Buffers配置指南]]></title>
    <url>%2F2016%2F06%2F27%2F2016%2F2016-06-27%2F</url>
    <content type="text"><![CDATA[使用Protobuf，先配置环境，以下是配置Protobuf的步骤和编译Protobuf原文件的步骤使用Protobuf，先配置环境，以下是配置Protobuf的步骤和编译Protobuf原文件的步骤 Java:Compiled Environment Download:https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-java-3.0.0-beta-3.zip Install:$ ./configure $ make $ make check $ make install Check version:$ protoc --version Protocol Buffers Outputhttps://developers.google.com/protocol-buffers/ To Objective-C(.h .m)$ protoc --proto_path=src --objc_out=build/gen src/foo.proto src/bar/baz.proto To Java(.java)$ protoc --proto_path=src --java_out=build/gen src/foo.proto –proto_path可以缩写为： －I Objective-C:####Download: https://github.com/google/protobuf/releases/download/v3.0.0-beta-3/protobuf-objectivec-3.0.0-beta-3.zip Install:$ objectivec/DevTools/full_mac_build.sh Building:There are two ways to include the Runtime sources in your project: Add objectivec/\*.h &amp; objectivec/GPBProtocolBuffers.m to your project. or Add objectivec/\*.h &amp; objectivec/\*.m except forobjectivec/GPBProtocolBuffers.m to your project. If the target is using ARC, remember to turn off ARC (-fno-objc-arc) for the.m files. The files generated by protoc for the *.proto files (\*.pbobjc.h&#39; and*.pbobjc.m`) are then also added to the target.]]></content>
      <categories>
        <category>开发环境与工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活法3－寻找你自己的人生王道]]></title>
    <url>%2F2016%2F05%2F23%2F2016%2F2016-05-23%2F</url>
    <content type="text"><![CDATA[早些时候，就有想写写随笔。这个类目当作我阅读好书的笔记思考。 2011年，第一次读稻盛和夫《活法（壹）》一书，犹如闪电于混沌中飞越，对我的价值观带来一次迄今为止最大的更新和改动。 早些时候，就有想写写随笔。这个类目当作我阅读好书的笔记思考。 2011年，第一次读稻盛和夫《活法（壹）》一书，犹如闪电于混沌中飞越，对我的价值观带来一次迄今为止最大的更新和改动。 今天重拾活法－－系列叁，书读过半，深感于语句散发出来的韵律和共鸣。摘要如下： 能力出众，满腔热情，干净十足，事业一开始就拼命努力，若再有好运相助，成功便几成定数。相较于成功，保持成功更为不易。不论经营，政治或治学领域，“成功”不足为奇。成为不骄，谦虚律己，生命不息，克己不止，方才为人杰。只是这样的人似乎太正派，旁者看来颇为无趣。然而，若非颇为无趣之人，则不可能实现持久的成功 考虑到这是译文，也就不必在意成功这词的随意滥用了。 再摘引如下： 克己，临于万事欲克而不得。故先修身养性而后成也。 只有将“克己”精神融入自己的品性，血肉之中，事到临头才不致想克制也克制不了。为此，需积以时日，不断在平时就训练努力克制自己，抑制自身的欲望。 都天下无二道，圣人无两心。自天子以至于庶人，皆是以修身为本，其本乱而末至者，否矣。《大学》里的观点：平天下，治国，齐家，当从修身开始。 这里稻盛和夫讲得于旁观者看来无趣和我们要做个有趣的人说的有趣，概念会冲突么？这值得思考]]></content>
      <categories>
        <category>闲书札记</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论软件工程里解决问题的思维]]></title>
    <url>%2F2016%2F04%2F10%2F2016%2F2016-04-10%2F</url>
    <content type="text"><![CDATA[今天在项目开发中，遇到一个问题，在尝试解决无果后，对解决问题的思维产生一番思考。记录如下。 今天在项目开发中，遇到一个问题，在尝试解决无果后，对解决问题的思维产生一番思考，记录如下。 在我看来，解决一个项目问题的思维能拆分成若干个环节，这些若干个环节彼此相互互斥，解决问题的过程被映射为一环环固化思维的串接。问题得到解决存在一个最小思维量。当认知超过最小思维量时，就能推测、预判问题的变化。 思维量存在且不限于以下两个属性：思维复杂度和环节确定性。思维复杂度表示解决问题的可能性数量或方向多少。环节确定性指的是：互斥并且单一的指向下一个思维环节。互斥和单一指向两者缺一不可。当一个环节在这个思维过程中与其它环节形成互斥，即表示这个思维环节是解决问题的有效组成成分；单一指向的作用是能促成思维导向同一个结果：解决问题。一个方向而不是多个方向，这大大的降低思维复杂度。 另一方面，每个思维环节的确定性大小会影响下一个环节的确定性。如果一个环节不确定是对是错、正确程度未知，就会导致该环节的指向不再单一而是多个。所以，不高的环节确定性会造成较高的思维复杂度，这是不利于工程问题的顺利解决的。 结论：基于上述认知，工程能力提高的过程其实就是增加思维环节确定性和数量的过程。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年的年度小结]]></title>
    <url>%2F2015%2F12%2F31%2F2015%2F2015-12-31%2F</url>
    <content type="text"><![CDATA[2015年，于我是全新的一年。很多事情，从这一年才开始走上轨道，我感到开心和幸运。在写这篇小结之前，读完了糊糊老师的年度小结散文，杂感繁多，就摘录一小段文字吧，如下： 人如何能说服自己用当下去换一个未来的结果，将现在的自己当成工具一般，去为充满了无常的未来牺牲此刻。一个不够快乐的过程，如何得来圆满的结果？ 2015年，于我是全新的一年。很多事情，从这一年才开始走上轨道，我感到开心和幸运。在写这篇小结之前，读完了糊糊老师的年度小结散文，杂感繁多，就摘录一小段文字吧，如下： 人如何能说服自己用当下去换一个未来的结果，将现在的自己当成工具一般，去为充满了无常的未来牺牲此刻。一个不够快乐的过程，如何得来圆满的结果？ 我想，我不需要说服自己，在这过程中，本就是快乐多于痛苦，收获多于汗水的，所以我感到幸运。 做为安卓开发人员，这一年，我花大量的时间在安卓技艺的熟练和学习上。主要有以下方面： 1) 对安卓基本的控件做到了熟练使用。不再像去年那般书写代码要通过大脑思考反复验证生涩的写，而是可以主要通过手指记忆敲出大量常用的代码，包括ListVIew，RecyclerView，Notification，ViewPager，Fragment，WebView等等。 2) 多次获得了一些有效项目实践。体现在项目重构，减少App启动时间，代码重构优化，Android6. 0权限适配，UI多屏幕适配上。 3）年底开源了自己写的一个字母表控件到github上。虽然这个控件很小，和github上各位大牛相比不值一提，但却是某种新的开始。 4）其他杂项。如纸质设计，git使用，gradle的学习，大都只是入门。尤其是gradle的学习，我希望接下来抽一段时间，好好把这块深入进去。 今年入手了Macbook pro，Mac相比于Window对开发人员真友善了，我想吼一句相用恨晚啊。今年看的一些书籍，简单做了记录吧。 《Android开发艺术探索》，很赞，五星推荐。（还在阅读中） 《HTTP权威指南》 读完一遍，对代理服务器／缓存服务器，http 报文有了一个全面的了解。 《MacTalk 人生元编程》&amp;《MackTalk 跨越边界》，这两本是池建强老师的微信文章集文成册，一部分讲解Mac的使用，更多的是关于程序员生活状态／工作的人文内容。 通过这一年的学习，更清晰的是了解到接下来一年，我该在哪些地方提高自己的安卓水平。2016年对于我来说，是很重要的一年，是技术道路上需要我更多投入的，以期达到一种升华和质变的一年。 2016年度小结再续]]></content>
      <categories>
        <category>年度小结</category>
      </categories>
      <tags>
        <tag>Year End Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentTransition的replace，add，show，hide方法的使用差异]]></title>
    <url>%2F2015%2F12%2F26%2F2015%2F2015-12-26%2F</url>
    <content type="text"><![CDATA[android项目，使用Fragment来展示视图，替换Activity显示，能有效的提高响应的速度。结合在项目中的实践，接下来说说我对这些方法的使用感悟。 replace使用使用replace()替换后会将之前的fragment的view从viewtree中删除触发顺序:detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView() attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() android项目，使用Fragment来展示视图，替换Activity显示，能有效的提高响应的速度。结合在项目中的实践，接下来说说我对这些方法的使用感悟。 replace使用使用replace()替换后会将之前的fragment的view从viewtree中删除触发顺序:detach()-&gt;onPause()-&gt;onStop()-&gt;onDestroyView() attach()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 使用该方法，每次都可以走一遍生命周期方法，让对象保持在最新的状态，同时也会带来频繁的数据请求，实例销毁和创建 replace时，通过FragmentTransition的addToBackStack(String name)方法，把被置换的fragment压入任务栈，放在新的fragment下。在replace时如果带上tag参数，那么就可以通过FragmentManager的findFragmentByTag（）找到被置换的fragment对象 这样，当按返回键时，被置换的Fragment就能重新显示出来，并执行对应的生命周期方法（如上显示的触发顺序） add使用使用该方法，常和show和hide配合，达到replace方法的显示效果。在使用过程中，有时候会出现视图重叠。原因有两种： 没有使用FrameLayout作为容器 第一次add把Fragment添加到容器后，第二次通过 FragmentManager.findFragmentByTag(“fragment” + position)找到Fragment而不是重新新建实例add进容器 一个MainActivity加上多个Fragment来构建android项目界面主体。用这种方式，底部每一个菜单就是一个fragment，暂且叫它一级操作界面，通常用add－show －hide方式显示Fragment，在每一个Tab里（二级以上操作界面），通过replace不同的fragment来展示不同的视图 使用这种方式，我在项目中遇到了一个问题。如果二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，那么这时候在一级操作界面里，调用了二级操作界面的对象的成员对象将变成null 原来，当二级操作界面进入到三级操作界面，再从三级操作界面返回到二级操作界面，二级以上的界面通过replace来显示不同的界面，这时候二级操作界面的fragment将按上面的触发顺序重新走一遍生命周期方法，创建了新的实例，原来在一级目录里引用的二级界面上的Fragment的成员对象依然是旧实例里的 因此这时候解决的办法可以，在每次创建二级界面的fragment实例时，重新更新一遍（set方法）一级界面会用到的所有涉及二级界面fragment的成员变量]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少App的启动时间]]></title>
    <url>%2F2015%2F12%2F10%2F2015%2F2015-12-10%2F</url>
    <content type="text"><![CDATA[这几天在做App的启动时间优化，减少了将近一半的启动时间。先把一些感悟分享如下： 如何查看App的启动时间？通过android自带的工具adb，使用命令行查看adb shell am start -W -n 包名/.启动Activity例如：adb shell am start -W -n com.adb.xyz/.view.LaunchActivity这几天在做App的启动时间优化，减少了将近一半的启动时间。先把一些感悟分享如下： 如何查看App的启动时间通过android自带的工具adb，使用命令行查看adb shell am start -W -n 包名/.启动Activity例如：adb shell am start -W -n com.adb.xyz/.view.LaunchActivity 优化思路：打开App，程序首先运行Application 的onCreate方法，多数App接下来会进入扉页，最后是主页的Activity。如果在onCreate方法里，运行过多代码以及做了耗时操作，App在启动的时候就会出现一片白屏或黑屏。 而我门要做的就是把运行在onCreate的方法里的代码尽量的移到扉页中运行。 这里还有三个注意事项：Android6.0后权限的适配。如果在Application里执行代码有需要用户授权，那么需要在BaseActivity里，权限请求回调函数中，从新执行Application里的代码。 同时还要关注，上述变动对主页Activity带来的影响，有些在主页里执行的代码要做异常处理，然后在请求授权的回调里重新执行一遍。 项目工程里，如果引用的第三方库使用到了.so文件，这些.so文件的执行速度跟手机的硬件内核有关。因此，会看到，不同的手机，相同的优化方案，减少的App启动时间会不同。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓三种动画小结]]></title>
    <url>%2F2015%2F11%2F24%2F2015%2F2015-11-24%2F</url>
    <content type="text"><![CDATA[安卓中，动画可以分为三类。逐帧动画，补间动画，属性动画。稍微小结下，我对这三个动画的认识。 逐帧动画AnimationDrawble,所以逐帧动画，其实是一种图像。通过设置ImageView类的background好或者src从代码和xml两个方式上载入。安卓中，动画可以分为三类。逐帧动画，补间动画，属性动画。稍微小结下，我对这三个动画的认识。 逐帧动画AnimationDrawble,所以逐帧动画，其实是一种图像。通过设置ImageView类的background好或者src从代码和xml两个方式上载入。 ####纯代码 AnimationDrawable frameAnimation = (AnimationDrawable) img.getBackground(); frameAnimation.start(); xml定义&lt;animation-list android:id=&quot;@+id/selected&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/ wheel0&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel1&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel2&quot; android:duration=&quot;50&quot; /&gt; &lt;/animation-list&gt; 补间动画补间：开发者只需要给出动画的起始和结束帧状态，中间的帧交由安卓系统计算和补齐。抽象类Animation是补间动画的基类。同样可以分为xml和纯代码两种方式显示。补间动画无法实现动画无限重复播放。 涉及的APIAlphaAnimation,ScaleAnimation,RotateAnimation,TranslateAnimation,AnimationSet，Interpolator(差值接口),TimeInterpolator,Transformation,Camera（三维图形变换，类似Matrix） Animation animation = AnimationUtils.loadAnimation(Context context,int id) 实现自定义补间动画继承Animation，重写initalize()方法和applyTransformation(float interpolatedTime,Transformation t)方法 interpolatedTime:代表了动画的时间进行比，不管动画实际的持续时间如何，当动画播放时，该参数总是自动从0变化到1. Transformation 该参数代表了补间动画在不同时刻对图形或组件的变形程度。 applyTransformation方法的参考代码：camera.save(); camera.rotateY(360 *interpolatedTime); Matrix matrix = transformation.getMatrix(); camera.getMatrix(matrix); matrix.preTranslate(-centerX,-centerY); camera.restore(); 属性动画属性动画主要有两方面组成：1计算各帧的相关属性值 2为指定对象设置这些计算后的值。对象的属性名称有：rotationX,rotationY,scaleX,scaleY,alpha,translationX,translationY监听事件 ValueAnimator.AnimatorUpdateListener , Animator.AnimatorListener 涉及的APIAnimator:属性动画的基类。 ValueAnimator: 负责第一方面的内容。因此第二方面，为指定对象设置属性值须由程序员通过监听来完成。 ObjectAnimator,是ValueAnimator的子类，使用起来更简单。 AnimatorSet（属性动画组合），它是Animator的子类，用于组合多个Animator,指定播放顺序。 Evaluator和TypeEvaluatorEvaluator 计算器，控制属性动画如何计算属性值。TypeEvaluator 计算器接口，通过实现该接口来实现自定义计算器。 IntEvaluator FloatEvaluator ArgbEvaluator PointFEvaluator RectEvaluator ValueAnimator的使用基本用法 调用ValueAnimator的ofInt(),ofFloat()或ofObject静态方法创建 设置持续时间，插值方式，动画模式等属性 注册监听器AnimationUpdateListerner，在监听方法里，通过getAnimatedValue()方法，把当前帧的值应用到所需要的对象上。 start()启动动画 如果getAnimatedValue()返回的不是系统默认的值，借助TypeEvaluator接口，用系统自带的实现类，如PointFEvaluator,FloatArrayEvaluator,或者自己实现TypeEvaluetor,重写evaluator方法。 代码如下： valueAnimator.setObjectValues(new PointF(0, 0)); valueAnimator.setEvaluator(new TypeEvaluator&lt;PointF&gt;() { @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) { Log.e(&quot;evaluate&quot;,&quot;fraction=&quot;+fraction + &quot; startValue=&quot;+startValue +&quot; endValue=&quot; + endValue); PointF pointF = new PointF(); pointF.x = 200 * fraction * 3; pointF.y = (float) (0.5 * 10 * 200 * fraction * fraction); return pointF; } }); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { PointF pointF = (PointF) animation.getAnimatedValue(); ball.setTranslationX(pointF.x); ball.setTranslationY(pointF.y); } }); ObjectAnimator的使用继承自ValueAnimator，完成了属性动画的两个方面，所以可以直接把动画应用到对象上。 注意事项 该对象存在对应属性的setter方法。 如果只提供一个值，则该值被认为是结束值，此时需要提供getter方法。 如果该对象的setter方法不会自动调用invalidate()方法，则需要在onAnimationUpdate()监听方法里调用invalidate()刷新屏幕。 xml定义属性动画&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;objectAnimator android:duration=&quot;600&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:propertyName=&quot;alpha&quot; android:repeatCount=&quot;infinite&quot; android:repeatMode=&quot;reverse&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot; /&gt; Animator animator = AnimatorInflator.loadAnimator(Context context,int resId); 多个属性动画同时播放的实现通过AnimatorSetAnimatorSet s = new Animatorset(); s.play(animator1).before(animator2); s.paly(animator2).befor(animator3); 2、ValueAnimator,ObjectAnimater的AnimatorUpdateListener监听方法onAnimationUpdate里，调用对象的多个属性setter即可 3、借助PropertyValuesHolder PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;,1f,0f); PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0f); PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1f, 0f); ObjectAnimator animator1 = ObjectAnimator.ofPropertyValuesHolder(txt,holder1, holder2, holder3); animator1.setDuration(800); animator1.setInterpolator(new AccelerateDecelerateInterpolator()); animator1.setRepeatMode(ValueAnimator.REVERSE); animator1.setRepeatCount(ValueAnimator.INFINITE); animator1.setStartDelay(1000); animator1.start(); 借助ViewPropertyAnimator实现同时播放动画//need API12 mBlueBall.animate()// .alpha(0)// .y(mScreenHeight / 2).setDuration(1000) // need API 12 .withStartAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;START&quot;); } // need API 16 }).withEndAction(new Runnable() { @Override public void run() { Log.e(TAG, &quot;END&quot;); runOnUiThread(new Runnable() { @Override public void run() { mBlueBall.setY(0); mBlueBall.setAlpha(1.0f); } }); } }).start(); 等效于： PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(“alpha”, 1f, 0f, 1f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(“y”, 0, mScreenHeight / 2, 0); ObjectAnimator.ofPropertyValuesHolder(mBlueBall, pvhX, pvhY).setDuration(1000).start(); 参考资料 《疯狂安卓讲义》 Android 属性动画（Property Animation） 完全解析 （下）]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中对变量范围转换引发的思考]]></title>
    <url>%2F2015%2F10%2F07%2F2015%2F2015-10-07%2F</url>
    <content type="text"><![CDATA[程序中，变量活动范围有：方法/函数（局部）里的，成员变量（全局变量） 当一个变量从局部变量升级到全局变量，该变量可以跨方法使用，因此在一个方法里对该变量赋值，在另一个方法里就能马上感知到并获取变量的值，体现着监听设计思想。程序中，变量活动范围有：方法/函数（局部）里的，成员变量（全局变量）。 当一个变量从局部变量升级到全局变量，该变量可以跨方法使用，因此在一个方法里对该变量赋值，在另一个方法里就能马上感知到并获取变量的值，体现着监听设计思想。 变量升级，并不是都带来了好的方面。一个变量升级后，就要求程序员考虑是否需要对这个变量进行维护。（所谓维护就是该变量是否处在一个循环中）如果需要维护，即变量处在循环中，则要考虑是否需要对该变量进行初始化和善后处理（因为全局变量是和其他变量或方法相互联系的）如果需要，则进一步考虑变量在循环中从0次，到1次，到2次的变化过程，并从这三次变化过程中提取规律。如果获取规律？程序员的经验以及一些更底层的规律。 把一个变量从局部编程全局的途径有如下方法： 1）利用java语言的特性，从方法变量编程成员变量 2）java语言特性，编程静态变量 3）通过单例，存储在手机内存中 4）放在Application中（严格说，这种方法其实也属于3）中的单例法） 5）存储在本地，需要用到的时候，再从本地获取。比如SharedPeference，IO流写入和读取。 变量从全局变量降级成局部变量，带来的好处就是降低了变量维护难度。只需要在该方法作用范围内考虑，同时对变量个体而言，作用范围的缩小，自然增加了变量作用的安全性。 由此，还可以推广到逻辑思考切入点事宜。 一个问题，肯定是处在特定的范围或事件中的。澄清前提，划清界限很有必要。解决一个问题，修复一个bug，首先需要把这个bug产生的起始点找到，这个起始点有时候是浮动的，可以往前多些，也可以往后移些。找到bug的起始点后，还要清楚这个bug的结束点。在这起始点和结束点之间的这一段范围里，我们去修改这个bug。为了定位bug，有时候当第一直觉和感知还无法定位bug的时候，就需要对这一段范围进行切割分段。如何切割？切割的依据是什么？这里涉及到责任链，可以选取一个范围大小的责任链作为参考进行分割，其实也即是业务逻辑功能模块来分割。然后定位到某一段时，再次分割。 这种循序渐进的方式，带来了逻辑的严密，bug就不容易被我们漏过。面对问题，只要有严密的思路和逻辑对bug和问题进行分解、拆分，加上有效时间的累积实践和反馈，就一定能找到解决和修复的方法。]]></content>
      <categories>
        <category>代码杂思</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
