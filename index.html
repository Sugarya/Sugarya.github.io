<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Java Coder &amp; Kotlin Lover">
<meta property="og:type" content="website">
<meta property="og:title" content="Ethan Ruan&#39;s Blog">
<meta property="og:url" content="https://sugarya.github.io/index.html">
<meta property="og:site_name" content="Ethan Ruan&#39;s Blog">
<meta property="og:description" content="Java Coder &amp; Kotlin Lover">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ethan Ruan&#39;s Blog">
<meta name="twitter:description" content="Java Coder &amp; Kotlin Lover">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sugarya.github.io/"/>





  <title>Ethan Ruan's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ethan Ruan's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Study as if you were to live forever, live as you were to die tomorrow</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/08/03/Android原生项目集成React-Native混合开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/Android原生项目集成React-Native混合开发/" itemprop="url">Android原生项目集成ReactNative混合开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T22:22:19+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReactNative/" itemprop="url" rel="index">
                    <span itemprop="name">ReactNative</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>假设你已经配置好了ReactNative开发所需的开发环境，若没有，建议先看这篇React Native官网的翻译：<a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">搭建开发环境</a></p>
<p>以下是 本篇的正文:</p>
<h3 id="初始化React-Native"><a href="#初始化React-Native" class="headerlink" title="初始化React Native"></a>初始化React Native</h3><ol>
<li>生成package.json文件，该文件用于记录react native版本信息和依赖包</li>
<li>加入React，React Native类库</li>
<li>生成flowconfig文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">npm install --save react react-native@版本号</span><br><span class="line"></span><br><span class="line">curl -o .flowconfig  https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</span><br></pre></td></tr></table></figure>
<h3 id="配置原生安卓项目的Gradle"><a href="#配置原生安卓项目的Gradle" class="headerlink" title="配置原生安卓项目的Gradle"></a>配置原生安卓项目的Gradle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;$rootDir/node_modules/react-native/android&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   implementation &apos;com.facebook.react:react-native:版本号&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">       ndk &#123;</span><br><span class="line">            //选择要添加的对应cpu类型的.so库。</span><br><span class="line">            abiFilters &apos;armeabi&apos;, &quot;armeabi-v7a&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="添加React-native入口"><a href="#添加React-native入口" class="headerlink" title="添加React native入口"></a>添加React native入口</h3><p>在项目根目录下，新建index.js文件作为React Native控件配置页</p>
<p>Hello World示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123;AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class HelloWorld extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flex: 1,</span><br><span class="line">    justifyContent: &apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  hello: &#123;</span><br><span class="line">    fontSize: 20,</span><br><span class="line">    textAlign: &apos;center&apos;,</span><br><span class="line">    margin: 10,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AndroidRnDemoApp&apos;, () =&gt; HelloWorld);</span><br></pre></td></tr></table></figure>
<h3 id="编译运行到安卓真机"><a href="#编译运行到安卓真机" class="headerlink" title="编译运行到安卓真机"></a>编译运行到安卓真机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:8081 tcp:8081</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>新建assert资产文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform android --dev false --entry-file index.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>本次Android集成了React Native0.51.0版本的环境（最新为0.56.0），采取了原生项目为主，编译和打包仍走安卓项目的Gradle流程</p>
</li>
<li><p>React Native集成过程中，由于Kotlin改写了模块iml文件里的某处标签信息，使得项目无法正常编译，往文件里手动添加如下标签得以修复：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/07/16/Kotlin第七讲-泛型在Java和Kotlin上的横向比较/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/16/Kotlin第七讲-泛型在Java和Kotlin上的横向比较/" itemprop="url">Kotlin第七讲-泛型在Java和Kotlin上的横向比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-16T16:24:00+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读本文前，如果对Java泛型不够了解，不妨先阅读我之前写的两篇说Java泛型的文章</p>
<p><a href="https://mp.weixin.qq.com/s/2z4eVX_ftdTkx4exr-H7Ew" target="_blank" rel="noopener">重拾Java泛型 上篇</a></p>
<p><a href="https://mp.weixin.qq.com/s/o3pyQEZf7DdsZZPIneBuyg" target="_blank" rel="noopener">重拾Java泛型 下篇</a></p>
<h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>Java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)&#123;</span><br><span class="line">        Iterator&lt;? extends T&gt; iterator = list.iterator();</span><br><span class="line">        T result = iterator.next();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            T t = iterator.next();</span><br><span class="line">            if(t.compareTo(result) &gt; 0)&#123;</span><br><span class="line">                result = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T : Comparable&lt;in T&gt;&gt; max(list: List&lt;out T&gt;): T &#123;</span><br><span class="line">    val iterator = list.iterator()</span><br><span class="line">    var result: T = iterator.next()</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        val t = iterator.next()</span><br><span class="line">        if (t.compareTo(result) &gt; 0) &#123;</span><br><span class="line">            result = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看Kotlin里的Comparable类和List类源码，Comparable类定义<in t="">，List类定义<out t="">，所以可以不必重复表明Comparable的逆变能力和List的协变能力。</out></in></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T : Comparable&lt;T&gt;&gt; max(list: List&lt;T&gt;): T &#123;</span><br><span class="line">    val iterator = list.iterator()</span><br><span class="line">    var result: T = iterator.next()</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        val t = iterator.next()</span><br><span class="line">        if (t.compareTo(result) &gt; 0) &#123;</span><br><span class="line">            result = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是泛型类还是泛型方法，泛型的使用分为两个步骤</p>
<ol>
<li>第一步，声明泛型参数</li>
<li>第二步，才是使用泛型参数</li>
</ol>
<p>上面的泛型方法，以Java泛型方法为例，泛型声明部分是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Comparable&lt;? super T&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>引入泛型类型名称为T，这个数据类型的关系是实现Comparable的类。</p>
<p>使用泛型的部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends T&gt;</span><br></pre></td></tr></table></figure>
<p>入参的集合具有对类型T的协变能力。</p>
<p>所以，有些书或者网上资料，会出现两个概念：声明点变型，使用点变型。这个概念说的就是这件事</p>
<p>再来看下in位置，和out位置的概念</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1933990-0e965487f430a9ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="in_out位置图.png"></p>
<p>所以，类型参数T上的关键字out有两方面含义：</p>
<ol>
<li>具有协变的能力</li>
<li>T只能用在out位置</li>
</ol>
<p>我们再看一个有趣的例子</p>
<p>我有一个方法，入参的一个集合，我希望入参集合元素是EditText的子类的集合，如何构建满足这个关系的方法呢？至少有下面的两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun test2(list: MutableList&lt;out EditText&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T: EditText&gt;test3(list: MutableList&lt;T&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面test2， test3方法都能实现预期的效果。不同的是，test2使用协变来实现，也意味着只能读不能写操作，test2不是泛型方法。test3方法通过在声明表明泛型参数的类型关系来实现，可读可写，它是泛型方法。</p>
<p>对应的Java代码如下</p>
<pre><code>private void test2(List&lt;? extends EditText&gt; list){

}

private &lt;T extends EditText&gt; void test3(List&lt;T&gt; list){

}
</code></pre><h3 id="实现泛型参数多约束"><a href="#实现泛型参数多约束" class="headerlink" title="实现泛型参数多约束"></a>实现泛型参数多约束</h3><p>Java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T extends Serializable &amp; CharSequence&gt; void ensureTrailingPeriod(T seq)&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kotlin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T: Serializable, T: CharSequence&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Java语法上很大的不同，Kotlin要实现多约束，使用到where关键词，这是全新的表示法。</p>
<h3 id="实化类型参数"><a href="#实化类型参数" class="headerlink" title="实化类型参数"></a>实化类型参数</h3><p>来看一段Java代码：</p>
<pre><code>private &lt;T&gt; void test(T t){
    if(t instanceof String){
        String s = (String)t;

    }else if(t instanceof Integer){
        Integer i = (Integer)t;
    }
}
</code></pre><p>入参是泛型的，通过instanceof来判断泛型具体是哪个类型。再看一段代码</p>
<pre><code>private &lt;T&gt; void test2(Object o){
    //编译不通过
    if(o instanceof T){

    }
}
</code></pre><p>泛型作为参数类型时，编译不通过。如果要完成上述的逻辑，要怎么实现？可以通过class近似等效实现</p>
<pre><code>class ClassJudge&lt;T&gt;{
    Class&lt;T&gt; kind;

    public ClassJudge(Class&lt;T&gt; kind) {
        this.kind = kind;
    }

    public boolean isInstance(Object o){
        return kind.isInstance(o);
    }
}
</code></pre><p>调用</p>
<pre><code>Integer a = 12;
boolean instance = new ClassJudge&lt;String&gt;(String.class).isInstance(a);
System.out.println(&quot;instance = &quot; + instance);
</code></pre><p>Kotlin在语言层面作出了支持，对上述Java代码test2方法，kotlin代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun&lt;reified T&gt; test2(any: Any)&#123;</span><br><span class="line">    if(any is T)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此需要具备两个条件：</p>
<ol>
<li>是内联函数 inline</li>
<li>关键词 reified</li>
</ol>
<h3 id="集合协变"><a href="#集合协变" class="headerlink" title="集合协变"></a>集合协变</h3><p>在Kotlin里，非空类型是可空类型的子类型。</p>
<p>Java实现的协变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>Kotlin实现的协变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val list: MutableList&lt;out Number&gt; = arrayListOf&lt;Int&gt;()</span><br></pre></td></tr></table></figure>
<h3 id="集合逆变"><a href="#集合逆变" class="headerlink" title="集合逆变"></a>集合逆变</h3><p>Java实现的逆变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;();</span><br></pre></td></tr></table></figure>
<p>对应的Kotlin逆变的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val list: MutableList&lt;in Int&gt; = arrayListOf&lt;Number&gt;()</span><br></pre></td></tr></table></figure>
<p>变型（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。</p>
<p>由此可见，在泛型里，extends 不全等于 ：。extends代表子类型关系和协变，而Kotlin的 ：只代表子类型关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;out T&gt; = &lt;? extends T&gt;</span><br><span class="line">&lt;in T&gt; = &lt;? super T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="星投影和Java无限制通配符？差异"><a href="#星投影和Java无限制通配符？差异" class="headerlink" title="星投影和Java无限制通配符？差异"></a>星投影和Java无限制通配符？差异</h3><p>星投影如何使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;*&gt; = &lt;out Any?&gt;</span><br><span class="line">&lt;*&gt; = &lt;in nothing&gt;</span><br></pre></td></tr></table></figure>
<p>投影一词，顾名思义，是对Any？的投影，获得了Any？部分的能力—Any？协变的能力，即失去写操作，只能读操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun printFirst(list: List&lt;*&gt;)&#123;</span><br><span class="line">    if(list.isNotEmpty())&#123;</span><br><span class="line">        println(list.first())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="场景二：泛型类存储"><a href="#场景二：泛型类存储" class="headerlink" title="场景二：泛型类存储"></a>场景二：泛型类存储</h4><p>所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化到一个分开的位置，预防了误用，保证了它不会被错误地使用。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="非空性与泛型"><a href="#非空性与泛型" class="headerlink" title="非空性与泛型"></a>非空性与泛型</h3><p>Java和Kotlin默认，泛型参数都是可空的，以Kotlin为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Processor&lt;T&gt; &#123;</span><br><span class="line">    fun process(value: T)&#123;</span><br><span class="line">        value?.hashCode()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型参数是可空类型，可以理解为默认实现&lt;T: Any?&gt;，因此要实现非空类型，只需&lt;T: Any&gt;，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Processor2&lt;T: Any&gt; &#123;</span><br><span class="line">    fun process(value: T)&#123;</span><br><span class="line">        value.hashCode()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，泛型<t> 和&lt;T: Any&gt;是有区别的，前者是可空类型，后者是非空类型，确切说，<t>和&lt;T:Any?&gt;等效</t></t></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Kotlin和Java的差异，体现在语法和功能两个方面</p>
<p>语法上</p>
<ol>
<li>Kotlin使用：替代 extends；</li>
<li>用星投影 * 替代？</li>
<li>用out, in来体现协变和逆变；</li>
<li>泛型类型多约束条件，Kotlin使用where关键词，而不用Java里&amp;表示</li>
</ol>
<p>功能上：</p>
<ol>
<li>新增了实化参数类型</li>
</ol>
<p>##参考资料</p>
<p><a href="https://zhuanlan.zhihu.com/p/31137677" target="_blank" rel="noopener">仔细说说Java中的泛型</a></p>
<p><a href="https://www.zhihu.com/question/20400700/answer/117464182" target="_blank" rel="noopener">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></p>
<p><a href="https://www.jianshu.com/p/4caf2567f91d" target="_blank" rel="noopener">Java 泛型进阶</a></p>
<p><a href="https://www.zhihu.com/question/36645143/answer/68650398" target="_blank" rel="noopener">Java为什么要添加运行时获取泛型的方法</a></p>
<p><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="noopener">Kotlin实战</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1933990-c2b40ae64200e884.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注CodeThings"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/06/12/Kotlin第六讲-委托类和属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/Kotlin第六讲-委托类和属性/" itemprop="url">Kotlin第六讲-委托类和属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T10:28:00+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="委托类"><a href="#委托类" class="headerlink" title="委托类"></a>委托类</h2><p>实现一个接口，可以使用by关键字将接口实现委托给另一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface OnClickListener&#123;</span><br><span class="line">    fun onClick()</span><br><span class="line"></span><br><span class="line">    fun onLongClick()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewClickDelegate : OnClickListener&#123;</span><br><span class="line"></span><br><span class="line">    override fun onClick()&#123;</span><br><span class="line">        println(&quot;ViewClickDelegate onClick&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onLongClick() &#123;</span><br><span class="line">        println(&quot;ViewClickDelegate onLongClick&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class View(val name: String, onClickListener: OnClickListener) : OnClickListener by onClickListener&#123;</span><br><span class="line"></span><br><span class="line">    override fun onLongClick() &#123;</span><br><span class="line">        println(&quot;$name onLongClick&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类委托后我们依然可以通过重写的方式来覆盖委托类的实现，这里View实现onLongClick方法，覆盖重写了ViewClickDelegate类里的onLongClick方法。</p>
<p><strong>类委托的本质是：把抽象方法的实现交给了by后的委托对象</strong></p>
<h2 id="延迟初始化和委托属性"><a href="#延迟初始化和委托属性" class="headerlink" title="延迟初始化和委托属性"></a>延迟初始化和委托属性</h2><h3 id="延迟初始化属性"><a href="#延迟初始化属性" class="headerlink" title="延迟初始化属性"></a>延迟初始化属性</h3><p>不在对象创建的时候初始化，而是在第一次使用时初始化。完成后像普通属性一样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">open class Food(val name: String) &#123;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;[$name]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Container(val name: String) &#123;</span><br><span class="line"></span><br><span class="line">    lateinit var foodList: List&lt;Food&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="惰性初始化属性"><a href="#惰性初始化属性" class="headerlink" title="惰性初始化属性"></a>惰性初始化属性</h3><p>第一次使用该属性时才初始化，且只初始化一次。用旗号标示是否初始化过，旗号有多种选择和实现方式。</p>
<p>在代码定义处执行初始化，有助于代码维护。</p>
<p>对指令式语言，这个模式可能潜藏着危险，尤其是使用共享状态的程式习惯。</p>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Container2(val name: String) &#123;</span><br><span class="line">    private var _foodList: List&lt;Food&gt;? = null</span><br><span class="line">    val foodList: List&lt;Food&gt;</span><br><span class="line">        get() &#123;</span><br><span class="line">            if (_foodList == null) &#123;</span><br><span class="line">                _foodList = arrayListOf(Food(&quot;米糊&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">            return _foodList!!</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="by-lazy-实现惰性初始化"><a href="#by-lazy-实现惰性初始化" class="headerlink" title="by lazy(){}实现惰性初始化"></a>by lazy(){}实现惰性初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Container4(val name: String) &#123;</span><br><span class="line">    val food: Food by lazy&#123;</span><br><span class="line">        Food(&quot;米糊&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//指定锁</span><br><span class="line">class Container5(val name: String) &#123;</span><br><span class="line">    val food: Food by lazy(Container5::class)&#123;</span><br><span class="line">        Food(&quot;米糊&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//默认 线程安全 SYNCHRONIZED</span><br><span class="line">//PUBLICATION，同步锁不是必需的，允许多个线程同时执行</span><br><span class="line">class Container6(val name: String) &#123;</span><br><span class="line">    val food: Food by lazy(LazyThreadSafetyMode.SYNCHRONIZED)&#123;</span><br><span class="line">        Food(&quot;米糊&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性，索引属性；关联属性，限制属性。接下来看下Kotlin如何实现关联属性和限制属性的</p>
<h3 id="关联属性（可观察属性）"><a href="#关联属性（可观察属性）" class="headerlink" title="关联属性（可观察属性）"></a>关联属性（可观察属性）</h3><h4 id="通过PropertyChangeSupport代码实现属性监听"><a href="#通过PropertyChangeSupport代码实现属性监听" class="headerlink" title="通过PropertyChangeSupport代码实现属性监听"></a>通过PropertyChangeSupport代码实现属性监听</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shelf(val name: String, _book: Book) &#123;</span><br><span class="line"></span><br><span class="line">    private val propertyChange: PropertyChangeSupport = PropertyChangeSupport(this)</span><br><span class="line">    var book: Book = _book</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            val oldBook = field</span><br><span class="line">            field = value</span><br><span class="line">            propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        propertyChange.addPropertyChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        propertyChange.removePropertyChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把逻辑封装，抽取出基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">open class BasePropertyChange &#123;</span><br><span class="line"></span><br><span class="line">    val propertyChange = PropertyChangeSupport(this)</span><br><span class="line"></span><br><span class="line">    protected fun addChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        propertyChange.addPropertyChangeListener(key, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected fun removeChangeListener(key: String, propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        propertyChange.removePropertyChangeListener(key, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shelf_2(val name: String, _book: Book) : BasePropertyChange() &#123;</span><br><span class="line"></span><br><span class="line">    var book: Book = _book</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            val oldBook = field</span><br><span class="line">            field = value</span><br><span class="line">            propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        addChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        removeChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把book里的set访问器的逻辑封装成一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class BookDelegate(_book: Book, val propertyChange: PropertyChangeSupport) &#123;</span><br><span class="line"></span><br><span class="line">    var field: Book = _book</span><br><span class="line"></span><br><span class="line">    fun getValue(): Book = field</span><br><span class="line"></span><br><span class="line">    fun setValue(value: Book) &#123;</span><br><span class="line">        val oldBook = field</span><br><span class="line">        field = value</span><br><span class="line">        propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shelf2(val name: String, _book: Book) : BasePropertyChange() &#123;</span><br><span class="line"></span><br><span class="line">    val _bookDelegate: BookDelegate = BookDelegate(_book, propertyChange)</span><br><span class="line">    var book: Book</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            _bookDelegate.setValue(value)</span><br><span class="line">        &#125;</span><br><span class="line">        get() = _bookDelegate.getValue()</span><br><span class="line"></span><br><span class="line">    fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        addChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        removeChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们用Kotlin手工实现了可观察属性变化的功能，测试下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun testObserverField() &#123;</span><br><span class="line">    val shelf = Shelf2(&quot;书架&quot;, Book(&quot;Think in java&quot;))</span><br><span class="line">    shelf.addBookChangeListener(object : PropertyChangeListener &#123;</span><br><span class="line">        override fun propertyChange(evt: PropertyChangeEvent?) &#123;</span><br><span class="line">            val oldBook = evt?.oldValue as Book</span><br><span class="line">            val newBook = evt.newValue as Book</span><br><span class="line"></span><br><span class="line">            println(&quot;old book = $oldBook , new book = $newBook&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    shelf.book = Book(&quot;Kotlin in action&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码结果如下：</p>
<blockquote>
<p>old book = Book(name=Think in java) , new book = Book(name=Kotlin in action)</p>
</blockquote>
<h4 id="使用Kotlin委托实现"><a href="#使用Kotlin委托实现" class="headerlink" title="使用Kotlin委托实现"></a>使用Kotlin委托实现</h4><p>Kotlin的委托属性在语言层面提供了在属性的读访问器里调用委托类里operator修饰的两参数getValue方法，属性写访问器调用operator修饰setValue三个参数方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class BookDelegate2(_book: Book, val propertyChange: PropertyChangeSupport) &#123;</span><br><span class="line"></span><br><span class="line">    var field: Book = _book</span><br><span class="line"></span><br><span class="line">    operator fun getValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;): Book = field</span><br><span class="line"></span><br><span class="line">    operator fun setValue(shelf3: Shelf3, prop: KProperty&lt;*&gt;, newValue: Book) &#123;</span><br><span class="line">        val oldBook = field</span><br><span class="line">        field = newValue</span><br><span class="line">        propertyChange.firePropertyChange(&quot;book&quot;, oldBook, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shelf3(val name: String, _book: Book) : BasePropertyChange() &#123;</span><br><span class="line"></span><br><span class="line">    var book: Book by BookDelegate2(_book, propertyChange)</span><br><span class="line"></span><br><span class="line">    fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        addChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        removeChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常借助ReadWriteProperty接口能方便我们实现委托</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class BookDelegate3(var field: Book, val propertyChange: PropertyChangeSupport) : ReadWriteProperty&lt;Shelf3_1, Book&gt; &#123;</span><br><span class="line"></span><br><span class="line">    override fun getValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;): Book &#123;</span><br><span class="line">        return field</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun setValue(thisRef: Shelf3_1, property: KProperty&lt;*&gt;, value: Book) &#123;</span><br><span class="line">        val oldBook = field</span><br><span class="line">        field = value</span><br><span class="line">        propertyChange.firePropertyChange(&quot;book&quot;, oldBook, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shelf3_1(val name: String, _book: Book) : BasePropertyChange() &#123;</span><br><span class="line"></span><br><span class="line">    var book: Book by BookDelegate3(_book, propertyChange)</span><br><span class="line"></span><br><span class="line">    fun addBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        addChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeBookChangeListener(propertyChangeListener: PropertyChangeListener) &#123;</span><br><span class="line">        removeChangeListener(&quot;book&quot;, propertyChangeListener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试上述代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun testDelegateFieldForKotlin() &#123;</span><br><span class="line">    val shelf = Shelf3_1(&quot;书架&quot;, Book(&quot;Think in java&quot;))</span><br><span class="line"></span><br><span class="line">    shelf.addBookChangeListener(object : PropertyChangeListener &#123;</span><br><span class="line">        override fun propertyChange(evt: PropertyChangeEvent?) &#123;</span><br><span class="line">            val oldBook = evt?.oldValue as Book</span><br><span class="line">            val newBook = evt?.newValue as Book</span><br><span class="line"></span><br><span class="line">            println(&quot;Kotlin委托 old book is $oldBook, and new book is $newBook&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    shelf.book = Book(&quot;Kotlin in action!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>Kotlin委托 old book is Book(name=Think in java), and new book is Book(name=Kotlin in action!)</p>
</blockquote>
<p><strong>委托属性的本质：把属性访问器的实现交给了by后的委托对象</strong></p>
<h4 id="使用Kotlin的自带的实现可观察属性"><a href="#使用Kotlin的自带的实现可观察属性" class="headerlink" title="使用Kotlin的自带的实现可观察属性"></a>使用Kotlin的自带的实现可观察属性</h4><p>其实，Delegate.observable()类实现了上面提到的所有逻辑了。</p>
<p>我们看下Delegate.observable方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T&gt; observable(initialValue: T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Unit):</span><br><span class="line">        ReadWriteProperty&lt;Any?, T&gt; = object : ObservableProperty&lt;T&gt;(initialValue) &#123;</span><br><span class="line">            override fun afterChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T) = onChange(property, oldValue, newValue)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回ObservableProperty对象，看下ObservableProperty对象源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ObservableProperty&lt;T&gt;(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line">    private var value = initialValue</span><br><span class="line"></span><br><span class="line">    protected open fun beforeChange(property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Boolean = true</span><br><span class="line"></span><br><span class="line">    protected open fun afterChange (property: KProperty&lt;*&gt;, oldValue: T, newValue: T): Unit &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123;</span><br><span class="line">        val oldValue = this.value</span><br><span class="line">        if (!beforeChange(property, oldValue, value)) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        this.value = value</span><br><span class="line">        afterChange(property, oldValue, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该对象有getValue和setValue方法，这和我们自己实现的BookDelegate3类里的getValue和setValue方法逻辑几乎相同。不同之处是，官方还多了beforeChange()控制，和afterChange()供实现类覆盖重写。</p>
<p>Kotlin标准库已经提供了可观察属性的属性委托实现了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Shelf4(val name: String, _book: Book) &#123;</span><br><span class="line"></span><br><span class="line">    var book: Book by Delegates.observable(_book, &#123;property, oldValue, newValue -&gt;</span><br><span class="line">        println(&quot;The old book&apos;s name is \&quot;$&#123;oldValue.name&#125;\&quot;, and the new book&apos;s name is \&quot;$&#123;newValue.name&#125;\&quot;&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试下上述的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testObserverFieldForKotlin()&#123;</span><br><span class="line">    val shelf = Shelf4(&quot;书架&quot;, Book(&quot;think in java&quot;))</span><br><span class="line">    shelf.book = Book(&quot;Kotlin in action&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>The old book’s name is “think in java”, and the new book’s name is “Kotlin in action”</p>
</blockquote>
<h4 id="限制属性"><a href="#限制属性" class="headerlink" title="限制属性"></a>限制属性</h4><p>Kotlin也为我们提供了现成的委托类来实现限制属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Shelf5(val name: String, val book: Book ,_year: Int) &#123;</span><br><span class="line">    var year: Int by Delegates.vetoable(_year, &#123;property, oldValue, newValue -&gt;</span><br><span class="line">        newValue &lt;= 99</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试上述代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testVetoableFieldForKotlin()&#123;</span><br><span class="line">    val shelf = Shelf5(&quot;书架&quot;, Book(&quot;think in java&quot;), 0)</span><br><span class="line">    shelf.year = 200</span><br><span class="line">    println(&quot;current book is $&#123;shelf.year&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    shelf.year = 20</span><br><span class="line">    println(&quot;current book is $&#123;shelf.year&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>current book is 0<br>current book is 20</p>
</blockquote>
<p><strong>注意：</strong><br>上述用的是成员函数，事实上，扩展函数也能实现委托属性</p>
<h3 id="使用Map实现委托属性"><a href="#使用Map实现委托属性" class="headerlink" title="使用Map实现委托属性"></a>使用Map实现委托属性</h3><p>MapAccessors.kt文件里，有如下扩展函数源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.jvm.JvmName(&quot;getVarContravariant&quot;)</span><br><span class="line">@kotlin.internal.LowPriorityInOverloadResolution</span><br><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): V</span><br><span class="line">        = @Suppress(&quot;UNCHECKED_CAST&quot;) (getOrImplicitDefault(property.name) as V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline operator fun &lt;V&gt; MutableMap&lt;in String, in V&gt;.setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: V) &#123;</span><br><span class="line">    this.put(property.name, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见， MutableMap存在getValue方法和setValue方法，那么就可以用于委托，事实上，也确实如此。</p>
<p>举个例子:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Fruit(name: String) : Food(name)&#123;</span><br><span class="line"></span><br><span class="line">    private val attributeMap = HashMap&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    val color: String by attributeMap</span><br><span class="line"></span><br><span class="line">    val size: String by attributeMap</span><br><span class="line"></span><br><span class="line">    fun setAttributeMap(name: String, value: String)&#123;</span><br><span class="line">        attributeMap.put(name, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testDelegateMap()&#123;</span><br><span class="line">    val fruit = Fruit(&quot;西瓜&quot;)</span><br><span class="line"></span><br><span class="line">    fruit.setAttributeMap(&quot;color&quot;, &quot;绿色&quot;)</span><br><span class="line">    fruit.setAttributeMap(&quot;size&quot;, &quot;2kg&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;color = $&#123;fruit.color&#125;, size = $&#123;fruit.size&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>color = 绿色, size = 2kg</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>类委托的本质是：把抽象方法的实现交给了by后的委托对象</strong></p>
<p><strong>属性委托的本质是：把属性访问器的实现交给了by后的委托对象</strong></p>
<p><strong>扩展函数也能实现属性委托</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科：惰性初始化模式</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">维基百科：惰性求值</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/06/03/Kotlin第五讲-Kotlin的类型和空处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/Kotlin第五讲-Kotlin的类型和空处理/" itemprop="url">Kotlin第五讲-Kotlin的类型和空处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T17:20:00+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Kotlin的类型<br>类型就是数据的分类，不同类型代表不同种类的数据。</p>
<p>Kotlin里类型分为：可空类型，非空类型，平台类型</p>
<p>####对平台类型的理解<br><strong>平台类型：</strong>Kotlin不知道可空性信息的类型，即当作可空类型也可当作非空类型。所以在这个类型上的所有操作需要程序员自己负责，编译器允许所有的操作。通常发生在Kotlin调用Java代码的场景上。</p>
<p>以字符串类型举例，字符串平台类型如下：</p>
<blockquote>
<p>String！</p>
</blockquote>
<p>程序员不能使用这种语法，Java代码转Kotlin代码的时候会出现，表示可控性未知，也可以理解为己有肯能是非空类型也有可能是可空类型</p>
<p>####非空类型和可空类型的理解<br>可空类型 = 非空类型 + null</p>
<blockquote>
<p>Type? = Type + null</p>
</blockquote>
<p>因此，String？，String是两种不同的数据类型，就像Int和String是两种数据类型那般。</p>
<p>###基本数据类型<br>Kotlin不区分基本数据类型和包装类型，都是使用一种基本类型：</p>
<p>下面是非空基本类型  </p>
<blockquote>
<p>Char, Boolean, Byte, Short, Int，Long, Float, Double </p>
</blockquote>
<p>可空基本类型  </p>
<blockquote>
<p>Char？, Boolean?, Byte?, Short?, Int?，Long?, Float?, Double? </p>
</blockquote>
<p>Kotlin的基本类型如果转成Java基本数据类型，要怎么办？</p>
<p>对于变量、属性、参数和返回类型，Kotlin的基本类型会被编译成Java的基本数据类型。<br>用作泛型类型参数的基本数据类型会被编译成对应的Java包装类型。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>和Java不同，小范围的值不能自动转化为大范围的值，而是看成两种不同的类型</p>
</blockquote>
<p>下面的代码演示了数据类型的表示，各类型转化，数据类型智能推断，字符串类型转成基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">fun testBasicType() &#123;</span><br><span class="line">    val bb: Byte = 127</span><br><span class="line">    val boolean = false</span><br><span class="line">    val aa: Char = &apos;a&apos;</span><br><span class="line"></span><br><span class="line">    var i: Int = 21_4748_3647 //10位</span><br><span class="line">    var l: Long = 922_3372_0368_5477_5807L  //19位 //不存在小写的l</span><br><span class="line"></span><br><span class="line">    val f: Float = 123f</span><br><span class="line">    val f2: Float = 124F</span><br><span class="line"></span><br><span class="line">    val a16 = 0x123ef3</span><br><span class="line">    val b16 = 0XcCCef3</span><br><span class="line"></span><br><span class="line">    val c2 = 0b1010</span><br><span class="line">    val cc2 = 0B11001</span><br><span class="line"></span><br><span class="line">    val b: Byte = 1</span><br><span class="line"></span><br><span class="line">    val eas = b + 1L //Long + Byte =&gt; Long , eas为Long类型</span><br><span class="line"></span><br><span class="line">    fun foo(l: Long) &#123;</span><br><span class="line">        println(l)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo(44) //单独写44可能是byte，int long，这里智能推断44会被认为是long</span><br><span class="line"></span><br><span class="line">    //字符串转基本数据类型</span><br><span class="line">    val p = &quot;44&quot;.toInt()</span><br><span class="line">    val p2 = &quot;44&quot;.toLong()</span><br><span class="line">    val p3 = &quot;44&quot;.toFloatOrNull()</span><br><span class="line">    val p4 = &quot;44&quot;.toDouble()</span><br><span class="line"></span><br><span class="line">    val translate = l.toInt().toLong().toFloat().toDouble().toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###Any，Unit，Nothing类型</p>
<p>Any 相当于 Object，不同点：是非空类型，缺少Object的wait，notify方法</p>
<p>Unit相当于Java的Void；不同点：Unit是一个完备的类型，可以作为类型参数。Unit是Any的子类</p>
<p>Nothong表明函数不会有返回类型（没有返回类型），该函数不会正常终止，Nothing是Unit的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fun getStrinLenght(s: String?): Int &#123;</span><br><span class="line">    if (s == null) &#123;</span><br><span class="line">        throw IllegalArgumentException()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return s.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun fail(): Nothing = throw IllegalArgumentException()</span><br><span class="line"></span><br><span class="line">fun getStrinLenght2(s: String?): Int =</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            fail()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            s.length</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">fun testAnyAndNothing(o: Any?): View &#123;</span><br><span class="line">    val filterO = o ?: fail()</span><br><span class="line"></span><br><span class="line">    return when (filterO) &#123;</span><br><span class="line">        is View -&gt; &#123;</span><br><span class="line">            View(&quot;View&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        is TextView -&gt; &#123;</span><br><span class="line">            TextView(&quot;TextView&quot;, &quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        else -&gt; &#123;</span><br><span class="line">            fail()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以认为：throw IllegalArgumentException()返回的类型是Nothing，nothing是Int的子类型。</p>
<p>####小结<br>Any，Unit和Nothing三者关系： <a href="http://natpryce.com/articles/000818.html" target="_blank" rel="noopener">A Whirlwind Tour of the Kotlin Type Hierarchy</a></p>
<p>##空安全相关的运算符</p>
<p>###安全调用？.<br>如果值是null，整个表达式的值为null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open class Company(val name: String, val address: String?)</span><br><span class="line"></span><br><span class="line">fun testNullType()&#123;</span><br><span class="line">    val company = Company(&quot;京东&quot;, null)</span><br><span class="line"></span><br><span class="line">    val length = company.address?.length</span><br><span class="line">    println(&quot;length = $length&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###Elvis运算符 ？：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun testElvis(list: List&lt;Company?&gt;?, defaultAddress: String?)&#123;</span><br><span class="line">    val defaultAdd = defaultAddress ?: &quot;&quot;</span><br><span class="line">    val length = defaultAddress?.length ?: 0 //.?为空调用，表达式返回null，遇到了？：</span><br><span class="line">    println(&quot;defaultAdd = $defaultAdd, length = $length&quot;)</span><br><span class="line"></span><br><span class="line">    val companyList = list ?: throw IllegalArgumentException(&quot;null list&quot;)</span><br><span class="line"></span><br><span class="line">    val address = companyList[0]?.address?.toUpperCase() ?: defaultAddress //多重空安全调用和Elvis联合使用</span><br><span class="line">    println(&quot;address = $address&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###安全转换as?<br>as？运算法尝试把值转换成制定的类型，如果值不是合适的类型就返回null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">open class View(val name: String)</span><br><span class="line"></span><br><span class="line">class TextView(name: String, val text: String) : View(name)</span><br><span class="line"></span><br><span class="line">fun testAsClient()&#123;</span><br><span class="line">    val company = Company(&quot;JD&quot;, &quot;亦庄&quot;)</span><br><span class="line">    testAs(company)</span><br><span class="line"></span><br><span class="line">    testAs2(company)</span><br><span class="line"></span><br><span class="line">    val tv = TextView(&quot;TextView&quot;, &quot;I am a message content&quot;)</span><br><span class="line">    testAs2(tv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testAs(o: Any)&#123;</span><br><span class="line">    val tv = o as TextView</span><br><span class="line">    println(&quot;name = $&#123;tv.name&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testAs2(o: Any)&#123;</span><br><span class="line">    val tv = o as? TextView ?: TextView(&quot;Default TextView&quot;, &quot;&quot;)</span><br><span class="line">    println(&quot;The content of $&#123;tv.name&#125; is = $&#123;tv.text&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###非空断言 !!</p>
<p>把任何值转换成非空类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun testNoNullClient()&#123;</span><br><span class="line">    val result = testNoNull(&quot;Kotlin&quot;)</span><br><span class="line">    println(&quot;result = $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testNoNull(s: String?) : String&#123;</span><br><span class="line">    val length = s!!.length</span><br><span class="line">    println(&quot;$s&apos;s length is $length&quot;)</span><br><span class="line">    return s!!.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###let函数 </p>
<p>把可空值作为实参传递一个只接收非空值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun testLet()&#123;</span><br><span class="line">    val length = getTheBigCompanyInTheWorld().address?.length</span><br><span class="line">    val upperCase = getTheBigCompanyInTheWorld().address?.toUpperCase()</span><br><span class="line">    val letter = getTheBigCompanyInTheWorld().address?.get(0)</span><br><span class="line">    println(&quot;address&apos;s length is $length , uppercase  = $upperCase, letter = $letter&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testLet2()&#123;</span><br><span class="line">    getTheBigCompanyInTheWorld().address?.let &#123;</span><br><span class="line">        val upperCase = it.toUpperCase()</span><br><span class="line">        val length = it.length</span><br><span class="line">        val letter = it[0]</span><br><span class="line">        println(&quot;address&apos;s length is $length , uppercase  = $upperCase, letter = $letter&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun getTheBigCompanyInTheWorld(): Company = Company(&quot;JD&quot;, &quot;Beijing&quot;)</span><br></pre></td></tr></table></figure>
<p>###可空类型的扩展函数</p>
<p>允许接收者为null的调用，在扩展函数内部处理null。不需要安全调用了</p>
<p>看几个Kotlin标准库，String定义的扩展函数isNullOrEmpty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public inline fun CharSequence?.isNullOrEmpty(): Boolean &#123;</span><br><span class="line">    return this == null || this.length == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>在Java中，this永远是非空的，在Kotlin中，this可以为null。    </p>
</blockquote>
<blockquote>
<p>因此在定义扩展函数时，需要考虑扩展是否需要为可空类型定义。本质上是对null在哪个环节处理的思考，是要在调用时使用空安全调用处理呢，还是在调用的函数内部处理。</p>
</blockquote>
<p>###泛型参数默认是可空类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; myPrintln(t: T)&#123;</span><br><span class="line">    println(t.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testGenericityClient()&#123;</span><br><span class="line">    myPrintln(null)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###转Java代码为Kotlin代码时，对空的处理</p>
<p>####带注解的Java变量翻译到Kotlin时被认为是可空类型或者非空类型</p>
<ol>
<li>Javax.annotation包下</li>
<li>android.support.annotation包下</li>
<li>org.jetbrains.annotations下</li>
</ol>
<blockquote>
<p>@Nullable + Type = Type?<br>@NotNull + Type = Type</p>
</blockquote>
<p>##参考资料<br><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="noopener">Kotlin实战</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/05/27/Kotlin第四讲-Kotlin的类、对象和接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/27/Kotlin第四讲-Kotlin的类、对象和接口/" itemprop="url">Kotlin第四讲-Kotlin的类、对象和接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-27T17:22:00+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是逻辑组织的基本单元，类含有以下成分：依赖包，类名，构造方法，属性，成员方法，伴生对象，接口，父类等</p>
<h3 id="类的构造方法的完整逻辑过程"><a href="#类的构造方法的完整逻辑过程" class="headerlink" title="类的构造方法的完整逻辑过程"></a>类的构造方法的完整逻辑过程</h3><p>先考虑主构造函数，当主构造函数不够用时，再引入从构造函数。最初的主构造函数是这样的:步骤1通过主构造函数的参数传入数据，步骤2在类里定义所需的属性，步骤3在init代码块里对属性做初始化/赋值操作，这三个步骤分工明确，前后关联，共同完成了一个类的构造。</p>
<p>为了简化，Kotlin支持步骤2和步骤1合并操作，在主构造函数参数前加var/val；</p>
<p>支持步骤3和步骤2合并，对定义的属性直接赋值。支持步骤3和步骤2和步骤1合并操作，使用主构造函数的默认参数表达。</p>
<p>当然这些合并带来简便的同时，降低了构造的能力。</p>
<p>最初的状态（步骤1，步骤2，步骤3都存在）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User(_sickName: String)&#123;</span><br><span class="line"></span><br><span class="line">    val sickName: String</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">    	println(&quot;init&quot;)</span><br><span class="line">        sickName = _sickName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤2和步骤1的合并，在主构造函数里传参和定义类的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User(val sickName: String)&#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤3，步骤2和步骤1的合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open class User private constructor(val sickName: String = &quot;Kotlin&quot;, var age: Int)&#123;</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>Java中需要重载构造方法的场景大多数都被Kotlin参数默认值和参数命名的语法特性涵盖了</p>
<h4 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> open class AirBook(name: String, val year: Int, val size: Int) &#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: String, year: Int) : this(name, year, 22)&#123;</span><br><span class="line">		println(&quot;constructor&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> class MacBookPro: AirBook&#123;</span><br><span class="line"></span><br><span class="line">    public constructor(name: String, year: Int) : super(name, year) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public constructor(name: String, year: Int, size: Int) : super(name, year, size)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类在创建的时候，必须调用父类的构造函数，如果其父类还有父类，仍然要调用父类的父类的构造函数，直至顶层的基类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open class AirBook(name: String, val year: Int, val size: Int)&#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(name: String, year: Int) : this(name, year, 22)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数可以调用当前自身的构造函数，因为自身的构造函数必然有至少一个调用了父类的构造函数。</p>
<h3 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h3><p>在kotlin里，一个属性 = 字段 + 属性访问器；这里的字段是Java里的成员变量</p>
<p>属性访问器分为读访问器getter，和写访问器setter</p>
<p>访问器里存在field字段，用来连接写访问器和读访问器，作为两者的通信桥梁</p>
<p>val修饰的属性只有读访问器，var修饰的属性既有有读也有写访问器</p>
<p>Kotlin引入属性访问器后，凡事对属性进行赋值操作，就会调用属性的写访问器setter；读取值的操作对应调用的是属性的读访问器</p>
<p>那么如果我们要自定义一个类似Java里的setter方法，要怎么做呢？</p>
<p>通过var变量的私有setter来实行</p>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TableLamp(val name: String, lightness: Int)&#123;</span><br><span class="line"></span><br><span class="line">    var lightness: Int = 1</span><br><span class="line">    private set</span><br><span class="line">    </span><br><span class="line">    fun setupLightness(lightness: Int)&#123;</span><br><span class="line">        this.lightness = lightness</span><br><span class="line">        println(&quot;setupLightness lightness = $lightness&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样对属性lightness的修改，只能通过setupLightness方法。</p>
<h3 id="修饰词final-open-abstract相互影响和使用"><a href="#修饰词final-open-abstract相互影响和使用" class="headerlink" title="修饰词final, open, abstract相互影响和使用"></a>修饰词final, open, abstract相互影响和使用</h3><p>Kotlin的函数，类默认是final的，如果想重写函数，类有子类，则需使用open修饰。abstract修饰的函数和类，意味着有open的特性。这和Java的用法是一致的。</p>
<h3 id="Kotlin自带的特殊类"><a href="#Kotlin自带的特殊类" class="headerlink" title="Kotlin自带的特殊类"></a>Kotlin自带的特殊类</h3><p>数据类，嵌套类，内部类，密封类的基本写法这里就略去不谈。</p>
<h4 id="数据类data"><a href="#数据类data" class="headerlink" title="数据类data"></a>数据类data</h4><p>data修饰的类，必须有主构造函数，且主构造每个入参必须都val或var修饰</p>
<p>data修饰补充的方法里的所用的变量取决于主构造函数的入参</p>
<h4 id="嵌套类和内部类"><a href="#嵌套类和内部类" class="headerlink" title="嵌套类和内部类"></a>嵌套类和内部类</h4><p>定义在某个类内部并用inner修饰的类称为内部类</p>
<p>嵌套类可以类比Java的静态内部类，Kotlin的内部类类比Java的内部类，他们含有外部类的引用。<strong>与Java内部类不同的是，Kotlin的内部类能对外部类的变量进行写操作。</strong></p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TextView&#123;</span><br><span class="line">    var counter: Int= 0</span><br><span class="line">    </span><br><span class="line">    inner class Operator&#123;</span><br><span class="line">        fun calculate()&#123;</span><br><span class="line">            counter ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类Operator的成员函数可以写外部类的counter属性，这在Java里是做不到的。</p>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>sealed关键词修饰的类，表达有限个子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sealed class Color constructor(val name: String)</span><br><span class="line"></span><br><span class="line">class Red : Color(&quot;Red&quot;)</span><br><span class="line"></span><br><span class="line">class Green : Color(&quot;Green&quot;)</span><br><span class="line"></span><br><span class="line">class Blue : Color(&quot;Blue&quot;)</span><br><span class="line"></span><br><span class="line">class Gray : Color(&quot;Gray&quot;)</span><br></pre></td></tr></table></figure>
<p>上述写法，编译器就会知道，Color的子类的数量，此例Color一共只有四个子类，分别是：Red，Green， Blue， Gray。如果增加或删除Color的子类，编译器是能感知到的。密封类的子类可以作为嵌套类，也可以写在密封类所在的文件里，但是不能写在其他文件里。</p>
<p>举个和When搭配的应用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun testSealed(color: Color): Int =</span><br><span class="line">        when (color) &#123;</span><br><span class="line">            is Red -&gt; &#123;</span><br><span class="line">                println(&quot;Red&quot;)</span><br><span class="line">                1</span><br><span class="line">            &#125;</span><br><span class="line">            is Green -&gt; &#123;</span><br><span class="line">                println(&quot;Green&quot;)</span><br><span class="line">                2</span><br><span class="line">            &#125;</span><br><span class="line">            is Blue -&gt; &#123;</span><br><span class="line">                println(&quot;Blue&quot;)</span><br><span class="line">                3</span><br><span class="line">            &#125;</span><br><span class="line">            is GRAY -&gt;&#123;</span><br><span class="line">                println(&quot;GRAY&quot;)</span><br><span class="line">                4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>密封类的意义：</strong><br>如果不用密封类，使用when总是不得不添加一个默认分支。更重要的是，如果你添加了一个新的子类，编译器并不能发现有地方改变了。如果你忘记了添加一个分支，就会选择默认的选项，这可能导致潜在的bug。</p>
<p>使用密封类就能解决上述的问题。</p>
<h2 id="Object的使用"><a href="#Object的使用" class="headerlink" title="Object的使用"></a>Object的使用</h2><p>声明一个类并创建一个对应的实例。与类一样，对象可以包含属性，方法，初始化语句块等的声明。对象声明可以继承类和实现接口，尤其不包含状态的时候很适用，也可以有扩展函数。</p>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>创建单一的实例，对象声明在定义的时候就创建了，不需要在代码的其他地方调用构造方法。</p>
<p>因此，对象声明不允许有构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object NameComparator : Comparator&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    override fun compare(o1: String, o2: String): Int &#123;</span><br><span class="line">        return o1.compareTo(o2, true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java调用上述代码，则需要通过INSTANCE来调用，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveFileComparator.INSTANCE.compare(&quot;abc&quot;, &quot;abe&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>创建单一的实例，可以实现Java里访问类的私有成员的静态方法</p>
<p>在对象声明的基础上，使用companion关键字来标记，这样做就获得了直接通过容器类名称来访问这个对象的方法和属性的能力。</p>
<p>举个例子，实现CarFactory工厂</p>
<p>通过对象声明的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CarFactory&#123;</span><br><span class="line">    object Instance&#123;</span><br><span class="line">        fun newCar(name: String): Car&#123;</span><br><span class="line">            return Car(name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fun newRedCar(name: String): Car&#123;</span><br><span class="line">            return Car(name, Red())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<pre><code>CarFactory.Instance.newCar(&quot;Mini Cooper&quot;)
</code></pre><p>通过伴生对象的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CarFactory&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun newCar(name: String): Car&#123;</span><br><span class="line">            return Car(name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fun newRedCar(name: String): Car&#123;</span><br><span class="line">            return Car(name, Red())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<pre><code>CarFactory.newCar(&quot;Mini Cooper&quot;)
</code></pre><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>既然是表达式，就意味着有返回值</p>
<p>与Java的匿名内部类只能扩展一个类或者实现一个接口不同，Kotlin的匿名对象可以实现多个接口或者不实现接口。</p>
<p>与对象声明不通，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。<strong>在对象表达式里不经可以访问创建它的函数中的变量，还可以修改变量的值</strong></p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun countClick(view: View)&#123;</span><br><span class="line">    var clickCount = 0</span><br><span class="line">    </span><br><span class="line">    view.addClick(object : IClick&#123;</span><br><span class="line">        </span><br><span class="line">        override fun onClick() &#123;</span><br><span class="line">            clickCount ++ </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>object对象在Kotlin中的意义：</p>
<ol>
<li>实现Java里静态的功能，等效实现静态调用</li>
<li>代替Java匿名内部类书写</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface IFocus &#123;</span><br><span class="line">    val focusName: String</span><br><span class="line"></span><br><span class="line">    fun showOff()&#123;</span><br><span class="line">        println(&quot;IFocus foucusName length = $&#123;focusName.length&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun onFocus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IFocus接口声明函数，让子类实现，默认方法showOff，和抽象方法onFucus</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class View : IFocus&#123;</span><br><span class="line"></span><br><span class="line">    override val focusName: String</span><br><span class="line">        get() = &quot;View&quot;</span><br><span class="line"></span><br><span class="line">    override fun onFocus() &#123;</span><br><span class="line">        showOff()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View实现IFocus接口，focusName由View来确定，获取focusName逻辑写在IFocus的默认方法里。调用如下</p>
<pre><code>val view = View()
view.onFocus()
</code></pre><p>调用返回内容</p>
<blockquote>
<p>IFocus foucusName length = 4</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="访问权限修饰词"><a href="#访问权限修饰词" class="headerlink" title="访问权限修饰词"></a>访问权限修饰词</h3><p><strong>protected在Kotlin和Java的区别</strong><br>kotlin中protected只能是其子类和自身才能访问；Java中则是同包下所有文件和不同包的子类能访问</p>
<p><strong>Kotiln访问权限由小到大排列依次是：</strong><br>private, protected, internal, public</p>
<p>Kotlin函数和属性默认是public的，Java的默认是包级访问范围，即同一个包下的类能访问。<br>Kotlin缺少包级别访问控制，而多了一个模块访问范围internal。internal表示同一个项目模块下的类都能访问</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/27093660/" target="_blank" rel="noopener">Kotlin实战</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/05/07/Kotlin第三讲-拓展函数及其他/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/Kotlin第三讲-拓展函数及其他/" itemprop="url">Kotlin第三讲-拓展函数及其他</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T21:36:00+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集合的创建与遍历"><a href="#集合的创建与遍历" class="headerlink" title="集合的创建与遍历"></a>集合的创建与遍历</h2><p>Kotlin没有采用它自己的集合类，而是采用标准的Java集合类。大部分Kotlin的标准库是由Java类的拓展函数组成的。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>Kotlin中对集合增加了一个新的接口MutableList，实现该接口的集合是可变集合。Kotlin中，集合分为可变集合和不可变集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    override fun add(element: E): Boolean</span><br><span class="line"></span><br><span class="line">    override fun remove(element: E): Boolean</span><br><span class="line"></span><br><span class="line">    override fun addAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line"></span><br><span class="line">    public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean</span><br><span class="line"></span><br><span class="line">    override fun removeAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    override fun retainAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    override fun clear(): Unit</span><br><span class="line"></span><br><span class="line">    public operator fun set(index: Int, element: E): E</span><br><span class="line"></span><br><span class="line">    public fun add(index: Int, element: E): Unit</span><br><span class="line"></span><br><span class="line">    public fun removeAt(index: Int): E</span><br><span class="line"></span><br><span class="line">    override fun listIterator(): MutableListIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    override fun listIterator(index: Int): MutableListIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MutableList接口提供了增加和删除集合元素的能力。</p>
<h4 id="创建不可变集合"><a href="#创建不可变集合" class="headerlink" title="创建不可变集合"></a>创建不可变集合</h4><pre><code>val list = listOf&lt;String&gt;(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
val letter = list[0]
var list1 = listOfNotNull&lt;Int&gt;(1, 4, 8)
</code></pre><h4 id="创建可变集合"><a href="#创建可变集合" class="headerlink" title="创建可变集合"></a>创建可变集合</h4><pre><code>val list2 = arrayListOf&lt;Int&gt;(1, 2, 3, 4)
list2.set(0, 10)
list2[0] = 10
list2.add(5)
println(&quot;list2 = $list2&quot;)

val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
list3.add(&quot;d&quot;)
println(&quot;e = $list3&quot;)
println(&quot;last element = ${list3.last()}&quot;)

val list4 = mutableMapOf&lt;String, String&gt;(&quot;1&quot; to &quot;A&quot;, &quot;2&quot; to &quot;B&quot;)
val list5 = mutableSetOf&lt;String&gt;(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;)
</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>Kotlin的函数比Java函数强大的地方之一是入参可以有默认值，即默认参数；</p>
<p>在Kotlin调用函数时，可以指定入参的名称，即命名参数；</p>
<p>与Java不同，Koltin表示可变参数，不是参数后面加三个点，，而是在入参前加vararg关键词即可。Kotlin中存在一个展开运算符 – *（星号），它和可变参数搭配使用；作用是把一个数组展开成可变参数传入</p>
<p>详细说明，可看这篇文章<a href="https://zhuanlan.zhihu.com/p/34822964" target="_blank" rel="noopener">Kotlin里的输入参数</a></p>
<h2 id="顶层函数与属性"><a href="#顶层函数与属性" class="headerlink" title="顶层函数与属性"></a>顶层函数与属性</h2><ol>
<li>很多代码并不能归属到任何一个类中，有时一个操作对应两个不同的类的对象，而且重要性相差无几。</li>
<li>有时存在一个基本的对象，但不想通过实例函数来添加操作，让它的API继续膨胀。</li>
</ol>
<p>在Java里，我们使用静态方法。Kotlin里没有static修饰词，它一种方式，使用顶层函数来实现相同的效果。</p>
<h3 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h3><p>实现一个功能，把集合中元素添加前缀，后缀，用分隔符间隔展示</p>
<p>在kt类里直接写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const val counter: Int = 0</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; joinToString(</span><br><span class="line">        collection: Collection&lt;T&gt;,</span><br><span class="line">        separator: String,</span><br><span class="line">        prefix: String,</span><br><span class="line">        postfix: String</span><br><span class="line">                                ): String &#123;</span><br><span class="line">    val sb = StringBuffer(prefix)</span><br><span class="line">    for ((index, element) in collection.withIndex()) &#123;</span><br><span class="line">        if (index &gt; 0) &#123;</span><br><span class="line">            sb.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(postfix)</span><br><span class="line"></span><br><span class="line">    return sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶层函数是包内成员，包内直接访问。若包外访问，需要import（IDEA等开发工具会为你自动import）</p>
<p>顶层函数是都是静态函数，默认函数所在的文件名加KT作为容器类，比如上述joinToString方法是在Example3_2文件名下的顶层函数，在Java里调用是时</p>
<pre><code>Example3_2Kt.joinToString(collection, &quot;,&quot;, &quot;[&quot;, &quot;]&quot;);
</code></pre><p>如果我想更改调用静态方法的容器类的类名为StringUtils，则需要在kotlin文件里添加</p>
<pre><code>@file:JvmName(&quot;StringUtils&quot;)
</code></pre><p>这时候调用形式如下：</p>
<pre><code>StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;);
</code></pre><h3 id="顶层属性"><a href="#顶层属性" class="headerlink" title="顶层属性"></a>顶层属性</h3><p>counter就是顶层属性，等效于容器类的静态成员变量，即Java里如下写法</p>
<pre><code>public static final int counter = 0;    
</code></pre><h2 id="拓展函数与属性"><a href="#拓展函数与属性" class="headerlink" title="拓展函数与属性"></a>拓展函数与属性</h2><h3 id="拓展函数基本使用"><a href="#拓展函数基本使用" class="headerlink" title="拓展函数基本使用"></a>拓展函数基本使用</h3><pre><code>StringUtils.joinToString(collection, &quot;,&quot; , &quot;[&quot;, &quot;]&quot;);
</code></pre><p>每次调用上述实现的joinToString方法传入四个参数，有点多，我希望减少入参数量。StringUtils是工具类类名，工具类类名在整个调用过程中是不够高效的。达到优雅的途径之一就是做到高效而简洁。这个工具类具体是什么名字并不会影响这个函数的输入和输出，这个类名的意义是作为joinToString容器的标示，如果能把其中一个入参名作为类名，这个入参同时做两件事：传入自身到函数体里，作为调用的句柄名。</p>
<p>强大的Kotlin为我们实现了这样的能力：扩展函数。把上述方法生命为一个拓展函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator: String = &quot;,&quot;, prefix: String = &quot;(&quot;, postfix: String = &quot;)&quot;)&#123;</span><br><span class="line">    val sb = StringBuilder()</span><br><span class="line">    sb.append(prefix)</span><br><span class="line">    for((index, element) in this.withIndex())&#123;</span><br><span class="line">        if(index &gt; 0)&#123;</span><br><span class="line">            sb.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(element.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(postfix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接收者类型：</strong>函数名前的类，上例Collection就是该扩展函数的接收者类型</p>
<p><strong>接收者对象：</strong>接收者类的实例，上例this.withIndex方法的this指代的就是Collection对象，是该扩展函数接收者对象</p>
<p>这时候我们要使用joinToString方法，变成这样用了</p>
<pre><code>val list3 = mutableListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
list3.joinToString(&quot;_&quot;, &quot;[&quot;, &quot;]&quot;)
</code></pre><h3 id="导入范围"><a href="#导入范围" class="headerlink" title="导入范围"></a>导入范围</h3><p>需要进行导入扩展函数才能生效，好在开发工具为我们自动导入了。如果定义的扩展函数所在的类和其接收者类型的类在一个包下，可以不需要显式导入。</p>
<p>有一种情况，如果你定义的扩展函数名和其他包里定义的函数名相同，你需要导入全类名以示区分。还有另一种方式，通过as在导入的地方重命名扩展函数名</p>
<pre><code>import sugarya.chapter3.joinToString as jts
</code></pre><p>这时候，就可以调用jts就相当于调用joinToString方法</p>
<h3 id="扩展函数的本质和特性"><a href="#扩展函数的本质和特性" class="headerlink" title="扩展函数的本质和特性"></a>扩展函数的本质和特性</h3><p>其实，Kotlin把上述代码翻译到JVM上运行时。<strong>拓展函数的本质是：把接收者对象作为第一个入参的函数</strong>。通常我们在顶层位置定义扩展函数，这样扩展函数就能被其他包的文件调用。因此，扩展函数并没有改变接收者类里的代码，扩展函数并不是类的一部分，它是声明在类之外的，却能像成员变量那般使用。</p>
<p>像成员变量那般使用，扩展函数和成员变量不是一回事，它们之间是有区别的</p>
<ol>
<li>扩展函数不能访问私有或者受保护的成员，因为接收者对象只是静态方法的一个入参，这个入参有大的访问能力，扩展函数就是多大访问能力。</li>
<li>扩展函数不能被接收者类的子类重写／继承。前面说了，扩展函数只是静态方法，并不是真实的接收者里的成员，自然也就无法重写了。</li>
</ol>
<p>对于第2点的理解，我们举一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String, var age: Int) : Animal(name)</span><br><span class="line"></span><br><span class="line">//拓展定义是写在Example2_4.Kt文件里</span><br><span class="line">fun Animal.move()&#123;</span><br><span class="line">    println(&quot;animal move&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun Person.move()&#123;</span><br><span class="line">    println(&quot;Person move&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val animal: Animal = Person(&quot;Kotlin&quot;, 5)</span><br><span class="line">animal.move()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code>animal move
</code></pre><p>animal.move是拓展函数，转化为静态方法是Example2_4.move(animal),所以，move方法调用的就是Animal类下的move。</p>
<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>扩展属性是对扩展函数能力的弱化／简化使用。相当于Java里第一个参数是接收者对象的静态getter方法和setter方法。扩展函数和扩展属性搭配使用，在扩展函数里访问扩展属性。举个例子</p>
<pre><code>val Animal.length: Int get() = this.name.length * 10

fun Animal.move(){
    println(&quot;animal move ${this.length}&quot;)
}
</code></pre><h3 id="扩展函数的应用"><a href="#扩展函数的应用" class="headerlink" title="扩展函数的应用"></a>扩展函数的应用</h3><p>看几个扩展函数的应用例子</p>
<h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p>有一个字符串“ab.cd12.ef”，需要分割成三部分：ab, cd12, ef</p>
<p>使用Java，我们很容易写成这样</p>
<pre><code>String msg = &quot;ab.cd12.ef&quot;;
String[] strings = msg.split(&quot;.&quot;);
</code></pre><p>java里split（）方法入参的字符串表示的正则表达式，在正则表达式里“.”表示任意字符，所以，如果照上面所写，返回为空，找不到字符。</p>
<p>使用Java正确实现是：</p>
<pre><code>String msg = &quot;ab.cd12.ef&quot;;
String[] strings = msg.split(&quot;\\.&quot;);
</code></pre><p>Kotlin在此基础上，通过扩展函数扩展字符串方法，通过默认参数实现重载效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].</span><br><span class="line"> *</span><br><span class="line"> * @param delimiters One or more strings to be used as delimiters.</span><br><span class="line"> * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.</span><br><span class="line"> * @param limit The maximum number of substrings to return. Zero by default means no limit is set.</span><br><span class="line"> *</span><br><span class="line"> * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from</span><br><span class="line"> * the beginning to the end of this string, and matches at each position the first element in [delimiters]</span><br><span class="line"> * that is equal to a delimiter in this instance at that position.</span><br><span class="line"> */</span><br><span class="line">public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123;</span><br><span class="line">    if (delimiters.size == 1) &#123;</span><br><span class="line">        val delimiter = delimiters[0]</span><br><span class="line">        if (!delimiter.isEmpty()) &#123;</span><br><span class="line">            return split(delimiter, ignoreCase, limit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map &#123; substring(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin实现</p>
<pre><code>&quot;ab.cd12.ef&quot;split(&quot;.&quot;)
</code></pre><p>Kotlin里用Regex类表示正则，使用正则实现如下</p>
<pre><code>val regex = Regex(&quot;\\.&quot;)
val result = &quot;ab.cd12.ef&quot;.split(regex.toPattern())
</code></pre><p>解析字符串在Kotlin变得更容易了，除了split，Kotlin还提供了其他方法，再看一个例子</p>
<h4 id="解析文件路径"><a href="#解析文件路径" class="headerlink" title="解析文件路径"></a>解析文件路径</h4><p>解析一个文件路径：“/Users/mine/Documents/MyDocument/Photoes／546294_308008399296566_779316797_n.jpg”,获取目录路径，文件名，文件拓展名</p>
<p>Kotlin代码实现</p>
<pre><code>val msg = &quot;/Users/mine/Documents/MyDocument/Photoes/546294_308008399296566_779316797_n.jpg&quot;
val dirPath = msg.substringBeforeLast(&quot;/&quot;)
val filePath = msg.substringAfterLast(&quot;/&quot;)
val fileName = filePath.substringBeforeLast(&quot;.&quot;)
val extendName = filePath.substringAfterLast(&quot;.&quot;)

println(&quot;directory path = $dirPath, fileName = $fileName, extendName = $extendName&quot;)
</code></pre><p>输出：</p>
<pre><code>directory path = /Users/mine/Documents/MyDocument/Photoes, fileName = 546294_308008399296566_779316797_n, extendName = jpg
</code></pre><h2 id="局部属性"><a href="#局部属性" class="headerlink" title="局部属性"></a>局部属性</h2><p>在Java里，函数的最小的作用域是在一个类里（private修饰的方法），而Kotlin引入局部函数–允许在函数里定义一个函数，让函数（方法）的最小作用域降到一个函数体里。提供更小粒度的复用，这样有什么意义呢？</p>
<p>这样是有意义的。</p>
<p>没有局部函数的特性的Java语言里，对方法最小作用域的组织方式是这样的：一个复杂的类里有很多方法，当方法A里的代码行数很多时，通常拆分出几个新的方法a1，a2，a3等等，这些新的方法之间如果存在整体的逻辑关系，就能组合成一个内部类，a1，a2，a3是该内部类的方法。直接在A里新建内部类并调用即可。外部类的其他方法比如方法B也能方便的调用。</p>
<p>Kotlin局部函数提供了比上述Java更细致的代码组织方式：如果我们只在一个方法A里多次用到，这时候在方法A里，定义a1，a2，a3，在方法A里多次使用方法a1，a2，a3。这种方式相较于上面的内部类组织方式，带来的益处是降低定义内部类带来的语法开销。</p>
<p>对于什么时候引入局部函数，我们有了下述认识：<br>当需要在方法粒度上多次调用一段逻辑时。具体的场景有，登录验证，表单数据校验。</p>
<h2 id="中缀调用"><a href="#中缀调用" class="headerlink" title="中缀调用"></a>中缀调用</h2><ol>
<li>对只有一个参数的函数使用中缀调用</li>
<li>中缀调用的函数，需要对其使用inflix修饰符</li>
<li>中缀不仅适用于成员函数也适用于扩展函数</li>
</ol>
<p>举个中缀的例子</p>
<pre><code>val pair: Pair&lt;String, String&gt; = &quot;a&quot; to2 &quot;A&quot;
</code></pre><p>上面的中缀调用是怎么定义呢？</p>
<pre><code>infix fun &lt;T, V&gt; T.to2(v: V): Pair&lt;T, V&gt; = Pair(this, v)
</code></pre><h2 id="三重引号的字符串"><a href="#三重引号的字符串" class="headerlink" title="三重引号的字符串"></a>三重引号的字符串</h2><p>三重引号字符串不仅在于避免转义符，而且可以包含任何字符，包括换行符。</p>
<p>看一个佛祖镇楼的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    val bless = &quot;&quot;&quot;</span><br><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  88&quot; . &quot;88</span><br><span class="line">                  (| -_- |)</span><br><span class="line">                  O\  =  /O</span><br><span class="line">               ____/`---&apos;\____</span><br><span class="line">             .&apos;  \\|     |//  `.</span><br><span class="line">            /  \\|||  :  |||//  \</span><br><span class="line">           /  _||||| -:- |||||-  \</span><br><span class="line">           |   | \\\  -  /// |   |</span><br><span class="line">           | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">           \  .-\__  `-`  ___/-. /</span><br><span class="line">         ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">      .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">                   `=---=&apos;</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">         佛祖保佑       永无BUG</span><br><span class="line">         &quot;&quot;&quot;</span><br><span class="line">    println(bless)</span><br></pre></td></tr></table></figure>
<p>这样控制台按原样格式输出佛祖图</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这是Kotlin实战第三章涉及的所有知识点，结合自己的理解整理归纳成本篇文章。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/04/05/Kotlin第二讲-初出茅庐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/Kotlin第二讲-初出茅庐/" itemprop="url">Kotlin第二讲-初出茅庐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T13:03:00+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>年前快速地过了一遍Kotlin语法。这回计划花上半年的时间，从代码细节上重新系统的梳理一遍Kotlin语言。当然，性价比最高的方式是通过Kotlin开发项目来学习。</p>
<h3 id="同样表示变量var与val有什么区别？"><a href="#同样表示变量var与val有什么区别？" class="headerlink" title="同样表示变量var与val有什么区别？"></a>同样表示变量var与val有什么区别？</h3><p>val = 加了final的变量</p>
<pre><code>val message = &quot;Kotlin&quot; // final String message = &quot;Kotlin&quot;;
var count = 0

val msg: String = &quot;Kotlin&quot; //value
var count2: Int = 0  // variant

val p = Person(&quot;Kotlin&quot;)
p.name
/*
    Q1 var与val什么区别？
    val = 加了final变量
 */

val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;)
languageList.add(&quot;Go&quot;)
</code></pre><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>类比Java Web JSP里的EL表达式</p>
<pre><code>println(&quot;message = &quot; + message)

println(&quot;message = $message&quot;)
println(&quot;count = ${count}&quot;)
println(&quot;language list size = ${languageList.size}&quot;)
println(&quot;\$: ${count2}&quot;)
</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>fun max(a: Int, b: Int): Int {
    if (a &gt; b) {
        return a
    }
    return b
}

fun max2(a: Int, b: Int) = if (a &gt; b) a else b
</code></pre><p><strong>问题：表达式和语句有什么区别？</strong></p>
<p>表达式有返回值，语句没有。表达式可以包含在语句或表达式里。语句与语句之间是并列的</p>
<p>Kotlin常见的表达式有：if，when，try{}catch </p>
<h3 id="关于When"><a href="#关于When" class="headerlink" title="关于When"></a>关于When</h3><pre><code>fun filter(a: Int) {
    when (a) {
        0 -&gt; println(&quot;0&quot;)
        1 -&gt; println(&quot;1&quot;)
        in 2..10 -&gt; println(&quot;in 2..10&quot;)
        !in 11..20 -&gt; println(&quot;! in 11..20&quot;)
        Integer.parseInt(&quot;21&quot;) -&gt; println(&quot;21&quot;)
        22, 23 -&gt; println(&quot;22 , 23&quot;)
        else -&gt; println(&quot;else&quot;)
    }
}

fun filter2(x: Any) {
    when (x) {
        is Int -&gt; println(&quot;Int&quot;)
        is String -&gt; println(&quot;String&quot;)
        is Person -&gt; print(&quot;JavaPerson&quot;)
    }
}


fun filter3(x: Any) =
        when (x) {
            is Int -&gt; {
                val a = 3
                &quot;Int&quot;
            }
            is String -&gt; {
                val b = &quot;&quot;
                &quot;String&quot;
            }
            else -&gt; {
                &quot;else&quot;
            }
        }

fun filter4(x: Any) =
        when {
            x is Int -&gt; &quot;Int&quot;
            x is String -&gt; &quot;String&quot;
            else -&gt; &quot;else&quot;
        }
}
</code></pre><h3 id="关于Kotlin里的循环和迭代"><a href="#关于Kotlin里的循环和迭代" class="headerlink" title="关于Kotlin里的循环和迭代"></a>关于Kotlin里的循环和迭代</h3><pre><code>for (i in 0..5) {
    println(&quot;i : $i&quot;)
}

for(j in 0 until 5){
    println(&quot;j : $j&quot;)
}

for(k in 5 downTo 0){
    println(&quot;k : $k&quot;)
}


val languageList = arrayListOf&lt;String&gt;(&quot;Kotlin&quot;, &quot;Java&quot;, &quot;Go&quot;)
for((index, value) in languageList.withIndex()){
    println(&quot;index = $index, value = $value&quot;)
}

val languageMap = hashMapOf&lt;String, String&gt;(&quot;j&quot; to &quot;Java&quot;, &quot;k&quot; to &quot;Kotlin&quot;, &quot;g&quot; to &quot;Go&quot;)
for((key, v) in languageMap){
    println(&quot;$key : map value = $v&quot;)
}
</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><strong>背景知识：</strong></p>
<p>Java异常继承自Throwable，分为两种</p>
<ol>
<li>运行时异常RuntimeException，也叫非受检异常</li>
<li>受检异常 CheckedException</li>
</ol>
<p>Java处理异常有两种方式：</p>
<ol>
<li>try catch 捕获异常</li>
<li>throws抛出异常</li>
</ol>
<p>先看下Java的例子</p>
<pre><code>//非受检异常
private static void testRuntimeException() {
    int i = Integer.parseInt(&quot;!&quot;);
}

//受检异常
private void testCheckedException() {
    try {
        FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
}

private void testCheckedException2() throws FileNotFoundException {
    FileInputStream fileInputStream = new FileInputStream(&quot;/temp&quot;);
}
</code></pre><p>从上面程序可知：Java强制要求开发人员处理受检异常.</p>
<p><strong>常见的受检异常：</strong> Exception, FileNotFoundException, IOException, SQLException</p>
<p><strong>常见的未检查异常：</strong> NullPointerException, ClassCastException, ArrayIndexsOutOfBoundsException, ArithmeticException, NumberFormatException</p>
<p>上述Kotlin下的代码如下：</p>
<pre><code>fun testRuntimeException(){
    val i = Integer.parseInt(&quot;!&quot;)
}

fun testCheckedException(){
    val fis = FileInputStream(&quot;/temp&quot;)
    throw IllegalArgumentException(&quot;&quot;)
}
</code></pre><p>可知：与Java不同，对受检异常，Kotlin不强制开发人员处理。</p>
<p><strong>小结</strong><br>对于异常，Kotlin与Java的不同之处如下：</p>
<ol>
<li>Kotlin不区分受检异常和非受检异常, 都不强制处理异常</li>
<li>Kotlin不存在throws，不允许抛出异常</li>
</ol>
<h4 id="当try-catch-作为表达式的使用时"><a href="#当try-catch-作为表达式的使用时" class="headerlink" title="当try{}catch{}作为表达式的使用时"></a>当try{}catch{}作为表达式的使用时</h4><pre><code>fun readNumber(){
    val a = try {
        val c = &quot;&quot;
        Integer.parseInt(&quot;!&quot;)
    }catch (e: Exception){
        e.printStackTrace()
        0
    }

    println(&quot;a = $a&quot;)
}
</code></pre><h3 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum class Season&#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum class Color(val r: Int, val g: Int, val b: Int)&#123;</span><br><span class="line">    RED(255, 0, 0),</span><br><span class="line">    GREEN(0, 255, 0),</span><br><span class="line">    BLUE(0,0,255);</span><br><span class="line"></span><br><span class="line">    fun rgb() = r * 255 * 255 + g * 255 + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于类和属性"><a href="#关于类和属性" class="headerlink" title="关于类和属性"></a>关于类和属性</h3><p>我们看下Java的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line">    private final int width;</span><br><span class="line">    private final int height;</span><br><span class="line">    private final boolean isSquare;</span><br><span class="line"></span><br><span class="line">    public Rectangle(int width, int height, boolean isSquare) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.isSquare = isSquare;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isSquare() &#123;</span><br><span class="line">        return isSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">等效Kotlin实现</span><br></pre></td></tr></table></figure>
<p>class Rectangle(val width: Int, val height: Int){<br>    val isSquare get() = width == height<br>}<br><code>`</code></p>
<p>Java中，成员变量就是一个字段，访问成员变量通过setter或者getter方法，相当于变量的访问器。Kotlin把这个概念作为语言层面的支持了。kotlin中每个属性，如果是val变量就自带访问器get(),如果是var属性则自带get()和set()</p>
<p>因此Kotlin中，一个属性 = 字段 + 访问器；这是Kotlin对Java语言的进化。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>该文是对Kotlin实战一书第二章知识点代码的梳理和总结，完整代码，已上传到GitHub上，<a href="https://github.com/Sugarya/KotlinInActionExample" target="_blank" rel="noopener">KotlinInActionExample 传送门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sugarya.github.io/2018/03/22/ Kotlin第一讲-输入参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ethan Ruan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ethan Ruan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/ Kotlin第一讲-输入参数/" itemprop="url">Kotlin第一讲-输入参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T15:48:00+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin编程之旅/" itemprop="url" rel="index">
                    <span itemprop="name">Kotlin编程之旅</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本专栏的第一篇，分享下Kotlin里输入参数的特性</p>
<h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>我们先来看一个需求：<br>把集合里每个元素用分号分隔并打印到括号里，例如（Java,Kotlin,Python,JavaScript,Ruby,Go）</p>
<p>我还想改变输出格式，前缀，分隔符，后缀都有可能发生改变，于是提取出参数，Java实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SeparatorUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param collections 集合</span><br><span class="line">     * @param prefix 前缀</span><br><span class="line">     * @param separator 分隔符</span><br><span class="line">     * @param postfix 后缀</span><br><span class="line">     * @param &lt;T&gt; 集合泛型</span><br><span class="line">     * @return 分隔后的结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; String separator(Collection&lt;T&gt; collections, String prefix, String separator, String postfix) &#123;</span><br><span class="line">        Objects.requireNonNull(collections);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(prefix);</span><br><span class="line">        int size = collections.size();</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (T t : collections) &#123;</span><br><span class="line">            sb.append(t.toString());</span><br><span class="line">            if(index &lt; size - 1)&#123;</span><br><span class="line">                sb.append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(postfix);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>private static void testSeparator(){
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;Java&quot;);
    list.add(&quot;Kotlin&quot;);
    list.add(&quot;Python&quot;);
    list.add(&quot;JavaScript&quot;);
    list.add(&quot;Ruby&quot;);
    list.add(&quot;Go&quot;);

    String separator = SeparatorUtils.separator(list, &quot;(&quot;, &quot;,&quot;, &quot;)&quot;);
    System.out.println(&quot;separator result = &quot; + separator);
}
</code></pre><p>输出结果：  </p>
<pre><code>separator result = (Java,Kotlin,Python,JavaScript,Ruby,Go)
</code></pre><p>这是一个完整的编码过程，来了一个需求，通过新增类和方法，在需要的地方，调用实现。需求被解决了，代码默默地在角落发挥着作用。</p>
<p>转眼三个月过去，团队里来了新人，他阅读到testSeparator方法；当读到SeparatorUtils.separator（）方法，对于传的四个参数代表什么含义，乍看之下他并不清楚，需要点进去读实现代码或者看注释说明才确切明白。那么还有没有更易于阅读的方式呢？Kotlin的命名参数能做到。</p>
<p>SeparatorUtils.separator方法用Kotlin重写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; joinToString(</span><br><span class="line">        collection: Collection&lt;T&gt;,</span><br><span class="line">        separator: String,</span><br><span class="line">        prefix: String,</span><br><span class="line">        postfix: String</span><br><span class="line">): String &#123;</span><br><span class="line">    val sb = StringBuffer(prefix)</span><br><span class="line"></span><br><span class="line">    for ((index, element) in collection.withIndex()) &#123;</span><br><span class="line">        if (index &gt; 0) &#123;</span><br><span class="line">            sb.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(postfix)</span><br><span class="line"></span><br><span class="line">    return sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用joinToString方法可以这样</p>
<pre><code>val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
val s = joinToString(list, postfix = &quot;)&quot;, separator = &quot;,&quot;, prefix = &quot;(&quot;)
println(&quot;s = $s&quot;)
</code></pre><p>上述即是命名参数，在调用处使用，形式为：参数名=参数值；<br>这样的入参带来了两个便利：</p>
<ol>
<li>便于阅读，按顺序阅读代码就能知晓方法参数的含义</li>
<li>调用时入参的位置可以任意（调用的入参顺序和定义的入参的顺序允许不一致）</li>
</ol>
<p>这样看起来真不错的</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>定义函数时，给入参提供默认值，在调用处，如果不传入实参，则该参数使用默认值，可用于方法重载。例如对上述Kotlin代码的joinToString方法改变入参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@JvmOverloads</span><br><span class="line">fun &lt;T&gt; joinToString(</span><br><span class="line">        collection: Collection&lt;T&gt;,</span><br><span class="line">        separator: String = &quot;,&quot;,</span><br><span class="line">        prefix: String = &quot;(&quot;,</span><br><span class="line">        postfix: String = &quot;)&quot;</span><br><span class="line">): String &#123;</span><br><span class="line">    val sb = StringBuffer(prefix)</span><br><span class="line"></span><br><span class="line">    for ((index, element) in collection.withIndex()) &#123;</span><br><span class="line">        if (index &gt; 0) &#123;</span><br><span class="line">            sb.append(separator)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(postfix)</span><br><span class="line"></span><br><span class="line">    return sb.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Kotlin调用joinToString（）支持如下，最后一个我们同时使用了Kotlin的命名参数和默认参数的特性。</p>
<pre><code>val list = arrayListOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Python&quot;, &quot;JavaScript&quot;, &quot;Ruby&quot;, &quot;Go&quot;)
val s = joinToString(list)
val s2 = joinToString(list,&quot;,&quot;)
val s3 = joinToString(list,&quot;,&quot;,&quot;[&quot;)
val s4 = joinToString(list,&quot;,&quot;,&quot;[&quot;,&quot;]&quot;)
val s5 = joinToString(list, prefix = &quot;[&quot;, postfix = &quot;]&quot;)
</code></pre><p>上述调用体现了方法重载，默认参数可提供方法重载的效果</p>
<p>上面出现的@JvmOverloads注解是用来做什么的呢？</p>
<p>默认参数特性，使用是有前提的：用Kotlin定义函数，并在Kotlin代码里调用该函数。因此，如果在Java文件里调用Kotlin定义的joinToString方法，默认不支持默认参数特性的，也即方法重载失效。</p>
<p>@JvmOverloads提供了让默认参数特性在Java环境也得到支持。原理是：kotlin代码编译成java代码时，会增加增加下面的方法，这些正是Java方法重载。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public final class StringUtils &#123;</span><br><span class="line">   public static final int count = 11;</span><br><span class="line"></span><br><span class="line">   @JvmOverloads</span><br><span class="line">   @NotNull</span><br><span class="line">   public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix, @NotNull String postfix) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(collection, &quot;collection&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(separator, &quot;separator&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(prefix, &quot;prefix&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(postfix, &quot;postfix&quot;);</span><br><span class="line">      StringBuffer sb = new StringBuffer(prefix);</span><br><span class="line"></span><br><span class="line">      Object element;</span><br><span class="line">      for(Iterator var6 = CollectionsKt.withIndex((Iterable)collection).iterator(); var6.hasNext(); sb.append(element)) &#123;</span><br><span class="line">         IndexedValue var5 = (IndexedValue)var6.next();</span><br><span class="line">         int index = var5.component1();</span><br><span class="line">         element = var5.component2();</span><br><span class="line">         if (index &gt; 0) &#123;</span><br><span class="line">            sb.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sb.append(postfix);</span><br><span class="line">      String var10000 = sb.toString();</span><br><span class="line">      Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;sb.toString()&quot;);</span><br><span class="line">      return var10000;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // $FF: synthetic method</span><br><span class="line">   // $FF: bridge method</span><br><span class="line">   @JvmOverloads</span><br><span class="line">   @NotNull</span><br><span class="line">   public static String joinToString$default(Collection var0, String var1, String var2, String var3, int var4, Object var5) &#123;</span><br><span class="line">      if ((var4 &amp; 2) != 0) &#123;</span><br><span class="line">         var1 = &quot;,&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ((var4 &amp; 4) != 0) &#123;</span><br><span class="line">         var2 = &quot;(&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ((var4 &amp; 8) != 0) &#123;</span><br><span class="line">         var3 = &quot;)&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return joinToString(var0, var1, var2, var3);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @JvmOverloads</span><br><span class="line">   @NotNull</span><br><span class="line">   public static final String joinToString(@NotNull Collection collection, @NotNull String separator, @NotNull String prefix) &#123;</span><br><span class="line">      return joinToString$default(collection, separator, prefix, (String)null, 8, (Object)null);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @JvmOverloads</span><br><span class="line">   @NotNull</span><br><span class="line">   public static final String joinToString(@NotNull Collection collection, @NotNull String separator) &#123;</span><br><span class="line">      return joinToString$default(collection, separator, (String)null, (String)null, 12, (Object)null);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @JvmOverloads</span><br><span class="line">   @NotNull</span><br><span class="line">   public static final String joinToString(@NotNull Collection collection) &#123;</span><br><span class="line">      return joinToString$default(collection, (String)null, (String)null, (String)null, 14, (Object)null);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void testExtend(@NotNull Container $receiver) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull($receiver, &quot;$receiver&quot;);</span><br><span class="line">      String var1 = &quot;call the container testExtend method&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数关键词：vararg(分别取variate和arguments前三个字母)</p>
<p>来看一个Kotlin的Collections类里的一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a new [ArrayList] with the given elements.</span><br><span class="line"> * @sample samples.collections.Collections.Lists.arrayList</span><br><span class="line"> */</span><br><span class="line">public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt;</span><br><span class="line">        = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))</span><br></pre></td></tr></table></figure>
<p>调用</p>
<pre><code>val list = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
</code></pre><p>arrayListOf入参数量可以任意多个</p>
<p>Java实现可变参数，在数据类型后面加三个点：… ，看下Java里的Arrays里的一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">@SuppressWarnings(&quot;varargs&quot;)</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符 *"></a>展开运算符 *</h2><p>把数组展开成一个一个元素。展开运算符常与可变运算符联合使用。比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val array = arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">val list = arrayListOf(*array)</span><br></pre></td></tr></table></figure>
<p>我得到了一个ArrayList集合，集合里的元素是”a”, “b”, “c”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1933990-28eb61a91f733c41.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注CodeThings公众号"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Ethan Ruan" />
          <p class="site-author-name" itemprop="name">Ethan Ruan</p>
           
              <p class="site-description motion-element" itemprop="description">Java Coder & Kotlin Lover</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ethan Ruan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
